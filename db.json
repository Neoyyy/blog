{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RBah.woff2","path":"fonts/LinBiolinum_RBah.woff2","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RIah.woff2","path":"fonts/LinBiolinum_RIah.woff2","modified":0,"renderable":0},{"_id":"source/images/imageForPost/类加载器-pic-1.png","path":"images/imageForPost/类加载器-pic-1.png","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_Rah.woff2","path":"fonts/LinBiolinum_Rah.woff2","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_Rah.woff","path":"fonts/LinBiolinum_Rah.woff","modified":0,"renderable":0},{"_id":"source/images/imageForPost/一个成熟的博客/jenkins.png","path":"images/imageForPost/一个成熟的博客/jenkins.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/类加载器-pic-2.jpg","path":"images/imageForPost/类加载器-pic-2.jpg","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RIah.woff","path":"fonts/LinBiolinum_RIah.woff","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg","path":"images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RBah.woff","path":"fonts/LinBiolinum_RBah.woff","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/iobuffer扩大.JPG","path":"images/imageForPost/socket/Mina/iobuffer扩大.JPG","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/报文格式.png","path":"images/imageForPost/socket/Mina/报文格式.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/面向谷歌编程.png","path":"images/imageForPost/socket/Mina/面向谷歌编程.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/解包步骤.png","path":"images/imageForPost/socket/Mina/解包步骤.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png","path":"images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png","path":"images/imageForPost/Linux/openTooManyFiles/mac-set-error.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/security-limits.png","path":"images/imageForPost/Linux/openTooManyFiles/security-limits.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png","path":"images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RBah.eot","path":"fonts/LinBiolinum_RBah.eot","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_Rah.eot","path":"fonts/LinBiolinum_Rah.eot","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_Rah.ttf","path":"fonts/LinBiolinum_Rah.ttf","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png","path":"images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/MinaException2.jpg","path":"images/imageForPost/socket/Mina/MinaException2.jpg","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/动态代理/静态代理图1.png","path":"images/imageForPost/笔记/动态代理/静态代理图1.png","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RBah.ttf","path":"fonts/LinBiolinum_RBah.ttf","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RIah.eot","path":"fonts/LinBiolinum_RIah.eot","modified":0,"renderable":0},{"_id":"source/fonts/LinBiolinum_RIah.ttf","path":"fonts/LinBiolinum_RIah.ttf","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png","path":"images/imageForPost/Linux/openTooManyFiles/ulimit-a.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png","path":"images/imageForPost/Linux/openTooManyFiles/ulimit-n.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/testJava.png","path":"images/imageForPost/Linux/openTooManyFiles/testJava.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/动态代理/cglib代理图1.png","path":"images/imageForPost/笔记/动态代理/cglib代理图1.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/CAS/CASResult.png","path":"images/imageForPost/笔记/CAS/CASResult.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/CAS/FFAResult.png","path":"images/imageForPost/笔记/CAS/FFAResult.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/动态代理/transient图1.png","path":"images/imageForPost/笔记/动态代理/transient图1.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/proc-limits.png","path":"images/imageForPost/Linux/openTooManyFiles/proc-limits.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/CAS/LockResult.png","path":"images/imageForPost/笔记/CAS/LockResult.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-error.png","path":"images/imageForPost/Linux/openTooManyFiles/run-error.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-succ.png","path":"images/imageForPost/Linux/openTooManyFiles/run-succ.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/笔记/动态代理/jdk代理图1.png","path":"images/imageForPost/笔记/动态代理/jdk代理图1.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/prod-err.png","path":"images/imageForPost/Linux/openTooManyFiles/prod-err.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-command.png","path":"images/imageForPost/Linux/openTooManyFiles/run-command.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png","path":"images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png","modified":0,"renderable":0},{"_id":"source/images/imageForPost/socket/Mina/MinaException1.png","path":"images/imageForPost/socket/Mina/MinaException1.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar/avatar.png","path":"images/avatar/avatar.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/pure/.gitignore","hash":"dbb41a2f30c98cb9de173d82736c46266c901cda","modified":1564658232000},{"_id":"themes/pure/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1564658232000},{"_id":"themes/pure/README.cn.md","hash":"a634af4addbb57088935e060e8ec6035ea7bab76","modified":1564658232000},{"_id":"themes/pure/README.md","hash":"5861cec81712af9197a210fd5212d007aad8b0de","modified":1564658232000},{"_id":"themes/pure/_config.yml","hash":"12d23d728c7bcb721eda3466a237697a6e7837ec","modified":1569926307992},{"_id":"themes/pure/_config.yml.example","hash":"4714f87fdb6d4a6ea5ece84f4fe37f922337f14d","modified":1564658232000},{"_id":"themes/pure/package.json","hash":"a61723eead5cae2c4d9f0f05cf40d2de7c286fee","modified":1564658232000},{"_id":"source/about/index.md","hash":"9bc1d091991d333364a931d6041a30bc1f31e260","modified":1580308304241},{"_id":"source/_data/links.yml","hash":"94c2d90d31d197b5024b8a1e945bdd24960a8216","modified":1569924791533},{"_id":"source/_posts/一个成熟的博客.md","hash":"62d4c01433bfb699b82a16de18eeb7d72c894d55","modified":1570033103356},{"_id":"source/_posts/.DS_Store","hash":"d1274c3fc82c3bc9e88c00c73795af05f9214d66","modified":1579532365241},{"_id":"source/categories/index.md","hash":"1da3e69e720fc9a3e3cd87b93ad0a2aa9d91868a","modified":1580229485359},{"_id":"source/images/favicon-16x16.png","hash":"894c0db3d9b5b6ca36fe12ce7a008f3b8cd7d73f","modified":1559571460004},{"_id":"source/images/favicon-32x32.png","hash":"5acdd2eefc6574354069eefdb10add9c62649014","modified":1559571460004},{"_id":"source/images/favicon.png","hash":"c5895639bad16f83947cea62592ad26f6dabd93f","modified":1559571460004},{"_id":"source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1564658232000},{"_id":"source/images/.DS_Store","hash":"967961277c6acc37494d6a73ae76b90a70bb0d0f","modified":1579265753364},{"_id":"source/tags/index.md","hash":"f6b7069126ae1a4bf77bdd78e4c246486755a8fb","modified":1580229465095},{"_id":"themes/pure/languages/default.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1564658232000},{"_id":"themes/pure/languages/en.yml","hash":"167ea0db98f4db156ea68c4644f64c0287ae2b6f","modified":1564658232000},{"_id":"themes/pure/languages/zh-CN.yml","hash":"057ebc043f09449af9768791c89c86dfc2938365","modified":1564658232000},{"_id":"themes/pure/languages/zh-TW.yml","hash":"6d27c3114be539b8783ffce944f68b2e26a8c3b9","modified":1564658232000},{"_id":"themes/pure/layout/about.ejs","hash":"4f5c769e183249b12eb9d3141432bc0039519730","modified":1564658232000},{"_id":"themes/pure/layout/archive.ejs","hash":"ded5d953b35666e30f4c6e48e2d2c62af8d95ebf","modified":1564658232000},{"_id":"themes/pure/layout/books.ejs","hash":"6c64719cd7071b5319b01339aa524fdaab391385","modified":1564658232000},{"_id":"themes/pure/layout/categories.ejs","hash":"22a2bc1712dd9ba1a3027e875d636132d334fb00","modified":1564658232000},{"_id":"themes/pure/layout/category.ejs","hash":"3ca5651bbce7b0c280c906468f2eb18c2e55ebcb","modified":1564658232000},{"_id":"themes/pure/layout/index.ejs","hash":"07825d8d8b21eb7b694f5585567b9df5c5a91a60","modified":1564658232000},{"_id":"themes/pure/layout/links.ejs","hash":"77c5d1561e2c606c5b3bb39610133d84324074df","modified":1564658232000},{"_id":"themes/pure/layout/layout.ejs","hash":"a29ab2e881954a252bfc0dc1a7eb5aa52768dd2a","modified":1564658232000},{"_id":"themes/pure/layout/post.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1564658232000},{"_id":"themes/pure/layout/page.ejs","hash":"5c27475c176627e6e2e6a16172eb6980e56bcaff","modified":1564658232000},{"_id":"themes/pure/layout/repository.ejs","hash":"fe4b3e051a8b0debe9ee22c2cc2cc935d92ee23f","modified":1564658232000},{"_id":"themes/pure/layout/tag.ejs","hash":"df60564c162f7ad3422f8959dfea19351857a7cd","modified":1564658232000},{"_id":"themes/pure/layout/tags.ejs","hash":"29f19a6ed10f8b1f069259a7aeaaacddcfaa2ed4","modified":1564658232000},{"_id":"themes/pure/scripts/thumbnail.js","hash":"e667a611f9baac270281b765832020d50bf8fb7f","modified":1564658232000},{"_id":"themes/pure/source/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1564658232000},{"_id":"source/.DS_Store","hash":"d0019736fab9549b03cc58f9ced83ee506cdb117","modified":1579265753369},{"_id":"themes/pure/screenshot/pure-theme-black.png","hash":"10b40f398af7eb7e8ba2bf2f2a959d8779fc1fe1","modified":1564658232000},{"_id":"themes/pure/screenshot/pure-theme-green.png","hash":"12ec0c6033cb2762839fdf75434bbb4fbf946022","modified":1564658232000},{"_id":"themes/pure/screenshot/pure-theme-blue.png","hash":"6146890a68d5ea9d343c48d50151ddd5a2a1872c","modified":1564658232000},{"_id":"themes/pure/screenshot/pure-theme-purple.png","hash":"9855d2eb0acd23370209354f232471df8f4f72e2","modified":1564658232000},{"_id":"themes/pure/screenshot/pure.png","hash":"8f4cfd8d7edfa4fbffdf375291302d9807f5cc1c","modified":1564658232000},{"_id":"source/_posts/linux/应用too many files异常.md","hash":"4b49a60d4aea0ecc3e99484cb9c21761eb8359d3","modified":1580303691587},{"_id":"source/_posts/java虚拟机/虚拟机如何执行方法调用.md","hash":"6154604c16095bdf30c5ef176bf7df9c853a1b4d","modified":1580284178019},{"_id":"source/_posts/java虚拟机/jvm内存区域.md","hash":"217698ba50a93d57622caf880d5912c21f39f652","modified":1580304941188},{"_id":"source/_posts/java虚拟机/类加载器.md","hash":"c6244d88154555afe1e6eb8f3af5ea44749f886f","modified":1580306477112},{"_id":"source/_posts/socket/.DS_Store","hash":"dd214aead8de2941c9b5224c6af3ba2780999f68","modified":1572516358433},{"_id":"source/_posts/socket/使用netty实现一个简单的rpc调用.md","hash":"c0efee43e64c5e80963bc1740c430a74104bf602","modified":1580284225080},{"_id":"source/_posts/设计模式/单例模式.md","hash":"75d119becc59686cd410384fd0976870dac05f3d","modified":1580304387536},{"_id":"source/_posts/socket/记一次排查生产Mina框架BufferUnderflowException异常.md","hash":"e5e9c129bc096f9939b664fc22a371c30aec1dbb","modified":1580305665008},{"_id":"source/_posts/设计模式/常用设计模式.md","hash":"4165aa81930f3553dd69168fd015ab1e1736402d","modified":1571579162946},{"_id":"source/_posts/笔记/JAVA CAS.md","hash":"1d9aa8eea46afc5810f97f7eb4d29764dbc9bfab","modified":1580305790476},{"_id":"source/_posts/笔记/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1571233753886},{"_id":"source/_posts/笔记/HashMap.md","hash":"07f715a5836835e527742d1554647f0b90e82092","modified":1572273855986},{"_id":"source/_posts/笔记/JAVA 动态代理与Spring AOP  .md","hash":"f6c18b2759c01d81f800369ab36a00585c046e4d","modified":1580306143250},{"_id":"source/_posts/笔记/Linux命令.md","hash":"000c9fc8d6fafbe97f8a6348213694de9f21a019","modified":1571578924067},{"_id":"source/_posts/笔记/线程生命周期.md","hash":"f03b73fbb8c3b0c72777bcfe761657733894e9ce","modified":1572269462719},{"_id":"themes/pure/_source/_data/gallery.yml","hash":"e2b3fad87be3d1cfde1effa655d39678ee90907e","modified":1564658232000},{"_id":"themes/pure/_source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1564658232000},{"_id":"themes/pure/_source/_data/links.yml","hash":"aa443a4508550820c77c2a4f6abff1d38ad85054","modified":1564658232000},{"_id":"themes/pure/_source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1564658232000},{"_id":"themes/pure/_source/about/index.md","hash":"9c95cabb533409d06daefc4295021ad199761efc","modified":1564658232000},{"_id":"themes/pure/_source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1564658232000},{"_id":"themes/pure/_source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1564658232000},{"_id":"themes/pure/_source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1564658232000},{"_id":"themes/pure/layout/_common/footer.ejs","hash":"cdc48ec70d9202b947f2a9334234d038d7014a7d","modified":1564658232000},{"_id":"themes/pure/layout/_common/head.ejs","hash":"a48ef0fa22712b29ec044b9e5134461f3a21c10d","modified":1564658232000},{"_id":"themes/pure/_source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1569906020966},{"_id":"themes/pure/layout/_common/header.ejs","hash":"3d739d1e2b2991927c08ec222db123830a44a519","modified":1564658232000},{"_id":"themes/pure/layout/_common/script.ejs","hash":"0031114d2a58f8601c2869f78ceedc75a10be90d","modified":1564658232000},{"_id":"themes/pure/layout/_common/social.ejs","hash":"a35a2610e9da762df96587b76b51470507a88cad","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-book.ejs","hash":"977f97f3636947006ad738e502858c46d4cd5ec7","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-category.ejs","hash":"9c364fd6b5172890784141802f5f466241d233fd","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-link.ejs","hash":"fe4d9bf526d8176683cea89b8561ced571374db0","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-list.ejs","hash":"c66c86d6a6a90e00494c380603426fc0f4006311","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-post.ejs","hash":"13039fec017332029122ef99901755fcecbfc8ea","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-repository.ejs","hash":"e39dc762d9fe238cede462532e40eaa3d8651122","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive-tag.ejs","hash":"5de90244c3cedad531cccc03c40e5f9a3aef3c61","modified":1564658232000},{"_id":"themes/pure/layout/_partial/archive.ejs","hash":"4d6793f50d41fbd47dc50aa36b24d496006bba6c","modified":1564658232000},{"_id":"themes/pure/layout/_partial/article-about.ejs","hash":"7b80319daeb63401d1745b81cd9a6d1d21a4fb60","modified":1564658232000},{"_id":"themes/pure/layout/_partial/article.ejs","hash":"0f9b71de0087d1f777d92c5a0f3873971aec5a5b","modified":1564658232000},{"_id":"themes/pure/layout/_partial/item-post.ejs","hash":"9f755b0da1ea928dece32c2050d8a04b3a9fb13b","modified":1564658232000},{"_id":"themes/pure/layout/_partial/pagination.ejs","hash":"41a319642da5af07d6cfb8525796aa610b721879","modified":1564658232000},{"_id":"themes/pure/layout/_partial/sidebar-about.ejs","hash":"e10ea0176ba87e64888234bafedc01c92544352c","modified":1564658232000},{"_id":"themes/pure/layout/_partial/sidebar-toc.ejs","hash":"152538ceceb0fdef65c46470ebf0189f7b891c5b","modified":1564658232000},{"_id":"themes/pure/layout/_partial/sidebar.ejs","hash":"2aa8a9f90838e7c105e75e6d3d03cbf860bb1239","modified":1564658232000},{"_id":"themes/pure/layout/_script/analytics.ejs","hash":"e756a81f8c20a187fb863b9689f2f1fa15e2f4e1","modified":1564658232000},{"_id":"themes/pure/layout/_script/comment.ejs","hash":"6f951510bab9dc15474b6664e0329defccf29a30","modified":1564658232000},{"_id":"themes/pure/layout/_script/douban.ejs","hash":"143087db0573772b0bdaf7f93312553158942ec7","modified":1564658232000},{"_id":"themes/pure/layout/_script/fancybox.ejs","hash":"8f1be01e70a15b2c31ae57d8c6bce54622ebf8a7","modified":1564658232000},{"_id":"themes/pure/layout/_script/mathjax.ejs","hash":"f618393ab971b2faa80d541f2e6a553d9ace9816","modified":1564658232000},{"_id":"themes/pure/layout/_script/pv.ejs","hash":"fb9b5f16029f2ccef4b83cf4facfdcdd748b65b4","modified":1564658232000},{"_id":"themes/pure/layout/_script/repository.ejs","hash":"14f2e7d4c1055ff6a5f5867dc0e9a9f6f4c28fe1","modified":1564658232000},{"_id":"themes/pure/layout/_script/search.ejs","hash":"7be33dc260ce788aa1a2cd3bd0386d95057533cb","modified":1564658232000},{"_id":"themes/pure/layout/_search/baidu.ejs","hash":"67aab280a3ea34429f086cc5c3de7de17727c567","modified":1564658232000},{"_id":"themes/pure/layout/_search/index-mobile.ejs","hash":"c726e234c0166da69fdfbd3dd613a5eaf4c80258","modified":1564658232000},{"_id":"themes/pure/layout/_search/index.ejs","hash":"f8d5a9c3f777250f5fb6512bba585307f784d5cd","modified":1564658232000},{"_id":"themes/pure/layout/_search/insight.ejs","hash":"4af3e92ef98bedba9680d45699cb04dde4640536","modified":1564658232000},{"_id":"themes/pure/layout/_search/swiftype.ejs","hash":"4baeca36e410181300ae7d47ba1fb4755bcfcff0","modified":1564658232000},{"_id":"themes/pure/layout/_widget/archive.ejs","hash":"af8ad7f62877764b75d5272d9d899fd6c8e3845c","modified":1564658232000},{"_id":"themes/pure/layout/_widget/board.ejs","hash":"acd27451be52703e670ce0b313f2da6fa24071e4","modified":1564658232000},{"_id":"themes/pure/layout/_widget/category.ejs","hash":"331b7642a0f58b9088b937436ab39076a4c5dd7e","modified":1564658232000},{"_id":"themes/pure/layout/_widget/recent_posts.ejs","hash":"8942d60311797a591ba2d157c5cdd23e85ceb694","modified":1564658232000},{"_id":"themes/pure/layout/_widget/tag.ejs","hash":"487628925da5fcac91463cdad3d9e55d071bd5ed","modified":1564658232000},{"_id":"themes/pure/layout/_widget/tagcloud.ejs","hash":"3291108e5411c48b2c5b3e17adace6ffa90d1c29","modified":1564658232000},{"_id":"themes/pure/source/fonts/README.md","hash":"c5772b99ad81291fb137b330813f866bdceea0a3","modified":1564658232000},{"_id":"themes/pure/source/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1564658232000},{"_id":"themes/pure/source/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1564658232000},{"_id":"themes/pure/source/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1564658232000},{"_id":"themes/pure/source/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1564658232000},{"_id":"themes/pure/source/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1564658232000},{"_id":"themes/pure/source/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1564658232000},{"_id":"themes/pure/source/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1564658232000},{"_id":"themes/pure/source/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1564658232000},{"_id":"source/images/imageForPost/.DS_Store","hash":"860b987e7ddec0fb4b720f10b446babdde434e46","modified":1579265753365},{"_id":"source/fonts/LinBiolinum_RBah.woff2","hash":"0a34bd40bc949bc1ac254f8cf89a8f7f9db81158","modified":1559571459987},{"_id":"source/fonts/LinBiolinum_RIah.woff2","hash":"a8f91419803cb9a681a5de8a304b15f5c4f85152","modified":1559571459996},{"_id":"source/images/imageForPost/类加载器-pic-1.png","hash":"bb6b5865591fc88c4336776870eed096d0f22e66","modified":1559571460005},{"_id":"source/fonts/LinBiolinum_Rah.woff2","hash":"b7c4117d7d34d159052ebd3cfb3bee8bc3880f7f","modified":1559571460003},{"_id":"themes/pure/source/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1564658232000},{"_id":"themes/pure/source/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1564658232000},{"_id":"themes/pure/source/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1564658232000},{"_id":"source/fonts/LinBiolinum_Rah.woff","hash":"f5775c065e0a451bedaa8126e2a2522204647be1","modified":1559571460003},{"_id":"source/images/imageForPost/Linux/.DS_Store","hash":"4ce85dfca9239a04aed65b24085319b23c4ca057","modified":1579395806737},{"_id":"source/images/imageForPost/socket/.DS_Store","hash":"9e3331c715dabbd1bea7ecd5a800460239666f7e","modified":1579265664503},{"_id":"source/images/imageForPost/一个成熟的博客/jenkins.png","hash":"0bb26fc367955b91705ca4542c95343b8cf09b17","modified":1559571460005},{"_id":"source/images/imageForPost/类加载器-pic-2.jpg","hash":"01b63167ffef2a32ec43b26933665bcb6063a3e0","modified":1559571460006},{"_id":"themes/pure/layout/_partial/post/category.ejs","hash":"fcee6b4aef8b6c4627831ff8dbb2d73478511426","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/comment.ejs","hash":"3c0da69fcea6ccfd97b82d50e740107a88eec5c4","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/date.ejs","hash":"7d4979652998abf92a64bfae8157b70d6e514057","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/copyright.ejs","hash":"91547d340e7126eac119e0ee34ee8c1e5affd2b7","modified":1569904053059},{"_id":"themes/pure/layout/_partial/post/donate.ejs","hash":"a251dc34d660601a2e8b7d98b3bfe2b9023dbbce","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/nav.ejs","hash":"95eabc0fe4033ec61b240a16eeaf7dc62a9e3da1","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/pv.ejs","hash":"ec3ccf322432afc2761f860c5a3000ac34d46e4c","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/tag.ejs","hash":"39f53ead07f75c181a7ba93e586dd1b8171620f1","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/thumbnail.ejs","hash":"080d5c5f3e95accf51893a7092695fe32d34a087","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1564658232000},{"_id":"themes/pure/layout/_partial/post/wordcount.ejs","hash":"bd06c4c8449ed96aabf655fe1ae3be1f0707b81e","modified":1564658232000},{"_id":"themes/pure/layout/_script/_analytics/baidu-analytics.ejs","hash":"f314be7860c1d5930f1600d010e3120ba5c85325","modified":1564658232000},{"_id":"themes/pure/layout/_script/_analytics/google-analytics.ejs","hash":"54f1dc9375cbdb65464e0ac1b58847aa5e8bc6a5","modified":1564658232000},{"_id":"themes/pure/layout/_script/_analytics/tencent-analytics.ejs","hash":"77defb41a1613a758ff5a6a5128c6107fc584190","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/disqus.ejs","hash":"a051e3eddc75586e69131c29ab8c89d69626e0fd","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/gitalk.ejs","hash":"fb01f1631c3ae7fe6211dc03233506cb344229be","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/gitment.ejs","hash":"a64852076483395738a398deb4c10bdb0f3b7b71","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/livere.ejs","hash":"5ab997d5ee4475d2f89f882fab4a52648dbe0e30","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/youyan.ejs","hash":"095649a173573d03b5845c2e331ec7be976b152a","modified":1564658232000},{"_id":"themes/pure/layout/_script/_comment/valine.ejs","hash":"acf81f9a59dc45f197d723f70484de5fcd166577","modified":1564658232000},{"_id":"themes/pure/layout/_script/_search/baidu.ejs","hash":"9b60ffa2e2725a993e9cecfb81ddedd9b9361011","modified":1564658232000},{"_id":"themes/pure/layout/_script/_search/insight.ejs","hash":"3543c11d060feaf9381b5d87564b01ffef0e0a59","modified":1564658232000},{"_id":"themes/pure/source/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1564658232000},{"_id":"themes/pure/source/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1564658232000},{"_id":"themes/pure/source/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1564658232000},{"_id":"themes/pure/source/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1564658232000},{"_id":"themes/pure/source/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1564658232000},{"_id":"themes/pure/source/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1564658232000},{"_id":"themes/pure/source/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1564658232000},{"_id":"themes/pure/source/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1564658232000},{"_id":"source/images/imageForPost/笔记/.DS_Store","hash":"1dfc7555c5d103014144eea1d868f82ddda4a5a9","modified":1569738337664},{"_id":"source/fonts/LinBiolinum_RIah.woff","hash":"599e3d7737a675a929a008e4db9afde58b494398","modified":1559571459995},{"_id":"source/images/avatar.png","hash":"a0cadff5db3b392e76843d91677072c8f1cd7a91","modified":1559571460004},{"_id":"source/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg","hash":"057f45f6604de941b58958e2b0ee0e6d16b04da6","modified":1559571460005},{"_id":"themes/pure/source/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1564658232000},{"_id":"source/fonts/LinBiolinum_RBah.woff","hash":"af3aaf51e7b72ab26135b3320aa51c0b9eb39e80","modified":1559571459986},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/.DS_Store","hash":"3675693c4ba4cc2eb295231159bcc57d09512e6c","modified":1579335702570},{"_id":"source/images/imageForPost/socket/Mina/iobuffer扩大.JPG","hash":"5a0107bf222622716f409167cc33587edf81fc13","modified":1570776968000},{"_id":"source/images/imageForPost/socket/Mina/报文格式.png","hash":"04ca7db85e1a6b8cac769c4803feec96691314dc","modified":1570779204702},{"_id":"source/images/imageForPost/笔记/CAS/.DS_Store","hash":"e466f08b92c33aad53597d21fecbf90d716e5412","modified":1569738327202},{"_id":"source/images/imageForPost/socket/Mina/面向谷歌编程.png","hash":"f0495b181d7dda558c32899f33c8ad14457191ec","modified":1570779957693},{"_id":"source/images/imageForPost/socket/Mina/解包步骤.png","hash":"83c553fb9ce3682dc6266469fd33178292e4c626","modified":1570776615858},{"_id":"source/images/imageForPost/笔记/动态代理/.DS_Store","hash":"8a7662c0d82ec0ebc9040614b0fdc1b35d6dfb7b","modified":1561563491886},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png","hash":"3258789a5e5dee403c1081fbe7e6110e70fd6b64","modified":1579269814021},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png","hash":"50c11be4943a37ff9c198c5bca832e6bc8493635","modified":1579269781082},{"_id":"themes/pure/source/images/avatar.png","hash":"a0cadff5db3b392e76843d91677072c8f1cd7a91","modified":1569499390317},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/security-limits.png","hash":"1aefa52fea264cebaf81d8f8cbeb602844fcdd29","modified":1579266180857},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png","hash":"6b6c39d220d0b0c9f3a9ce33e801fa40465dcfc8","modified":1579270161693},{"_id":"source/fonts/LinBiolinum_RBah.eot","hash":"c591024cb23a2b26286a032377dafce7e2d15566","modified":1559571459982},{"_id":"source/fonts/LinBiolinum_Rah.eot","hash":"28505bf2f9698218e76b1bfd3cd69e275887f36e","modified":1559571459999},{"_id":"source/fonts/LinBiolinum_Rah.ttf","hash":"73119c2f63274fd0825c53ec639511ae2f1601ce","modified":1559571460002},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png","hash":"14929c99758f2da6c3bf7604d7e03450c85ab892","modified":1579267693821},{"_id":"source/images/imageForPost/socket/Mina/MinaException2.jpg","hash":"cf8f166fab69550e1fd46d1713284bd5c51da9af","modified":1570779850283},{"_id":"source/images/imageForPost/笔记/动态代理/静态代理图1.png","hash":"c769404169e74e37300e297687a122a6bcba30db","modified":1561471001934},{"_id":"source/fonts/LinBiolinum_RBah.ttf","hash":"50ee376e29207e4e8d9dc2c936efe4997451859d","modified":1559571459986},{"_id":"source/fonts/LinBiolinum_RIah.eot","hash":"71f1a4a78e81d8c12e77846950d1945015f9b409","modified":1559571459991},{"_id":"source/fonts/LinBiolinum_RIah.ttf","hash":"79289593787b336918d71bd624266c6d1ac26c97","modified":1559571459995},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png","hash":"54b213c5f4ade3709c7286459531a236e8a64b05","modified":1579273607536},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png","hash":"8102caa864146734b8718f1734098e883300c0e3","modified":1579265923162},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/testJava.png","hash":"73dba0bfd6ee258996004d3a1b17501c5cfc98fd","modified":1579266592263},{"_id":"source/images/imageForPost/笔记/动态代理/cglib代理图1.png","hash":"be4df3b33ad36199eacb93088ae8015c40ef3265","modified":1561556087688},{"_id":"source/images/imageForPost/笔记/CAS/CASResult.png","hash":"705a01cdd762be965c8eeb5f3b8ba05580b43e7a","modified":1569682853399},{"_id":"source/images/imageForPost/笔记/CAS/FFAResult.png","hash":"90bba515bd754e807aab9ba181670670bc1638c3","modified":1569683464283},{"_id":"source/images/imageForPost/笔记/动态代理/transient图1.png","hash":"c49a6de4fe413428eaec04186ec9ec9f18661e93","modified":1561560281345},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/proc-limits.png","hash":"cba8de975053b6749605a8a992638b4429095dae","modified":1579266073614},{"_id":"source/images/imageForPost/笔记/CAS/LockResult.png","hash":"0fc70e86b971d59324b1ec6b005930821213c437","modified":1569684440955},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-error.png","hash":"8b27087b1df545c25b417650962bfb9d59c554eb","modified":1579267943417},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-succ.png","hash":"82f6f94e077237fba46fa4bc4b9bfd762ab733c0","modified":1579270245862},{"_id":"source/images/imageForPost/笔记/动态代理/jdk代理图1.png","hash":"6e8abdac2b4976988627a69d933f3ecb700ee366","modified":1561554120860},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/prod-err.png","hash":"c4bd353884e9ba65ddbad0538176b3e2bc43f1e0","modified":1579273470815},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/run-command.png","hash":"2e72c2d918abe89693e7ba3884b1c5abd2f486bf","modified":1579274253957},{"_id":"source/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png","hash":"762bb39d9db1e6b84a73f5ecf3699cd480b458ac","modified":1579273695651},{"_id":"source/images/imageForPost/socket/Mina/MinaException1.png","hash":"0237a5175b1d4f1f15779ba30418f728cad80d16","modified":1570779142024},{"_id":"themes/pure/screenshot/pure.psd","hash":"a31cea40b45bdc31f051fca2f1e2f4ecbaee1a94","modified":1564658232000},{"_id":"public/atom.xml","hash":"fd9e0605066ed19d90387e1df7aacadb6e8332df","modified":1579341783011},{"_id":"public/search.xml","hash":"03d655cedaf88865013f5846c282dc7216b9af8d","modified":1579341783231},{"_id":"public/archives/2019/02/index.html","hash":"c6f9ec11d2f8372486817f773f236e63d96817f5","modified":1579274585984},{"_id":"public/archives/2019/03/index.html","hash":"eae38e2fb58225e5156b31d12f6358d7bb6f24e2","modified":1579274585984},{"_id":"public/archives/2019/06/index.html","hash":"9c6c1ab65c549401900897c9dd4a721ff03afea3","modified":1579274586090},{"_id":"public/categories/记录/index.html","hash":"27e824bda6037aa13713f7302c5f320c2869cb47","modified":1579274586090},{"_id":"public/categories/买的课怎么也得学完/index.html","hash":"bd8f263a6db0d97b79e2b8b2f9809a82806335ef","modified":1579274586093},{"_id":"public/tags/devops/index.html","hash":"e8f8662f23dfe066661c76188e2e3bf4d2d751a8","modified":1579274586093},{"_id":"public/baidusitemap.xml","hash":"193dd4b15a0b05c38e85f6ec0f9ba496cc0b3d5c","modified":1579341689328},{"_id":"public/content.json","hash":"eb3f9680c1db05d02a4df42a9bf54f936614b6f1","modified":1579341783011},{"_id":"public/sitemap.xml","hash":"8c6baa49e8d1e0a9e5b19a0b073d2c7dd0ee73da","modified":1579341783232},{"_id":"public/about/index.html","hash":"56a6e2da3853a8a5ac8cf02eef2831899fcbda0b","modified":1579274586093},{"_id":"public/categories/index.html","hash":"9b8aabc43e8ba5fc77cd98ff5504fe11c413a18b","modified":1579274586093},{"_id":"public/tags/index.html","hash":"1060ac44ca0b78f2ed8968d9ab21eaa56020d0f1","modified":1579274586093},{"_id":"public/2019/06/26/笔记/JAVA 动态代理与Spring AOP  /index.html","hash":"17c855a4573505fd0a5cf8ad2f27fd28c99896c2","modified":1579274586093},{"_id":"public/2019/03/30/java虚拟机/虚拟机如何执行方法调用/index.html","hash":"ddb34c48114bbccce8e1f78514e0d942717b80e5","modified":1579274586093},{"_id":"public/2019/03/30/一个成熟的博客/index.html","hash":"0a9499f9dbd086f2fe5044c2d66d2714335f9d3a","modified":1579274586093},{"_id":"public/2019/02/24/java虚拟机/类加载器/index.html","hash":"886395c110e92af627c45ecde1eec549dd0df865","modified":1579274586093},{"_id":"public/archives/index.html","hash":"35b697bf3d400d4406126449a7bc14adb1260479","modified":1579274586093},{"_id":"public/archives/2019/index.html","hash":"105419617d6c4b282f91e1067ebec0022ca41bbc","modified":1579274586093},{"_id":"public/index.html","hash":"b6ceae6808eb1bd6079afabbc2ee8e8484c5c6bd","modified":1579274586094},{"_id":"public/tags/java/index.html","hash":"5462ff08b07a382977841e2b3c11fc99a7f51ad4","modified":1579274586094},{"_id":"public/links/index.html","hash":"dc39117b4050ef970d4c0f746a7eb6c7d809438d","modified":1579274586102},{"_id":"public/archives/2019/09/index.html","hash":"c9fd183cc2354cd9a45a6b889182784bae977830","modified":1579274586103},{"_id":"public/archives/2020/index.html","hash":"ecec3454e31fb150abbd6c8790491a38c63a0086","modified":1579274586106},{"_id":"public/archives/2020/01/index.html","hash":"647a43defa95aa118a7a3bae8f8e6956372c0ba2","modified":1579274586106},{"_id":"public/categories/归纳/index.html","hash":"8509f07abcf2f1b261d2c927299be1a8887c3885","modified":1579274586106},{"_id":"public/tags/Linux/index.html","hash":"7b2764a19c84f15046166738704d7333e2590f01","modified":1579274586106},{"_id":"public/2020/01/17/linux/应用too many files异常/index.html","hash":"4c1a884031d85116551ef45601591b4d2a480f7d","modified":1579341783243},{"_id":"public/2019/10/28/笔记/HashMap/index.html","hash":"12e7f28ca758ff7f46e5fc90f02e99bde69e7125","modified":1579274586106},{"_id":"public/2019/10/20/设计模式/单例模式/index.html","hash":"d96970edfccf0bfc94f33af760fdd7596de2b29d","modified":1579274586106},{"_id":"public/2019/10/17/笔记/线程生命周期/index.html","hash":"24d6cc1577f954f541ae2357090e4df4aed62c37","modified":1579274586106},{"_id":"public/2019/10/16/笔记/Linux命令/index.html","hash":"be784d3932d2bf20dad3066685b758703405fd27","modified":1579274586106},{"_id":"public/2019/10/15/java虚拟机/jvm内存区域/index.html","hash":"1a67ee6dad4d05a1ad7a5dfc3e33c9cbcc9ef52f","modified":1579274586107},{"_id":"public/2019/10/11/socket/记一次排查生产Mina框架BufferUnderflowException异常/index.html","hash":"2d4f827e874da9693d3cef6f4ac03ea951571169","modified":1579274586107},{"_id":"public/2019/10/08/socket/使用netty实现一个简单的rpc调用/index.html","hash":"efeabe538fbd42581f2d01fabc30755b1d56622e","modified":1579274586107},{"_id":"public/2019/09/26/笔记/JAVA CAS/index.html","hash":"9eaab524756d8dc22207a46a5b031138a9046957","modified":1579274586107},{"_id":"public/2019/10/01/设计模式/常用设计模式/index.html","hash":"f2addf0ba19232e2c0b11cb6f899cb73349b2f61","modified":1579274586107},{"_id":"public/archives/2019/10/index.html","hash":"b0e1f99477ab0c2e408d9148d895a95542c28c5e","modified":1579274586107},{"_id":"public/categories/笔记/index.html","hash":"e4668ca2cad50781fc04f5482b3a1bcf2676bc0c","modified":1579274586107},{"_id":"public/page/2/index.html","hash":"ee3c16861d1002c95c749bdfc15c43ed86f5ada4","modified":1579274586107},{"_id":"public/tags/java/page/2/index.html","hash":"a177a66bcb72b1324fd880091b9d0541d12ef46d","modified":1579274586114},{"_id":"public/images/favicon-16x16.png","hash":"894c0db3d9b5b6ca36fe12ce7a008f3b8cd7d73f","modified":1579274586114},{"_id":"public/images/favicon-32x32.png","hash":"5acdd2eefc6574354069eefdb10add9c62649014","modified":1579274586114},{"_id":"public/images/favicon.png","hash":"c5895639bad16f83947cea62592ad26f6dabd93f","modified":1579274586114},{"_id":"public/images/imageForPost/一个成熟的博客/jenkins.png","hash":"0bb26fc367955b91705ca4542c95343b8cf09b17","modified":1579274586114},{"_id":"public/favicon.png","hash":"89875d3b018552e396fc5f0bd8ff5d9f5d4a5d71","modified":1579274586114},{"_id":"public/fonts/iconfont.eot","hash":"6819d9bb643bdeafc17bfecb0746ae641b018fdf","modified":1579274586114},{"_id":"public/fonts/iconfont.ttf","hash":"9b8837f9f79cf6ab794736301d0665345183a20c","modified":1579274586114},{"_id":"public/images/thumb-default.png","hash":"e8403b97ed9251f9f5207765b0ce796c5000b4ba","modified":1579274586114},{"_id":"public/fonts/iconfont.woff","hash":"78d29194287b8885d25212048c4f787705212a6e","modified":1579274586114},{"_id":"public/images/xingqiu-qrcode.jpg","hash":"ef2c2848dc79db6df7c752510651ed8ba57f2daf","modified":1579274586114},{"_id":"public/images/donate/alipayimg.png","hash":"9562f23f2eb57841c65dc769b6cc43a2cf0efa94","modified":1579274586114},{"_id":"public/images/favatar/SzsFox-logo.png","hash":"d71fcc73b7bc2a439d8c7ba461137856d190bd76","modified":1579274586115},{"_id":"public/images/donate/wechatpayimg.png","hash":"c0844d9a633696cb00ae64fde06f0f924f63b596","modified":1579274586115},{"_id":"public/images/favatar/chuangzaoshi-logo.png","hash":"7fa5734072050952159a02d330bbc008b5a99122","modified":1579274586115},{"_id":"public/images/favatar/idesign-logo.png","hash":"6b150a2dbb9912b7a7662255c27e4d4baaecee71","modified":1579274586115},{"_id":"public/images/imageForPost/socket/Mina/iobuffer扩大.JPG","hash":"5a0107bf222622716f409167cc33587edf81fc13","modified":1579274586115},{"_id":"public/images/imageForPost/socket/Mina/报文格式.png","hash":"04ca7db85e1a6b8cac769c4803feec96691314dc","modified":1579274586115},{"_id":"public/images/imageForPost/socket/Mina/面向谷歌编程.png","hash":"f0495b181d7dda558c32899f33c8ad14457191ec","modified":1579274586115},{"_id":"public/images/imageForPost/socket/Mina/解包步骤.png","hash":"83c553fb9ce3682dc6266469fd33178292e4c626","modified":1579274586115},{"_id":"public/images/imageForPost/类加载器-pic-1.png","hash":"bb6b5865591fc88c4336776870eed096d0f22e66","modified":1579274586124},{"_id":"public/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg","hash":"057f45f6604de941b58958e2b0ee0e6d16b04da6","modified":1579274586124},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png","hash":"3258789a5e5dee403c1081fbe7e6110e70fd6b64","modified":1579274586124},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png","hash":"50c11be4943a37ff9c198c5bca832e6bc8493635","modified":1579274586125},{"_id":"public/js/application.min.js","hash":"34d765e982c7d6360c37f82202d99f63ac40e408","modified":1579274586136},{"_id":"public/js/application.js","hash":"46d1fb207ce5f0acb83803f927985dfcea86f9ef","modified":1579274586136},{"_id":"public/fonts/README.html","hash":"43b6265aeccff3f9d495e2b44d07b249a2197bd7","modified":1579274586136},{"_id":"public/fonts/iconfont.svg","hash":"25929e6e74f7027acd1f6467a67e95b153bcd8d5","modified":1579274586136},{"_id":"public/js/plugin.js.map","hash":"1730c0cc660f863120aca0a439d7264e2e245fc5","modified":1579274586136},{"_id":"public/js/insight.js","hash":"298e8ca42517984bd26f34caa4c45560b0e909ad","modified":1579274586146},{"_id":"public/images/imageForPost/类加载器-pic-2.jpg","hash":"01b63167ffef2a32ec43b26933665bcb6063a3e0","modified":1579274586147},{"_id":"public/fonts/LinBiolinum_RIah.woff2","hash":"a8f91419803cb9a681a5de8a304b15f5c4f85152","modified":1579274586157},{"_id":"public/fonts/LinBiolinum_RBah.woff2","hash":"0a34bd40bc949bc1ac254f8cf89a8f7f9db81158","modified":1579274586157},{"_id":"public/fonts/LinBiolinum_Rah.woff2","hash":"b7c4117d7d34d159052ebd3cfb3bee8bc3880f7f","modified":1579274586157},{"_id":"public/fonts/LinBiolinum_Rah.woff","hash":"f5775c065e0a451bedaa8126e2a2522204647be1","modified":1579274586157},{"_id":"public/fonts/LinBiolinum_RIah.woff","hash":"599e3d7737a675a929a008e4db9afde58b494398","modified":1579274586165},{"_id":"public/images/avatar.png","hash":"a0cadff5db3b392e76843d91677072c8f1cd7a91","modified":1579274586165},{"_id":"public/fonts/LinBiolinum_RBah.woff","hash":"af3aaf51e7b72ab26135b3320aa51c0b9eb39e80","modified":1579274586165},{"_id":"public/images/imageForPost/笔记/动态代理/静态代理图1.png","hash":"c769404169e74e37300e297687a122a6bcba30db","modified":1579274586166},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png","hash":"14929c99758f2da6c3bf7604d7e03450c85ab892","modified":1579274586166},{"_id":"public/images/imageForPost/socket/Mina/MinaException2.jpg","hash":"cf8f166fab69550e1fd46d1713284bd5c51da9af","modified":1579274586166},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/security-limits.png","hash":"1aefa52fea264cebaf81d8f8cbeb602844fcdd29","modified":1579274586172},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png","hash":"6b6c39d220d0b0c9f3a9ce33e801fa40465dcfc8","modified":1579274586172},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png","hash":"54b213c5f4ade3709c7286459531a236e8a64b05","modified":1579274586173},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png","hash":"8102caa864146734b8718f1734098e883300c0e3","modified":1579274586173},{"_id":"public/images/imageForPost/笔记/动态代理/cglib代理图1.png","hash":"be4df3b33ad36199eacb93088ae8015c40ef3265","modified":1579274586180},{"_id":"public/images/imageForPost/笔记/动态代理/transient图1.png","hash":"c49a6de4fe413428eaec04186ec9ec9f18661e93","modified":1579274586180},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/proc-limits.png","hash":"cba8de975053b6749605a8a992638b4429095dae","modified":1579274586180},{"_id":"public/images/imageForPost/笔记/CAS/FFAResult.png","hash":"90bba515bd754e807aab9ba181670670bc1638c3","modified":1579274586181},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/testJava.png","hash":"73dba0bfd6ee258996004d3a1b17501c5cfc98fd","modified":1579274586185},{"_id":"public/images/imageForPost/笔记/CAS/LockResult.png","hash":"0fc70e86b971d59324b1ec6b005930821213c437","modified":1579274586185},{"_id":"public/images/imageForPost/笔记/CAS/CASResult.png","hash":"705a01cdd762be965c8eeb5f3b8ba05580b43e7a","modified":1579274586188},{"_id":"public/fonts/LinBiolinum_Rah.eot","hash":"28505bf2f9698218e76b1bfd3cd69e275887f36e","modified":1579274586191},{"_id":"public/fonts/LinBiolinum_Rah.ttf","hash":"73119c2f63274fd0825c53ec639511ae2f1601ce","modified":1579274586191},{"_id":"public/images/imageForPost/笔记/动态代理/jdk代理图1.png","hash":"6e8abdac2b4976988627a69d933f3ecb700ee366","modified":1579274586191},{"_id":"public/fonts/LinBiolinum_RBah.eot","hash":"c591024cb23a2b26286a032377dafce7e2d15566","modified":1579274586194},{"_id":"public/fonts/LinBiolinum_RBah.ttf","hash":"50ee376e29207e4e8d9dc2c936efe4997451859d","modified":1579274586195},{"_id":"public/fonts/LinBiolinum_RIah.eot","hash":"71f1a4a78e81d8c12e77846950d1945015f9b409","modified":1579274586196},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/prod-err.png","hash":"c4bd353884e9ba65ddbad0538176b3e2bc43f1e0","modified":1579274586196},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/run-command.png","hash":"2e72c2d918abe89693e7ba3884b1c5abd2f486bf","modified":1579274586197},{"_id":"public/js/plugin.min.js","hash":"07fe34638f9832702c5f81d8583c5e4e8b3d9659","modified":1579274586198},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/run-succ.png","hash":"82f6f94e077237fba46fa4bc4b9bfd762ab733c0","modified":1579274586199},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png","hash":"762bb39d9db1e6b84a73f5ecf3699cd480b458ac","modified":1579274586199},{"_id":"public/js/jquery.min.js","hash":"5a9dcfbef655a2668e78baebeaa8dc6f41d8dabb","modified":1579274586200},{"_id":"public/fonts/LinBiolinum_RIah.ttf","hash":"79289593787b336918d71bd624266c6d1ac26c97","modified":1579274586201},{"_id":"public/images/imageForPost/Linux/openTooManyFiles/run-error.png","hash":"8b27087b1df545c25b417650962bfb9d59c554eb","modified":1579274586210},{"_id":"public/js/plugin.js","hash":"a8524d42b8621bfaa06602a163c6a1f82702b91d","modified":1579274586217},{"_id":"public/images/imageForPost/socket/Mina/MinaException1.png","hash":"0237a5175b1d4f1f15779ba30418f728cad80d16","modified":1579274586217},{"_id":"public/css/style.min.css","hash":"1d23abc76726ebe042f7df4749f00f8f73338444","modified":1579274586223},{"_id":"public/css/style.css","hash":"3b693ce41c2e35ece4773593e94b4c17aeaee02f","modified":1579274586235},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1580040716000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1580040716000},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1580040716000},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1580040716000},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1580040716000},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1580040716000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1580040716000},{"_id":"themes/next/_config.yml","hash":"670ab28c82d5c1c8a4966a2b437a75eb992b9909","modified":1580290480796},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1580040716000},{"_id":"themes/next/README.md","hash":"dc026053a4d9fb97a58dbc3e9060e480f6852b23","modified":1580040716000},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1580040716000},{"_id":"themes/next/package.json","hash":"19dda7fab09594faba989669e29de88c4289877f","modified":1580040716000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1580040716000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ef63f34bd3b6bd4d7304d48ce5e0e3e2bead385","modified":1580040716000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"715dcf9b0429a4a4c7107d6d1d00a34e4cf9aa99","modified":1580040716000},{"_id":"themes/next/.github/config.yml","hash":"e4f4b9afe59bc508c4f7634895b33d7d460a7cb1","modified":1580040716000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1580040716000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1580040716000},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1580040716000},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1580040716000},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1580040716000},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1580040716000},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1580040716000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1580040716000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1580040716000},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1580040716000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"40a8089076005e0d26ef7c0db58a2b5b464cda6c","modified":1580040716000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1580040716000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1580040716000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1580040716000},{"_id":"themes/next/docs/MATH.md","hash":"f520b336f16665e164d6edf075bdcc6aa17b31bc","modified":1580040716000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"682937d48bf5d243842a76190921322e26c75247","modified":1580040716000},{"_id":"themes/next/languages/de.yml","hash":"285b294b1dd2ce49b0694beb4fd75ed05dc20ccb","modified":1580040716000},{"_id":"themes/next/languages/default.yml","hash":"89eb0cff04435307e4eccb0d72a653499627d02d","modified":1580040716000},{"_id":"themes/next/languages/en.yml","hash":"89eb0cff04435307e4eccb0d72a653499627d02d","modified":1580040716000},{"_id":"themes/next/languages/fa.yml","hash":"35468531ad0236df5b188f28bd1b4bb0c0537faf","modified":1580040716000},{"_id":"themes/next/languages/es.yml","hash":"3bd0977225a9b9dc3cdc856161b3a77e5993ac4a","modified":1580040716000},{"_id":"themes/next/languages/fr.yml","hash":"5fe560d14824c71ea90b2a76d0c17b2332b9d08a","modified":1580040716000},{"_id":"themes/next/languages/hu.yml","hash":"dd9e4cd2873ed9a9ae7cb89962eeff911de396b4","modified":1580040716000},{"_id":"themes/next/languages/id.yml","hash":"80c3db4c2dbbea0703f6c8f1191218f692899507","modified":1580040716000},{"_id":"themes/next/languages/it.yml","hash":"68ac5a0aa361210f51915e101c842ed1c9464889","modified":1580040716000},{"_id":"themes/next/languages/ja.yml","hash":"e61529ddf80426a5362ed07642216027615bd740","modified":1580040716000},{"_id":"themes/next/languages/ko.yml","hash":"14a162509dc71bb364335c20281d3bccbd2a51f3","modified":1580040716000},{"_id":"themes/next/languages/nl.yml","hash":"4d9b09aff03648cbbbfeb0c51a2d1214320b5ec6","modified":1580040716000},{"_id":"themes/next/languages/pt-BR.yml","hash":"024dcdeb30c93e57cd1ba4cd707f8988dcad2468","modified":1580040716000},{"_id":"themes/next/languages/pt.yml","hash":"88fb58e537a949c013a2adcdaebcbe09543c0bd2","modified":1580040716000},{"_id":"themes/next/languages/ru.yml","hash":"f7d5efd6289845f2375bbee8fe883813de745767","modified":1580040716000},{"_id":"themes/next/languages/tr.yml","hash":"e08d8d6ee9507a7c7d4450bc1c76b435470a3739","modified":1580040716000},{"_id":"themes/next/languages/uk.yml","hash":"e58393cf726401bf50a772392e23507d9e11049e","modified":1580040716000},{"_id":"themes/next/languages/vi.yml","hash":"0c0890ccffcb5cca0893de63ebad66e3ce740707","modified":1580040716000},{"_id":"themes/next/languages/zh-CN.yml","hash":"4b36a51556e87d236c6ac6ee6975de1beb95724c","modified":1580040716000},{"_id":"themes/next/languages/zh-HK.yml","hash":"6d83daf9df1811e3ae6cde5ad778c888d8027b13","modified":1580040716000},{"_id":"themes/next/languages/zh-TW.yml","hash":"5e395cb492a0b6284f8d2ffdd93f7380db31486f","modified":1580040716000},{"_id":"themes/next/layout/_layout.swig","hash":"29ee038b0d5ffdb45327598733ea968588367769","modified":1580040716000},{"_id":"themes/next/layout/archive.swig","hash":"26526c09a4334099e2141456697696fcd1f9783f","modified":1580040716000},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1580040716000},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1580040716000},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1580040716000},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1580040716000},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1580040716000},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1580040716000},{"_id":"source/_posts/pmp/启动过程组.md","hash":"ffadfbac7d7b94f6de9a99c31016ff9006f78614","modified":1580306439299},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"8ae029084b9ac482adf0fae2a0979dd388476513","modified":1580040716000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"7a9526f749205c882d672a4f51e6a3033c80ca6e","modified":1580040716000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"789a3cceb8f37a4b63b1fb2452a03332a3c365ed","modified":1580040716000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"89667adbb85c25716dba607cd7a38191acf60736","modified":1580040716000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1580040716000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1580040716000},{"_id":"themes/next/docs/ru/README.md","hash":"41b1bef32fb991410ebf559b4c45022549f95215","modified":1580040716000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"17d7203e85a8ce9760c42a853dee0f26a8f7ee4e","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"0b0b9ec6ec4a89e701a3b91f8d7d95752d3e241b","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"f0ffb74de522749c9f2fda46970a61bdafbfbc24","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"b6a3611d40863c12804c5846994786119ce3b79f","modified":1580040716000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"7f37327bbcae7ed7d04d187fd5e9bc6bbf14926a","modified":1580040716000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1580040716000},{"_id":"themes/next/layout/_macro/post.swig","hash":"049caf88e2cb8dde780b0c6196db984c7bc3a4cc","modified":1580040716000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"e2c9db54cc9e154e882008fde6588b065fadc9a7","modified":1580040716000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"0c4914a5fd08f15beec71940218c814ad9a89f3f","modified":1580040716000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"f50073293f4d1b957ff86a317baaed82f9512efe","modified":1580282442074},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1580040716000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1580040716000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1580040716000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1580040716000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"a3462c37ab6d7642b1e95860ea5c4cfbac78efab","modified":1580040716000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1580040716000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1580040716000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1580040716000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1580040716000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"dd6bd817cb69b5ad5e9746498146314b54054ff8","modified":1580040716000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1580040716000},{"_id":"themes/next/scripts/events/index.js","hash":"9047d8ae2670e43429b16a7919a08a0a0a81afe0","modified":1580040716000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1580040716000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1580040716000},{"_id":"themes/next/scripts/filters/locals.js","hash":"5bbfdc1c373542159660b7a68ed0b57ca18ad10b","modified":1580040716000},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1580040716000},{"_id":"themes/next/scripts/filters/post.js","hash":"5e5035372b3d94a65309334c93303c858e072012","modified":1580040716000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"cb211b6b50913454b1737782e9e2af96cfa40448","modified":1580040716000},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1580040716000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"58347687b02f7ab5e64bef07525c8efa97c9e8fb","modified":1580040716000},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1580040716000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1580040716000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1580040716000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1580040716000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1580040716000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1580040716000},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1580040716000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1580040716000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1580040716000},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1580040716000},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1580040716000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1580040716000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1580040716000},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1580040716000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1580040716000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1580040716000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1580040716000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1580040716000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1580040716000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1580040716000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1580040716000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1580040716000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1580040716000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1580040716000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1580040716000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1580040716000},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1580040716000},{"_id":"themes/next/source/js/bookmark.js","hash":"a00945ff886e9f6f835731cdaf29a3a3727c8877","modified":1580040716000},{"_id":"themes/next/source/js/local-search.js","hash":"9f3d3ddff86e7b2828772aba915a5ebfd7d9f55f","modified":1580040716000},{"_id":"themes/next/source/js/motion.js","hash":"26c6170bc861f33030084e15f9bd31e7e9050b0e","modified":1580040716000},{"_id":"themes/next/source/js/next-boot.js","hash":"f7045763e277e685c271bd4b4c37e531d699ac63","modified":1580040716000},{"_id":"themes/next/source/js/utils.js","hash":"a1e70ac9d32697907d5d78f2533d627f4df8ebcb","modified":1580040716000},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1580040716000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580040716000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580040716000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"1638483d2d2dad1da4c841a6fb9f6ee96b850187","modified":1580040716000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"0172055d118d1d7f4c8379c8495c1ee1aa50c7d9","modified":1580040716000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1580040716000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1580040716000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"e6076865dba066c5f0008e22217efb850d5af69c","modified":1580040716000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"bbf0c8e42491fac70f4f8165224f1d7d92a040d7","modified":1580040716000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"54ba9508a901c295a02c8e34e9cece7c7dcad518","modified":1580040716000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1580040716000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1580040716000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"94d54b0c65d504f772af1e62424952e092b6c21d","modified":1580040716000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1580040716000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1580040716000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"1b7faa20a458b46369779b57bcc695bbc5d1c13a","modified":1580040716000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1580040716000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1580040716000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1580040716000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"716b78cd90addc4216413719554721cb362b0c18","modified":1580040716000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"a2bb0bec243685e670b60a3d54142950adc03af0","modified":1580040716000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1580040716000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1580040716000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1580040716000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1580040716000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1580040716000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1580040716000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1580040716000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1580040716000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1580040716000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"d3dc3e051e6816cdd576d00cc70b18b8a4c6a495","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"ed236103bccbcf608f7d5d5b33b9f995d2f1a7de","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4d6f9e09ca4056ff6a5d4923e202126a75242183","modified":1580040716000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1580040716000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1580040716000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1580040716000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1580040716000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1580040716000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1580040716000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1580040716000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1580040716000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1580040716000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"0ea0bac09b0747bc16fde852164c0eaab2efe02c","modified":1580040716000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1580040716000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"801e1d2f59f7d2db4096c4788b8469b4165f4965","modified":1580040716000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1580040716000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1580040716000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1580040716000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"b205d72a56b1827681f0a260c266e0c02065fd08","modified":1580040716000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1f20213af8da3127701e6bb9da995e5c91be2051","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"19cbd24880d0fbbd4d5698cd54da598f03b942da","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1580040716000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6a72b5928cdab9526a288177991e4b2aedd028cf","modified":1580040716000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1580040716000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1580040716000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1580040716000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1580040716000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1580040716000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1580040716000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1580040716000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d4e817e2b238ace5d7ac568ce0c5380196a6d039","modified":1580040716000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"ae2a2502b77203e83f75a040c43e86a7ecb4873c","modified":1580040716000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"f068b46f8c305c7436c2767492a6bed42dcd764c","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1580040716000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1580040716000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"bc87cea0b534f2d75db60f300b069456f6516d1b","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4f7879a50d4608c46cc2061c725a2564597a45bd","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"8e1cc5e3b20d804a7265f945b877388bffee39eb","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"1693ec6b53758ac15d2c7798c789d6ae8af913ea","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4fb385d8533877678440c8faa08b68fa793cb1a2","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"a54662bd4cbbe316048a811d3b5c83fb6df63739","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"5adf2fdea25630893283e1ad5ba1721b698d6e95","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"71a3d7f2242706f7a6b79933a67ef3664cca3a24","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"84a3b8fe07fc790082ee988dd8f6c2536fde72de","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"b797c693378d94160121a2b8d9df0622a76cdbda","modified":1580040716000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"af182c0d1e52f94280f6108936914f04ed541eee","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"5d5c022aa3b2f89c2f2a178212338bb64804dd75","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"bcba503e956e4b737b062faa66341bd880f16c10","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9df5ba77e6cf36129bddc270407215c23c60ff38","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"eca4d80dd0df1c3b1bc06bd39e6a4bd6c56198df","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"284249dcfa3b49c5d76210bbb0f74f65fc2f12ea","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"a48ed1dc9978b1b621f0e12664738c0d855d8013","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1580040716000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"f5821481440a0624c8aec5fc85f093de1527095f","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"c27b3056d5e22d3c66d8a152a23634314d5c4a60","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"a237c290e8934d1a8cbbf22b3f30503d9663021d","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"521534f483440434e808f92377bc3fc73667c89a","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"6d8680894e24a516e2b5263af86b485767c3be63","modified":1580040716000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"b492a45422773ab2af06ee345d527ba4c6bbc608","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"b4923515ca8e44aa62e839ce948f759cfd1f896f","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"1a14c1b92d8a4dd8aabb5949333ac0ac79094c6c","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"d2f0f2171722533bba308f944a2ec727b083582c","modified":1580040716000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1580040716000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1580040716000},{"_id":"themes/next/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580228641886},{"_id":"themes/next/source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580228646893},{"_id":"themes/next/source/images/.DS_Store","hash":"f111ebc90839d42449b015fd652732efee21b6e8","modified":1580228637461},{"_id":"themes/next/source/images/avatar/avatar.png","hash":"a1883bd1ebb943869fc7982cb0e005cef0ec1b80","modified":1580228605439}],"Category":[{"name":"记录","_id":"ck5ibb8t50003d4rmqfydel1b"},{"name":"笔记","_id":"ck5ibb8uo000bd4rm8zwxubbd"},{"name":"买的课怎么也得学完","_id":"ck5ibb8ut000gd4rmvczdjv2a"},{"name":"归纳","_id":"ck5ibb8v2000td4rmxhjpeo75"},{"name":"总结","_id":"ck5z0hhk1000a95rmjotv52yx"}],"Data":[{"_id":"links","data":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}],"Page":[{"title":"about","date":"2019-02-21T04:39:04.000Z","type":"about","comments":0,"_content":"## 杭州   \n## java  \n## vue    \n\n---  \n\n养成记录的习惯...\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-02-21 12:39:04\ntype: \"about\"  \ncomments: false\n---\n## 杭州   \n## java  \n## vue    \n\n---  \n\n养成记录的习惯...\n","updated":"2020-01-29T14:31:44.241Z","path":"about/index.html","_id":"ck5ibb8sx0000d4rm5cyf30u6","layout":"page","content":"<h2 id=\"杭州\"><a href=\"#杭州\" class=\"headerlink\" title=\"杭州\"></a>杭州</h2><h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h2><hr>\n<p>养成记录的习惯…</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"","more":"<h2 id=\"杭州\"><a href=\"#杭州\" class=\"headerlink\" title=\"杭州\"></a>杭州</h2><h2 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h2><h2 id=\"vue\"><a href=\"#vue\" class=\"headerlink\" title=\"vue\"></a>vue</h2><hr>\n<p>养成记录的习惯…</p>\n"},{"title":"分类","date":"2019-02-21T06:46:26.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-02-21 14:46:26\ntype: \"categories\"  \ncomments: false\n---\n","updated":"2020-01-28T16:38:05.359Z","path":"categories/index.html","_id":"ck5ibb8t40002d4rmfejfnwr9","layout":"page","content":"","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","comments":1,"sidebar":"none","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\nlayout: links\ncomments: true\nsidebar: none\n---","date":"2019-10-01T04:35:56.957Z","updated":"2019-08-01T11:17:12.000Z","path":"links/index.html","_id":"ck5ibb8u20007d4rm4oi6jumo","content":"","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"","more":""},{"title":"标签","date":"2019-02-21T06:46:26.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-02-21 14:46:26\ntype: \"tags\"  \ncomments: false  \n---\n","updated":"2020-01-28T16:37:45.095Z","path":"tags/index.html","_id":"ck5ibb8u40008d4rml19lqm21","layout":"page","content":"","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"","more":""}],"Post":[{"title":"一个成熟的博客","date":"2019-03-30T05:39:04.000Z","comments":1,"_content":"\n\n\n\n![hexo_meitu_2](/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg)  \n<!-- more -->\n\n### 我要干啥  \n\n通过jenkins自动部署hexo博客，只需要将写好的博客推送到github仓库即可，作为一个记录，所以这不是一篇步骤性的教学文章！只是分享下方法，详细的教学文章很多，只需要打开搜索引擎，输入  \n\n```shell\njenkins \nhexo\ngithub\n```\n\n即可\n\n### 建博客的缘由\n\n虽然到现在还没有写博客，但是博客平台还是要建起来的，万一哪天就有可以写博客的内容了呢。虽然如掘金，简书等各大平台都可以发布博客，已经买了阿里云两年，那自然是要利用起来的，又不想浪费大量时间去从头开始写一个博客工程，那就考虑下现有的可以用来创建博客的工具--hexo吧，作为一个node应用，可以很方便的搭建起来，还能随意换主题，还可以使用github仓库的issues作为评论，只需要node.js环境和npm包管理器，通过nginx作为静态文件服务器就可以进行访问。\n\n### 如何让hexo自动构建  \n\n试过两种方法，打算使用github仓库的issues作为评论所以目前使用的是第二种方法  \n\n- 服务器搭建git，通过git hooks钩子在推送到git仓库后执行hexo g编译并复制到/var/www/blog文件夹下  \n- 通过jenkins关联github仓库，发现有推送就进行拉取并执行编译命令，编译完成后复制到web目录下，构建完成后发送邮件进行通知\n\n### 为什么要让博客自动构建  \n\n因为我懒啊，最原始方式部署博客的话，通过nginx引出hexo编译后的静态文件进行访问， 所以更新完博客的话需要推送github，然后本地执行hexo g编译再将编译后的文件通过ftp上传。\n\n第一种方式需要在服务器上创建git用户，并搭建git环境，创建git仓库。\n\n配置该用户的ssh key进行访问，使得hexo工程中配置好git仓库地址后，可以通过hexo的hexo d命令可以直接编译并推送到服务器上的git仓库。\n\n当有数据推送到服务器的git仓库后，通过git hooks执行复制脚本编译，并把文件复制到/var/ww/blog文件夹下进行访问。\n\n目前博客托管在github上，所以不想维护两个仓库，于是打算采用方式二\n\n### 让jenkins来构建博客  \n\n#### 主要构建过程  \n\nlocal: git push -> github \ngithub: 偶哟，有新的推送，该通知服务器上的jenkins干活了  \njenkins：是博客的仓库诶！拉取过来，执行预先写好的脚本进行编译、部署。搞定~邮件通知下\n\n收到了构建成功邮件，访问博客站点，看到了新博客\n\n------\n\n对于jenkins来说需要配置一个自动构建工程\n\n#### 自动构建工程配置  \n\n创建一个自动构建工程，指定github仓库地址，配上仓库的密钥key，使得jenkins在该仓库有更新时可以拉取数据，写好构建时要执行的shell脚本，当仓库更新并拉取数据后执行该脚本，构建后可以配置邮件通知，详细步骤可以参考网络上大量的教程文章。  \n\n#### 需要的环境准备   \n\n##### jenkins  \n\njenkins运行需要java环境，[jenkins官网](https://jenkins.io/) 下载到war包\n\n```shell\nnohup java -jar jenkins.war --httpPort={对外端口} & \n```\n\n 即可后台启动jenkins  \n\n![](/images/imageForPost/一个成熟的博客/jenkins.png)\n\n用于自动构建的脚本  \n\n```shell\nhexo clean\nnpm install\nhexo g\ncp -r ./public/. /var/www/blog\n```\n\njenkins拉取github仓库的推送后执行目录在/root/.jenkins/workspace/{jenkins工程目录}  \n\n所以脚本也是在jenkins工程目录为起点执行的\n\n##### node.js\n\nnode是一个JavaScript 运行环境，hexo是node.js上的一个静态博客框架，可以使用npm包管理器安装  \n\n```shell\nnpm install -g hexo-cli\n```\n\nhexo为npm安装的应用，目录在  {node应用目录}/lib/node_modules/hexo-cli/bin/目录下，需要将hexo通过ln命令创建一个全局可用的链接： ln -s {hexo真实目录} /usr/local/bin/hexo   \n\nnpm、node等命令出现找不到并确认已经安装即可使用相同方式处理      \n\n##### nginx  \n\nhexo编译结果为静态文件，只需访问index.html文件即可，所以附上nginx配置  \n\n```\nserver {\n    listen       80;\n    server_name  localhost;\n    location / {\n        root   /var/www/blog;\n        index  index.html index.htm;\n    }\n\n}\n\n```\n\n博客文件目录为/var/www/blog/，内容为hexo工程执行hexo g编译后public文件夹下的所有内容\n\nnginx启动默认是nginx用户\n\nnginx的启动配置文件中可以指定执行用户，如果该用户对博客静态文件文件夹没有读权限则访问时会报403 forbidden错误。\n\n------\n\n当环境准备好后hexo就已经是个成熟的博客啦，他可以自己完成部署，不需要我再手动搬运了~\n\n\n\n","source":"_posts/一个成熟的博客.md","raw":"---\ntitle: 一个成熟的博客\ndate: 2019-03-30 13:39:04\ncomments: true\ncategories: \n- 记录\ntags: \n- devops\n---\n\n\n\n\n![hexo_meitu_2](/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg)  \n<!-- more -->\n\n### 我要干啥  \n\n通过jenkins自动部署hexo博客，只需要将写好的博客推送到github仓库即可，作为一个记录，所以这不是一篇步骤性的教学文章！只是分享下方法，详细的教学文章很多，只需要打开搜索引擎，输入  \n\n```shell\njenkins \nhexo\ngithub\n```\n\n即可\n\n### 建博客的缘由\n\n虽然到现在还没有写博客，但是博客平台还是要建起来的，万一哪天就有可以写博客的内容了呢。虽然如掘金，简书等各大平台都可以发布博客，已经买了阿里云两年，那自然是要利用起来的，又不想浪费大量时间去从头开始写一个博客工程，那就考虑下现有的可以用来创建博客的工具--hexo吧，作为一个node应用，可以很方便的搭建起来，还能随意换主题，还可以使用github仓库的issues作为评论，只需要node.js环境和npm包管理器，通过nginx作为静态文件服务器就可以进行访问。\n\n### 如何让hexo自动构建  \n\n试过两种方法，打算使用github仓库的issues作为评论所以目前使用的是第二种方法  \n\n- 服务器搭建git，通过git hooks钩子在推送到git仓库后执行hexo g编译并复制到/var/www/blog文件夹下  \n- 通过jenkins关联github仓库，发现有推送就进行拉取并执行编译命令，编译完成后复制到web目录下，构建完成后发送邮件进行通知\n\n### 为什么要让博客自动构建  \n\n因为我懒啊，最原始方式部署博客的话，通过nginx引出hexo编译后的静态文件进行访问， 所以更新完博客的话需要推送github，然后本地执行hexo g编译再将编译后的文件通过ftp上传。\n\n第一种方式需要在服务器上创建git用户，并搭建git环境，创建git仓库。\n\n配置该用户的ssh key进行访问，使得hexo工程中配置好git仓库地址后，可以通过hexo的hexo d命令可以直接编译并推送到服务器上的git仓库。\n\n当有数据推送到服务器的git仓库后，通过git hooks执行复制脚本编译，并把文件复制到/var/ww/blog文件夹下进行访问。\n\n目前博客托管在github上，所以不想维护两个仓库，于是打算采用方式二\n\n### 让jenkins来构建博客  \n\n#### 主要构建过程  \n\nlocal: git push -> github \ngithub: 偶哟，有新的推送，该通知服务器上的jenkins干活了  \njenkins：是博客的仓库诶！拉取过来，执行预先写好的脚本进行编译、部署。搞定~邮件通知下\n\n收到了构建成功邮件，访问博客站点，看到了新博客\n\n------\n\n对于jenkins来说需要配置一个自动构建工程\n\n#### 自动构建工程配置  \n\n创建一个自动构建工程，指定github仓库地址，配上仓库的密钥key，使得jenkins在该仓库有更新时可以拉取数据，写好构建时要执行的shell脚本，当仓库更新并拉取数据后执行该脚本，构建后可以配置邮件通知，详细步骤可以参考网络上大量的教程文章。  \n\n#### 需要的环境准备   \n\n##### jenkins  \n\njenkins运行需要java环境，[jenkins官网](https://jenkins.io/) 下载到war包\n\n```shell\nnohup java -jar jenkins.war --httpPort={对外端口} & \n```\n\n 即可后台启动jenkins  \n\n![](/images/imageForPost/一个成熟的博客/jenkins.png)\n\n用于自动构建的脚本  \n\n```shell\nhexo clean\nnpm install\nhexo g\ncp -r ./public/. /var/www/blog\n```\n\njenkins拉取github仓库的推送后执行目录在/root/.jenkins/workspace/{jenkins工程目录}  \n\n所以脚本也是在jenkins工程目录为起点执行的\n\n##### node.js\n\nnode是一个JavaScript 运行环境，hexo是node.js上的一个静态博客框架，可以使用npm包管理器安装  \n\n```shell\nnpm install -g hexo-cli\n```\n\nhexo为npm安装的应用，目录在  {node应用目录}/lib/node_modules/hexo-cli/bin/目录下，需要将hexo通过ln命令创建一个全局可用的链接： ln -s {hexo真实目录} /usr/local/bin/hexo   \n\nnpm、node等命令出现找不到并确认已经安装即可使用相同方式处理      \n\n##### nginx  \n\nhexo编译结果为静态文件，只需访问index.html文件即可，所以附上nginx配置  \n\n```\nserver {\n    listen       80;\n    server_name  localhost;\n    location / {\n        root   /var/www/blog;\n        index  index.html index.htm;\n    }\n\n}\n\n```\n\n博客文件目录为/var/www/blog/，内容为hexo工程执行hexo g编译后public文件夹下的所有内容\n\nnginx启动默认是nginx用户\n\nnginx的启动配置文件中可以指定执行用户，如果该用户对博客静态文件文件夹没有读权限则访问时会报403 forbidden错误。\n\n------\n\n当环境准备好后hexo就已经是个成熟的博客啦，他可以自己完成部署，不需要我再手动搬运了~\n\n\n\n","slug":"一个成熟的博客","published":1,"updated":"2019-10-02T16:18:23.356Z","layout":"post","photos":[],"link":"","_id":"ck5ibb8sz0001d4rm1v8fe8qb","content":"<p><img src=\"/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg\" alt=\"hexo_meitu_2\"><br><a id=\"more\"></a></p>\n<h3 id=\"我要干啥\"><a href=\"#我要干啥\" class=\"headerlink\" title=\"我要干啥\"></a>我要干啥</h3><p>通过jenkins自动部署hexo博客，只需要将写好的博客推送到github仓库即可，作为一个记录，所以这不是一篇步骤性的教学文章！只是分享下方法，详细的教学文章很多，只需要打开搜索引擎，输入  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">jenkins </span><br><span class=\"line\">hexo</span><br><span class=\"line\">github</span><br></pre></td></tr></table></figure>\n<p>即可</p>\n<h3 id=\"建博客的缘由\"><a href=\"#建博客的缘由\" class=\"headerlink\" title=\"建博客的缘由\"></a>建博客的缘由</h3><p>虽然到现在还没有写博客，但是博客平台还是要建起来的，万一哪天就有可以写博客的内容了呢。虽然如掘金，简书等各大平台都可以发布博客，已经买了阿里云两年，那自然是要利用起来的，又不想浪费大量时间去从头开始写一个博客工程，那就考虑下现有的可以用来创建博客的工具–hexo吧，作为一个node应用，可以很方便的搭建起来，还能随意换主题，还可以使用github仓库的issues作为评论，只需要node.js环境和npm包管理器，通过nginx作为静态文件服务器就可以进行访问。</p>\n<h3 id=\"如何让hexo自动构建\"><a href=\"#如何让hexo自动构建\" class=\"headerlink\" title=\"如何让hexo自动构建\"></a>如何让hexo自动构建</h3><p>试过两种方法，打算使用github仓库的issues作为评论所以目前使用的是第二种方法  </p>\n<ul>\n<li>服务器搭建git，通过git hooks钩子在推送到git仓库后执行hexo g编译并复制到/var/www/blog文件夹下  </li>\n<li>通过jenkins关联github仓库，发现有推送就进行拉取并执行编译命令，编译完成后复制到web目录下，构建完成后发送邮件进行通知</li>\n</ul>\n<h3 id=\"为什么要让博客自动构建\"><a href=\"#为什么要让博客自动构建\" class=\"headerlink\" title=\"为什么要让博客自动构建\"></a>为什么要让博客自动构建</h3><p>因为我懒啊，最原始方式部署博客的话，通过nginx引出hexo编译后的静态文件进行访问， 所以更新完博客的话需要推送github，然后本地执行hexo g编译再将编译后的文件通过ftp上传。</p>\n<p>第一种方式需要在服务器上创建git用户，并搭建git环境，创建git仓库。</p>\n<p>配置该用户的ssh key进行访问，使得hexo工程中配置好git仓库地址后，可以通过hexo的hexo d命令可以直接编译并推送到服务器上的git仓库。</p>\n<p>当有数据推送到服务器的git仓库后，通过git hooks执行复制脚本编译，并把文件复制到/var/ww/blog文件夹下进行访问。</p>\n<p>目前博客托管在github上，所以不想维护两个仓库，于是打算采用方式二</p>\n<h3 id=\"让jenkins来构建博客\"><a href=\"#让jenkins来构建博客\" class=\"headerlink\" title=\"让jenkins来构建博客\"></a>让jenkins来构建博客</h3><h4 id=\"主要构建过程\"><a href=\"#主要构建过程\" class=\"headerlink\" title=\"主要构建过程\"></a>主要构建过程</h4><p>local: git push -&gt; github<br>github: 偶哟，有新的推送，该通知服务器上的jenkins干活了<br>jenkins：是博客的仓库诶！拉取过来，执行预先写好的脚本进行编译、部署。搞定~邮件通知下</p>\n<p>收到了构建成功邮件，访问博客站点，看到了新博客</p>\n<hr>\n<p>对于jenkins来说需要配置一个自动构建工程</p>\n<h4 id=\"自动构建工程配置\"><a href=\"#自动构建工程配置\" class=\"headerlink\" title=\"自动构建工程配置\"></a>自动构建工程配置</h4><p>创建一个自动构建工程，指定github仓库地址，配上仓库的密钥key，使得jenkins在该仓库有更新时可以拉取数据，写好构建时要执行的shell脚本，当仓库更新并拉取数据后执行该脚本，构建后可以配置邮件通知，详细步骤可以参考网络上大量的教程文章。  </p>\n<h4 id=\"需要的环境准备\"><a href=\"#需要的环境准备\" class=\"headerlink\" title=\"需要的环境准备\"></a>需要的环境准备</h4><h5 id=\"jenkins\"><a href=\"#jenkins\" class=\"headerlink\" title=\"jenkins\"></a>jenkins</h5><p>jenkins运行需要java环境，<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">jenkins官网</a> 下载到war包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup java -jar jenkins.war --httpPort=&#123;对外端口&#125; &amp;</span><br></pre></td></tr></table></figure>\n<p> 即可后台启动jenkins  </p>\n<p><img src=\"/images/imageForPost/一个成熟的博客/jenkins.png\" alt></p>\n<p>用于自动构建的脚本  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">cp -r ./public/. /var/www/blog</span><br></pre></td></tr></table></figure>\n<p>jenkins拉取github仓库的推送后执行目录在/root/.jenkins/workspace/{jenkins工程目录}  </p>\n<p>所以脚本也是在jenkins工程目录为起点执行的</p>\n<h5 id=\"node-js\"><a href=\"#node-js\" class=\"headerlink\" title=\"node.js\"></a>node.js</h5><p>node是一个JavaScript 运行环境，hexo是node.js上的一个静态博客框架，可以使用npm包管理器安装  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>hexo为npm安装的应用，目录在  {node应用目录}/lib/node_modules/hexo-cli/bin/目录下，需要将hexo通过ln命令创建一个全局可用的链接： ln -s {hexo真实目录} /usr/local/bin/hexo   </p>\n<p>npm、node等命令出现找不到并确认已经安装即可使用相同方式处理      </p>\n<h5 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h5><p>hexo编译结果为静态文件，只需访问index.html文件即可，所以附上nginx配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /var/www/blog;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>博客文件目录为/var/www/blog/，内容为hexo工程执行hexo g编译后public文件夹下的所有内容</p>\n<p>nginx启动默认是nginx用户</p>\n<p>nginx的启动配置文件中可以指定执行用户，如果该用户对博客静态文件文件夹没有读权限则访问时会报403 forbidden错误。</p>\n<hr>\n<p>当环境准备好后hexo就已经是个成熟的博客啦，他可以自己完成部署，不需要我再手动搬运了~</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p><img src=\"/images/imageForPost/一个成熟的博客/hexo_meitu_2.jpg\" alt=\"hexo_meitu_2\"><br>","more":"</p>\n<h3 id=\"我要干啥\"><a href=\"#我要干啥\" class=\"headerlink\" title=\"我要干啥\"></a>我要干啥</h3><p>通过jenkins自动部署hexo博客，只需要将写好的博客推送到github仓库即可，作为一个记录，所以这不是一篇步骤性的教学文章！只是分享下方法，详细的教学文章很多，只需要打开搜索引擎，输入  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">jenkins </span><br><span class=\"line\">hexo</span><br><span class=\"line\">github</span><br></pre></td></tr></table></figure>\n<p>即可</p>\n<h3 id=\"建博客的缘由\"><a href=\"#建博客的缘由\" class=\"headerlink\" title=\"建博客的缘由\"></a>建博客的缘由</h3><p>虽然到现在还没有写博客，但是博客平台还是要建起来的，万一哪天就有可以写博客的内容了呢。虽然如掘金，简书等各大平台都可以发布博客，已经买了阿里云两年，那自然是要利用起来的，又不想浪费大量时间去从头开始写一个博客工程，那就考虑下现有的可以用来创建博客的工具–hexo吧，作为一个node应用，可以很方便的搭建起来，还能随意换主题，还可以使用github仓库的issues作为评论，只需要node.js环境和npm包管理器，通过nginx作为静态文件服务器就可以进行访问。</p>\n<h3 id=\"如何让hexo自动构建\"><a href=\"#如何让hexo自动构建\" class=\"headerlink\" title=\"如何让hexo自动构建\"></a>如何让hexo自动构建</h3><p>试过两种方法，打算使用github仓库的issues作为评论所以目前使用的是第二种方法  </p>\n<ul>\n<li>服务器搭建git，通过git hooks钩子在推送到git仓库后执行hexo g编译并复制到/var/www/blog文件夹下  </li>\n<li>通过jenkins关联github仓库，发现有推送就进行拉取并执行编译命令，编译完成后复制到web目录下，构建完成后发送邮件进行通知</li>\n</ul>\n<h3 id=\"为什么要让博客自动构建\"><a href=\"#为什么要让博客自动构建\" class=\"headerlink\" title=\"为什么要让博客自动构建\"></a>为什么要让博客自动构建</h3><p>因为我懒啊，最原始方式部署博客的话，通过nginx引出hexo编译后的静态文件进行访问， 所以更新完博客的话需要推送github，然后本地执行hexo g编译再将编译后的文件通过ftp上传。</p>\n<p>第一种方式需要在服务器上创建git用户，并搭建git环境，创建git仓库。</p>\n<p>配置该用户的ssh key进行访问，使得hexo工程中配置好git仓库地址后，可以通过hexo的hexo d命令可以直接编译并推送到服务器上的git仓库。</p>\n<p>当有数据推送到服务器的git仓库后，通过git hooks执行复制脚本编译，并把文件复制到/var/ww/blog文件夹下进行访问。</p>\n<p>目前博客托管在github上，所以不想维护两个仓库，于是打算采用方式二</p>\n<h3 id=\"让jenkins来构建博客\"><a href=\"#让jenkins来构建博客\" class=\"headerlink\" title=\"让jenkins来构建博客\"></a>让jenkins来构建博客</h3><h4 id=\"主要构建过程\"><a href=\"#主要构建过程\" class=\"headerlink\" title=\"主要构建过程\"></a>主要构建过程</h4><p>local: git push -&gt; github<br>github: 偶哟，有新的推送，该通知服务器上的jenkins干活了<br>jenkins：是博客的仓库诶！拉取过来，执行预先写好的脚本进行编译、部署。搞定~邮件通知下</p>\n<p>收到了构建成功邮件，访问博客站点，看到了新博客</p>\n<hr>\n<p>对于jenkins来说需要配置一个自动构建工程</p>\n<h4 id=\"自动构建工程配置\"><a href=\"#自动构建工程配置\" class=\"headerlink\" title=\"自动构建工程配置\"></a>自动构建工程配置</h4><p>创建一个自动构建工程，指定github仓库地址，配上仓库的密钥key，使得jenkins在该仓库有更新时可以拉取数据，写好构建时要执行的shell脚本，当仓库更新并拉取数据后执行该脚本，构建后可以配置邮件通知，详细步骤可以参考网络上大量的教程文章。  </p>\n<h4 id=\"需要的环境准备\"><a href=\"#需要的环境准备\" class=\"headerlink\" title=\"需要的环境准备\"></a>需要的环境准备</h4><h5 id=\"jenkins\"><a href=\"#jenkins\" class=\"headerlink\" title=\"jenkins\"></a>jenkins</h5><p>jenkins运行需要java环境，<a href=\"https://jenkins.io/\" target=\"_blank\" rel=\"noopener\">jenkins官网</a> 下载到war包</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">nohup java -jar jenkins.war --httpPort=&#123;对外端口&#125; &amp;</span><br></pre></td></tr></table></figure>\n<p> 即可后台启动jenkins  </p>\n<p><img src=\"/images/imageForPost/一个成熟的博客/jenkins.png\" alt></p>\n<p>用于自动构建的脚本  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo g</span><br><span class=\"line\">cp -r ./public/. /var/www/blog</span><br></pre></td></tr></table></figure>\n<p>jenkins拉取github仓库的推送后执行目录在/root/.jenkins/workspace/{jenkins工程目录}  </p>\n<p>所以脚本也是在jenkins工程目录为起点执行的</p>\n<h5 id=\"node-js\"><a href=\"#node-js\" class=\"headerlink\" title=\"node.js\"></a>node.js</h5><p>node是一个JavaScript 运行环境，hexo是node.js上的一个静态博客框架，可以使用npm包管理器安装  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n<p>hexo为npm安装的应用，目录在  {node应用目录}/lib/node_modules/hexo-cli/bin/目录下，需要将hexo通过ln命令创建一个全局可用的链接： ln -s {hexo真实目录} /usr/local/bin/hexo   </p>\n<p>npm、node等命令出现找不到并确认已经安装即可使用相同方式处理      </p>\n<h5 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h5><p>hexo编译结果为静态文件，只需访问index.html文件即可，所以附上nginx配置  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   /var/www/blog;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>博客文件目录为/var/www/blog/，内容为hexo工程执行hexo g编译后public文件夹下的所有内容</p>\n<p>nginx启动默认是nginx用户</p>\n<p>nginx的启动配置文件中可以指定执行用户，如果该用户对博客静态文件文件夹没有读权限则访问时会报403 forbidden错误。</p>\n<hr>\n<p>当环境准备好后hexo就已经是个成熟的博客啦，他可以自己完成部署，不需要我再手动搬运了~</p>"},{"title":"Too Many Files异常处理和Ulimit命令","date":"2020-01-17T14:02:16.000Z","comments":1,"_content":"前天生产环境网关应用报了一个异常，导致网关服务不可用，用户无法登陆。  \n查看了下日志，报了**Too Many Files**异常    \n这种异常也较为常见，当JAVA应用在打开超过系统允许它打开的最大文件数目时会报这个异常。  \n \n<!-- more -->  \n**异常日志：**\n![](/images/imageForPost/Linux/openTooManyFiles/prod-err.png)  \n  \n之前在测试环境中出现过一次，简单粗暴的重启了测试机器就解决了。   \n但是生产环境不能像测试环境一样暴力，于是通过ulimit命令来调整应用可以打开文件的上限来处理。    \n\n## 出现异常的原因  \n在Linux系统中有句话叫 万物皆为对象，生产环境中通过socket对接上游系统.  \n某天上游系统不知道啥原因挂了，接收了socket请求但是不做任何操作，加上不断有用户请求进来，  \n应用不断的与该系统创建连接，每打开一个socket连接对Linux来说就是我们的应用打开了一个文件，不断累加，于是超过了最大打开文件的限制，由于应用再也不能创建、接收socket连接，导致用户端出现了异常。    \n### 查看当前应用可打开的文件数  \n通过命令查看当前线程打开的文件数  \n`lsof -p PID ｜ wc -l   `\n**PID**为应用线程**id**    \n\n---------\n也可以在本机通过命令 umilits -a 查询结果如下。  \n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png)\n 其中open file就是允许打开的文件数。  \n 不过不加参数的话默认的时-S即显示soft的限制，通过ulimit设置的话没有指定-S或者-H则是同时设置。    \n ![](/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png)  \n ### soft和hard区别  \n linux对打开文件限制有soft和hard限制。\n \n #### hard和soft限制\n hard和soft都是对资源的限制，对打开的文件数限制来说  \n * hard表示打开的最大数目，soft是警告数目，超过soft会出现警告  \n * soft小于等于hard  \n * root进程可以调整hard值，非root进程只能调整soft值  \n * 进程在开启前可以自主调整soft的值。    \n ------  \n \n## 处理方式  \n* **ulimit命令调整**\n* **修改limits.conf文件**    \n\n\n### ulimit命令\n之前测试环境出现这种情况直接简单粗暴的重启了机器，生产环境可不能这么干，于是可以通过ulimit命令增加nofile值  \n**nofile表示进程可打开的文件数**  \n \n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png)\n\n进程的ulimit修改对当前shell的进程生效，但是已经启动的进程不受影线，而且单次生效。  \n如果要保证应用每次启动的时候都生效则可以在应用的启动脚本里设置。  \n\n### 修改limits.conf文件 \n除了手动通过当前命令修改还可以对limits.conf文件新增记录来修改某用户进程可控制的资源数目\n文件路径。\n**/etc/security/limits.conf**  \n举例现有文件中的配置\n![](/images/imageForPost/Linux/openTooManyFiles/security-limits.png)\n\n* 第一个为范围，可为用户名、group或者用*表示所有的非root用户\n* 第二个字段可以为hard soft或者-，-表示hard和soft\n* 第三个字段表示控制什么类型，比如nofile代表可打开的文件数目  \n* 第四个字段表示具体的值，1000表示nofile可为10000  \n\n---------\n通过查看/proc/PID/limits文件可以查看某个已经运行的进程的资源最大值，PID为进程ID。比如现在随机找了个进程查看\n![](/images/imageForPost/Linux/openTooManyFiles/proc-limits.png)  \n\n## 复现生产问题\n生产环境是因为socket打开过多导致的，那手动模拟一下多开许多文件也是一样的   \n\n注：直接在Mac机器上进行测试，都是类Unix系统\n### 查看当前shell允许的最大打开文件数量。  \n当前允许最大打开文件数目为1000\n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png)\n\n### 打开文件代码  \n\n```java  \npackage test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.IOException;\nimport java.lang.InterruptedException;\nclass Ulimit{\n    public static void main( String[] args ) throws IOException, InterruptedException\n    {\n                List<FileInputStream> fileList = new ArrayList<FileInputStream>();\n        for(int i=0;i<700;i++) {\n            File temp = File.createTempFile(\"test\", \".txt\");\n            fileList.add(new FileInputStream(temp));\n            System.out.println(\"file:\" + i + \" \" + temp.getAbsolutePath());\n        }\n    }\n}\n\n\n```\n\n由于jvm也是需要打开一些文件的，所以把循环值设置的比允许值更小一点，代码如下。设置为700\n\n目前允许值为1000，那么程序打开700个文件肯定是可以的\n\n### 编译代码。  \n`javac test.java  `\n会生成Ulimit.class\n\n### 在当前shell中执行代码  \n由于调整的是当前shell产生的进程，所以编译后执行该class，由于class包名为test，把class文件放入test文件夹后执行  \n`java test.java`\n![](/images/imageForPost/Linux/openTooManyFiles/run-command.png)\n### 正常执行  \n![](/images/imageForPost/Linux/openTooManyFiles/run-succ.png)\n### 调整open file值\n通过`ulimit -n 700`改变当前shell的允许值，然后重新执行代码  \n\n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png)\n\n重新运行，报错。  \n![](/images/imageForPost/Linux/openTooManyFiles/run-error.png)\n\n\n \n \n 不过在mac中通过ulimit -n 1100 调大时报错。\n ![](/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png)\n \n 在Mac中应该使用\n `sudo launchctl limit maxfiles 100000 500000 ` 进行设置\n ![](/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png)\n 由于手滑，后面的参数值设置的小了  \n 导致应用报 **too many files error** 无法正常关闭应用和重启，只得强制重启机器让之前的设置无效。\n ","source":"_posts/linux/应用too many files异常.md","raw":"---\ntitle: Too Many Files异常处理和Ulimit命令  \ndate: 2020-01-17 22:02:16  \ncomments: true  \ncategories:   \n- 记录  \ntags:   \n- Linux  \n\n---\n前天生产环境网关应用报了一个异常，导致网关服务不可用，用户无法登陆。  \n查看了下日志，报了**Too Many Files**异常    \n这种异常也较为常见，当JAVA应用在打开超过系统允许它打开的最大文件数目时会报这个异常。  \n \n<!-- more -->  \n**异常日志：**\n![](/images/imageForPost/Linux/openTooManyFiles/prod-err.png)  \n  \n之前在测试环境中出现过一次，简单粗暴的重启了测试机器就解决了。   \n但是生产环境不能像测试环境一样暴力，于是通过ulimit命令来调整应用可以打开文件的上限来处理。    \n\n## 出现异常的原因  \n在Linux系统中有句话叫 万物皆为对象，生产环境中通过socket对接上游系统.  \n某天上游系统不知道啥原因挂了，接收了socket请求但是不做任何操作，加上不断有用户请求进来，  \n应用不断的与该系统创建连接，每打开一个socket连接对Linux来说就是我们的应用打开了一个文件，不断累加，于是超过了最大打开文件的限制，由于应用再也不能创建、接收socket连接，导致用户端出现了异常。    \n### 查看当前应用可打开的文件数  \n通过命令查看当前线程打开的文件数  \n`lsof -p PID ｜ wc -l   `\n**PID**为应用线程**id**    \n\n---------\n也可以在本机通过命令 umilits -a 查询结果如下。  \n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png)\n 其中open file就是允许打开的文件数。  \n 不过不加参数的话默认的时-S即显示soft的限制，通过ulimit设置的话没有指定-S或者-H则是同时设置。    \n ![](/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png)  \n ### soft和hard区别  \n linux对打开文件限制有soft和hard限制。\n \n #### hard和soft限制\n hard和soft都是对资源的限制，对打开的文件数限制来说  \n * hard表示打开的最大数目，soft是警告数目，超过soft会出现警告  \n * soft小于等于hard  \n * root进程可以调整hard值，非root进程只能调整soft值  \n * 进程在开启前可以自主调整soft的值。    \n ------  \n \n## 处理方式  \n* **ulimit命令调整**\n* **修改limits.conf文件**    \n\n\n### ulimit命令\n之前测试环境出现这种情况直接简单粗暴的重启了机器，生产环境可不能这么干，于是可以通过ulimit命令增加nofile值  \n**nofile表示进程可打开的文件数**  \n \n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png)\n\n进程的ulimit修改对当前shell的进程生效，但是已经启动的进程不受影线，而且单次生效。  \n如果要保证应用每次启动的时候都生效则可以在应用的启动脚本里设置。  \n\n### 修改limits.conf文件 \n除了手动通过当前命令修改还可以对limits.conf文件新增记录来修改某用户进程可控制的资源数目\n文件路径。\n**/etc/security/limits.conf**  \n举例现有文件中的配置\n![](/images/imageForPost/Linux/openTooManyFiles/security-limits.png)\n\n* 第一个为范围，可为用户名、group或者用*表示所有的非root用户\n* 第二个字段可以为hard soft或者-，-表示hard和soft\n* 第三个字段表示控制什么类型，比如nofile代表可打开的文件数目  \n* 第四个字段表示具体的值，1000表示nofile可为10000  \n\n---------\n通过查看/proc/PID/limits文件可以查看某个已经运行的进程的资源最大值，PID为进程ID。比如现在随机找了个进程查看\n![](/images/imageForPost/Linux/openTooManyFiles/proc-limits.png)  \n\n## 复现生产问题\n生产环境是因为socket打开过多导致的，那手动模拟一下多开许多文件也是一样的   \n\n注：直接在Mac机器上进行测试，都是类Unix系统\n### 查看当前shell允许的最大打开文件数量。  \n当前允许最大打开文件数目为1000\n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png)\n\n### 打开文件代码  \n\n```java  \npackage test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.io.IOException;\nimport java.lang.InterruptedException;\nclass Ulimit{\n    public static void main( String[] args ) throws IOException, InterruptedException\n    {\n                List<FileInputStream> fileList = new ArrayList<FileInputStream>();\n        for(int i=0;i<700;i++) {\n            File temp = File.createTempFile(\"test\", \".txt\");\n            fileList.add(new FileInputStream(temp));\n            System.out.println(\"file:\" + i + \" \" + temp.getAbsolutePath());\n        }\n    }\n}\n\n\n```\n\n由于jvm也是需要打开一些文件的，所以把循环值设置的比允许值更小一点，代码如下。设置为700\n\n目前允许值为1000，那么程序打开700个文件肯定是可以的\n\n### 编译代码。  \n`javac test.java  `\n会生成Ulimit.class\n\n### 在当前shell中执行代码  \n由于调整的是当前shell产生的进程，所以编译后执行该class，由于class包名为test，把class文件放入test文件夹后执行  \n`java test.java`\n![](/images/imageForPost/Linux/openTooManyFiles/run-command.png)\n### 正常执行  \n![](/images/imageForPost/Linux/openTooManyFiles/run-succ.png)\n### 调整open file值\n通过`ulimit -n 700`改变当前shell的允许值，然后重新执行代码  \n\n![](/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png)\n\n重新运行，报错。  \n![](/images/imageForPost/Linux/openTooManyFiles/run-error.png)\n\n\n \n \n 不过在mac中通过ulimit -n 1100 调大时报错。\n ![](/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png)\n \n 在Mac中应该使用\n `sudo launchctl limit maxfiles 100000 500000 ` 进行设置\n ![](/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png)\n 由于手滑，后面的参数值设置的小了  \n 导致应用报 **too many files error** 无法正常关闭应用和重启，只得强制重启机器让之前的设置无效。\n ","slug":"linux/应用too many files异常","published":1,"updated":"2020-01-29T13:14:51.587Z","_id":"ck5ibb8um0009d4rmbmwa9x1e","layout":"post","photos":[],"link":"","content":"<p>前天生产环境网关应用报了一个异常，导致网关服务不可用，用户无法登陆。<br>查看了下日志，报了<strong>Too Many Files</strong>异常<br>这种异常也较为常见，当JAVA应用在打开超过系统允许它打开的最大文件数目时会报这个异常。  </p>\n<a id=\"more\"></a>  \n<p><strong>异常日志：</strong><br><img src=\"/images/imageForPost/Linux/openTooManyFiles/prod-err.png\" alt>  </p>\n<p>之前在测试环境中出现过一次，简单粗暴的重启了测试机器就解决了。<br>但是生产环境不能像测试环境一样暴力，于是通过ulimit命令来调整应用可以打开文件的上限来处理。    </p>\n<h2 id=\"出现异常的原因\"><a href=\"#出现异常的原因\" class=\"headerlink\" title=\"出现异常的原因\"></a>出现异常的原因</h2><p>在Linux系统中有句话叫 万物皆为对象，生产环境中通过socket对接上游系统.<br>某天上游系统不知道啥原因挂了，接收了socket请求但是不做任何操作，加上不断有用户请求进来，<br>应用不断的与该系统创建连接，每打开一个socket连接对Linux来说就是我们的应用打开了一个文件，不断累加，于是超过了最大打开文件的限制，由于应用再也不能创建、接收socket连接，导致用户端出现了异常。    </p>\n<h3 id=\"查看当前应用可打开的文件数\"><a href=\"#查看当前应用可打开的文件数\" class=\"headerlink\" title=\"查看当前应用可打开的文件数\"></a>查看当前应用可打开的文件数</h3><p>通过命令查看当前线程打开的文件数<br><code>lsof -p PID ｜ wc -l</code><br><strong>PID</strong>为应用线程<strong>id</strong>    </p>\n<hr>\n<p>也可以在本机通过命令 umilits -a 查询结果如下。<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png\" alt><br> 其中open file就是允许打开的文件数。<br> 不过不加参数的话默认的时-S即显示soft的限制，通过ulimit设置的话没有指定-S或者-H则是同时设置。<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png\" alt>  </p>\n<h3 id=\"soft和hard区别\"><a href=\"#soft和hard区别\" class=\"headerlink\" title=\"soft和hard区别\"></a>soft和hard区别</h3><p> linux对打开文件限制有soft和hard限制。</p>\n<h4 id=\"hard和soft限制\"><a href=\"#hard和soft限制\" class=\"headerlink\" title=\"hard和soft限制\"></a>hard和soft限制</h4><p> hard和soft都是对资源的限制，对打开的文件数限制来说  </p>\n<ul>\n<li>hard表示打开的最大数目，soft是警告数目，超过soft会出现警告  </li>\n<li>soft小于等于hard  </li>\n<li>root进程可以调整hard值，非root进程只能调整soft值  </li>\n<li>进程在开启前可以自主调整soft的值。    </li>\n</ul>\n<hr>\n<h2 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h2><ul>\n<li><strong>ulimit命令调整</strong></li>\n<li><strong>修改limits.conf文件</strong>    </li>\n</ul>\n<h3 id=\"ulimit命令\"><a href=\"#ulimit命令\" class=\"headerlink\" title=\"ulimit命令\"></a>ulimit命令</h3><p>之前测试环境出现这种情况直接简单粗暴的重启了机器，生产环境可不能这么干，于是可以通过ulimit命令增加nofile值<br><strong>nofile表示进程可打开的文件数</strong>  </p>\n<p><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png\" alt></p>\n<p>进程的ulimit修改对当前shell的进程生效，但是已经启动的进程不受影线，而且单次生效。<br>如果要保证应用每次启动的时候都生效则可以在应用的启动脚本里设置。  </p>\n<h3 id=\"修改limits-conf文件\"><a href=\"#修改limits-conf文件\" class=\"headerlink\" title=\"修改limits.conf文件\"></a>修改limits.conf文件</h3><p>除了手动通过当前命令修改还可以对limits.conf文件新增记录来修改某用户进程可控制的资源数目<br>文件路径。<br><strong>/etc/security/limits.conf</strong><br>举例现有文件中的配置<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/security-limits.png\" alt></p>\n<ul>\n<li>第一个为范围，可为用户名、group或者用*表示所有的非root用户</li>\n<li>第二个字段可以为hard soft或者-，-表示hard和soft</li>\n<li>第三个字段表示控制什么类型，比如nofile代表可打开的文件数目  </li>\n<li>第四个字段表示具体的值，1000表示nofile可为10000  </li>\n</ul>\n<hr>\n<p>通过查看/proc/PID/limits文件可以查看某个已经运行的进程的资源最大值，PID为进程ID。比如现在随机找了个进程查看<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/proc-limits.png\" alt>  </p>\n<h2 id=\"复现生产问题\"><a href=\"#复现生产问题\" class=\"headerlink\" title=\"复现生产问题\"></a>复现生产问题</h2><p>生产环境是因为socket打开过多导致的，那手动模拟一下多开许多文件也是一样的   </p>\n<p>注：直接在Mac机器上进行测试，都是类Unix系统</p>\n<h3 id=\"查看当前shell允许的最大打开文件数量。\"><a href=\"#查看当前shell允许的最大打开文件数量。\" class=\"headerlink\" title=\"查看当前shell允许的最大打开文件数量。\"></a>查看当前shell允许的最大打开文件数量。</h3><p>当前允许最大打开文件数目为1000<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png\" alt></p>\n<h3 id=\"打开文件代码\"><a href=\"#打开文件代码\" class=\"headerlink\" title=\"打开文件代码\"></a>打开文件代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.InterruptedException;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ulimit</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> IOException, InterruptedException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">                List&lt;FileInputStream&gt; fileList = <span class=\"keyword\">new</span> ArrayList&lt;FileInputStream&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">700</span>;i++) &#123;</span><br><span class=\"line\">            File temp = File.createTempFile(<span class=\"string\">\"test\"</span>, <span class=\"string\">\".txt\"</span>);</span><br><span class=\"line\">            fileList.add(<span class=\"keyword\">new</span> FileInputStream(temp));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"file:\"</span> + i + <span class=\"string\">\" \"</span> + temp.getAbsolutePath());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于jvm也是需要打开一些文件的，所以把循环值设置的比允许值更小一点，代码如下。设置为700</p>\n<p>目前允许值为1000，那么程序打开700个文件肯定是可以的</p>\n<h3 id=\"编译代码。\"><a href=\"#编译代码。\" class=\"headerlink\" title=\"编译代码。\"></a>编译代码。</h3><p><code>javac test.java</code><br>会生成Ulimit.class</p>\n<h3 id=\"在当前shell中执行代码\"><a href=\"#在当前shell中执行代码\" class=\"headerlink\" title=\"在当前shell中执行代码\"></a>在当前shell中执行代码</h3><p>由于调整的是当前shell产生的进程，所以编译后执行该class，由于class包名为test，把class文件放入test文件夹后执行<br><code>java test.java</code><br><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-command.png\" alt></p>\n<h3 id=\"正常执行\"><a href=\"#正常执行\" class=\"headerlink\" title=\"正常执行\"></a>正常执行</h3><p><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-succ.png\" alt></p>\n<h3 id=\"调整open-file值\"><a href=\"#调整open-file值\" class=\"headerlink\" title=\"调整open file值\"></a>调整open file值</h3><p>通过<code>ulimit -n 700</code>改变当前shell的允许值，然后重新执行代码  </p>\n<p><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png\" alt></p>\n<p>重新运行，报错。<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-error.png\" alt></p>\n<p> 不过在mac中通过ulimit -n 1100 调大时报错。<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png\" alt></p>\n<p> 在Mac中应该使用<br> <code>sudo launchctl limit maxfiles 100000 500000</code> 进行设置<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png\" alt><br> 由于手滑，后面的参数值设置的小了<br> 导致应用报 <strong>too many files error</strong> 无法正常关闭应用和重启，只得强制重启机器让之前的设置无效。</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>前天生产环境网关应用报了一个异常，导致网关服务不可用，用户无法登陆。<br>查看了下日志，报了<strong>Too Many Files</strong>异常<br>这种异常也较为常见，当JAVA应用在打开超过系统允许它打开的最大文件数目时会报这个异常。  </p>","more":"<p><strong>异常日志：</strong><br><img src=\"/images/imageForPost/Linux/openTooManyFiles/prod-err.png\" alt>  </p>\n<p>之前在测试环境中出现过一次，简单粗暴的重启了测试机器就解决了。<br>但是生产环境不能像测试环境一样暴力，于是通过ulimit命令来调整应用可以打开文件的上限来处理。    </p>\n<h2 id=\"出现异常的原因\"><a href=\"#出现异常的原因\" class=\"headerlink\" title=\"出现异常的原因\"></a>出现异常的原因</h2><p>在Linux系统中有句话叫 万物皆为对象，生产环境中通过socket对接上游系统.<br>某天上游系统不知道啥原因挂了，接收了socket请求但是不做任何操作，加上不断有用户请求进来，<br>应用不断的与该系统创建连接，每打开一个socket连接对Linux来说就是我们的应用打开了一个文件，不断累加，于是超过了最大打开文件的限制，由于应用再也不能创建、接收socket连接，导致用户端出现了异常。    </p>\n<h3 id=\"查看当前应用可打开的文件数\"><a href=\"#查看当前应用可打开的文件数\" class=\"headerlink\" title=\"查看当前应用可打开的文件数\"></a>查看当前应用可打开的文件数</h3><p>通过命令查看当前线程打开的文件数<br><code>lsof -p PID ｜ wc -l</code><br><strong>PID</strong>为应用线程<strong>id</strong>    </p>\n<hr>\n<p>也可以在本机通过命令 umilits -a 查询结果如下。<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a.png\" alt><br> 其中open file就是允许打开的文件数。<br> 不过不加参数的话默认的时-S即显示soft的限制，通过ulimit设置的话没有指定-S或者-H则是同时设置。<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-n.png\" alt>  </p>\n<h3 id=\"soft和hard区别\"><a href=\"#soft和hard区别\" class=\"headerlink\" title=\"soft和hard区别\"></a>soft和hard区别</h3><p> linux对打开文件限制有soft和hard限制。</p>\n<h4 id=\"hard和soft限制\"><a href=\"#hard和soft限制\" class=\"headerlink\" title=\"hard和soft限制\"></a>hard和soft限制</h4><p> hard和soft都是对资源的限制，对打开的文件数限制来说  </p>\n<ul>\n<li>hard表示打开的最大数目，soft是警告数目，超过soft会出现警告  </li>\n<li>soft小于等于hard  </li>\n<li>root进程可以调整hard值，非root进程只能调整soft值  </li>\n<li>进程在开启前可以自主调整soft的值。    </li>\n</ul>\n<hr>\n<h2 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h2><ul>\n<li><strong>ulimit命令调整</strong></li>\n<li><strong>修改limits.conf文件</strong>    </li>\n</ul>\n<h3 id=\"ulimit命令\"><a href=\"#ulimit命令\" class=\"headerlink\" title=\"ulimit命令\"></a>ulimit命令</h3><p>之前测试环境出现这种情况直接简单粗暴的重启了机器，生产环境可不能这么干，于是可以通过ulimit命令增加nofile值<br><strong>nofile表示进程可打开的文件数</strong>  </p>\n<p><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-adj.png\" alt></p>\n<p>进程的ulimit修改对当前shell的进程生效，但是已经启动的进程不受影线，而且单次生效。<br>如果要保证应用每次启动的时候都生效则可以在应用的启动脚本里设置。  </p>\n<h3 id=\"修改limits-conf文件\"><a href=\"#修改limits-conf文件\" class=\"headerlink\" title=\"修改limits.conf文件\"></a>修改limits.conf文件</h3><p>除了手动通过当前命令修改还可以对limits.conf文件新增记录来修改某用户进程可控制的资源数目<br>文件路径。<br><strong>/etc/security/limits.conf</strong><br>举例现有文件中的配置<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/security-limits.png\" alt></p>\n<ul>\n<li>第一个为范围，可为用户名、group或者用*表示所有的非root用户</li>\n<li>第二个字段可以为hard soft或者-，-表示hard和soft</li>\n<li>第三个字段表示控制什么类型，比如nofile代表可打开的文件数目  </li>\n<li>第四个字段表示具体的值，1000表示nofile可为10000  </li>\n</ul>\n<hr>\n<p>通过查看/proc/PID/limits文件可以查看某个已经运行的进程的资源最大值，PID为进程ID。比如现在随机找了个进程查看<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/proc-limits.png\" alt>  </p>\n<h2 id=\"复现生产问题\"><a href=\"#复现生产问题\" class=\"headerlink\" title=\"复现生产问题\"></a>复现生产问题</h2><p>生产环境是因为socket打开过多导致的，那手动模拟一下多开许多文件也是一样的   </p>\n<p>注：直接在Mac机器上进行测试，都是类Unix系统</p>\n<h3 id=\"查看当前shell允许的最大打开文件数量。\"><a href=\"#查看当前shell允许的最大打开文件数量。\" class=\"headerlink\" title=\"查看当前shell允许的最大打开文件数量。\"></a>查看当前shell允许的最大打开文件数量。</h3><p>当前允许最大打开文件数目为1000<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a-max.png\" alt></p>\n<h3 id=\"打开文件代码\"><a href=\"#打开文件代码\" class=\"headerlink\" title=\"打开文件代码\"></a>打开文件代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.InterruptedException;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ulimit</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">( String[] args )</span> <span class=\"keyword\">throws</span> IOException, InterruptedException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">                List&lt;FileInputStream&gt; fileList = <span class=\"keyword\">new</span> ArrayList&lt;FileInputStream&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">700</span>;i++) &#123;</span><br><span class=\"line\">            File temp = File.createTempFile(<span class=\"string\">\"test\"</span>, <span class=\"string\">\".txt\"</span>);</span><br><span class=\"line\">            fileList.add(<span class=\"keyword\">new</span> FileInputStream(temp));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"file:\"</span> + i + <span class=\"string\">\" \"</span> + temp.getAbsolutePath());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于jvm也是需要打开一些文件的，所以把循环值设置的比允许值更小一点，代码如下。设置为700</p>\n<p>目前允许值为1000，那么程序打开700个文件肯定是可以的</p>\n<h3 id=\"编译代码。\"><a href=\"#编译代码。\" class=\"headerlink\" title=\"编译代码。\"></a>编译代码。</h3><p><code>javac test.java</code><br>会生成Ulimit.class</p>\n<h3 id=\"在当前shell中执行代码\"><a href=\"#在当前shell中执行代码\" class=\"headerlink\" title=\"在当前shell中执行代码\"></a>在当前shell中执行代码</h3><p>由于调整的是当前shell产生的进程，所以编译后执行该class，由于class包名为test，把class文件放入test文件夹后执行<br><code>java test.java</code><br><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-command.png\" alt></p>\n<h3 id=\"正常执行\"><a href=\"#正常执行\" class=\"headerlink\" title=\"正常执行\"></a>正常执行</h3><p><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-succ.png\" alt></p>\n<h3 id=\"调整open-file值\"><a href=\"#调整open-file值\" class=\"headerlink\" title=\"调整open file值\"></a>调整open file值</h3><p>通过<code>ulimit -n 700</code>改变当前shell的允许值，然后重新执行代码  </p>\n<p><img src=\"/images/imageForPost/Linux/openTooManyFiles/ulimit-a-mac.png\" alt></p>\n<p>重新运行，报错。<br><img src=\"/images/imageForPost/Linux/openTooManyFiles/run-error.png\" alt></p>\n<p> 不过在mac中通过ulimit -n 1100 调大时报错。<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/mac-set-error.png\" alt></p>\n<p> 在Mac中应该使用<br> <code>sudo launchctl limit maxfiles 100000 500000</code> 进行设置<br> <img src=\"/images/imageForPost/Linux/openTooManyFiles/mac-sysctl-set.png\" alt><br> 由于手滑，后面的参数值设置的小了<br> 导致应用报 <strong>too many files error</strong> 无法正常关闭应用和重启，只得强制重启机器让之前的设置无效。</p>"},{"title":"JVM内存区域和GC类型","date":"2019-10-15T14:02:16.000Z","comments":1,"_content":"\n简单记录JVM的内存划分以及几种GC收集器  \n<!-- more -->  \n## 主要区域  \n\n* 线程公有部分\n\t* 堆 heap  \n\t\t用来存放对象实例。GC的主要区域，采用分代回收的gc算法的话还可以细分成 Eden，From Survivor(S0)，To Survivor(S1)，Tentired。其中Eden，S0，S1属于新生代，Tentired属于老年代，当对象在 Eden经过一次GC后对象年龄+1并且进入S0，S1区，当他的年龄增加到一定程度会进入Tentired老年区，或者s区域相同年龄的对象所占空间大于s总空间的一半，那对象大于这个年龄的都会进入老年代。    \n\t* 方法区  \n\t\t用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。\n\n\t* 运行时常量池\n\t\t方法区的一部分，也是线程共享的。\n\n* 线程私有部分  \n\t* 虚拟机栈  \n\t\t每个方法调用都是通过栈传递的，由栈帧组成，每个栈帧都包含了：1、局部变量表 2、操作数栈 3、动态链表 4、方法出口信息等。  \n\t\t每次函数调用都会有一个栈帧入栈，调用结束后会有个栈帧出栈，抛出异常也会出栈。  \n\t* 本地方法栈  \n\t\t调用native方法也会创建栈帧入本地方法栈，HotSpot虚拟机中本地方法栈和虚拟机栈是同一个。  \n\t* 程序计数器\n\t\t当前程序执行的行号指示器，可以保证线程切换后能恢复到原来的执行位置。通过程序计数器来获取下一步要执行的字节码指令。  \n* 直接内存\n\t* 元空间\n\t在jdk1.8之后移除了方法区，原方法区的内容移动到了直接内存中的元空间内  \n\t\n\t  \n## HotSpot    \n\n### 对象的创建过程    \n \n* 类加载检查 \n* 分配内存 \n* 初始化零值 \n* 设置对象头 \n* 执行init方法   \n\n### 类加载检查  \n  当虚拟机执行到new指令时，会检查是否能在常量池中找到这个类的符号引用，并且检查该类是否被加载、解析和初始化过。若没有则进行对应的类加载操作。  \n\n### 分配内存  \n  根据内存是否规整分为：1、指针碰撞 2、空闲列表 两种方式    \n\n  * 指针碰撞  \n  \t在内存规整的情况下被使用的内存在一则，未被使用的内存在另一侧，中间存在一个指针，当需要分配时指针往未被使用的一则移动所需空间即可。  \n  * 空闲列表  \n  \t内存分配不连续，虚拟机维护一份内存使用列表，当需要分配时查找列表找到一块合适的内存进行分配后更新该列表  \n在创建对象时需要保证线程安全，虚拟机通过：1、CAS 2、TLAB 两种方式来保证线程安全\n\t* CAS  \n\tCAS是一种乐观锁的实现，每次不加锁且假设没有冲突去操作，若因为冲突而导致失败则不断重试直到成功  \n\t* TLAB  \n\t预先给线程在Eden区分配一块内存，当需要分配时在这块内存中进行分配，若该块内存空间不够则进行CAS方式分配  \n\t\n\t  \n### 初始化零值  \n   为了保证不赋初始值就能使用需要将对应的数据设置零值  \n     \n### 设置对象头  \n   虚拟机需要在零值初始化完成后把对象的一些信息存放到对象头中，包括 这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希值，GC的分年代信息等  \n     \n### 直销init方法  \n   根据代码中的意愿初始化对象  \n     \n## GC部分  \n垃圾回收算法主要有：\n* 标记-清除算法 \n* 复制算法\n* 标记-整理算法\n* 分代收集算法   \n\n### 标记-清除算法  \n垃圾收集器会标记需要清除的对象，然后清除他们。不过会导致回收后内存有大量不连续碎片。  \n### 复制算法  \n将内存分为两块，将需要保留的对象复制到一侧，回收另一侧内存。缺点是内存使用率低，会空置一半的内存。  \n### 标记-整理算法  \n将需要回收的对象进行标记，然后把不回收的对象移动到一起，回收边界以外的内存。  \n### 分代收集算法  \n根据对象的存活周期，将内存分为新生代和老年代，然后在各个年代采用前面的算法。  \n\t\n## 垃圾收集器  \n\n垃圾收集器主要有：\n* Serial收集器   \n* ParNew收集器 \n* Parallel Scavenge收集器 \n* CMS收集器 \n* G1收集器  \n### Serial收集器\n单线程收集器，执行GC时会stop the world，对新生代使用复制算法，对老年代使用标记-整理算法。  \n### ParNew收集器  \nSerial收集器的多线程版本。  \n### Parallel Scavenge收集器  \n与ParNew收集器类似，提供很多参数供用户找到最合适的停顿时间或最大吞吐量。   \n### CMS收集器  \n并发收集器，收集线程与用户线程基本上一同工作。主要步骤有：1、初始标记 2、并发标记 3、重新标记 4、并发清除  \n### G1收集器  \n使用服务器的多处理器和大内存优势的收集器，1、初始标记 2、并发标记 3、最终标记 4、筛选回收\n\n## 类加载  \n类加载过程主要分为：\n* 加载 \n* 连接 \n* 初始化  \n其中**连接**又分为：\n* 验证 \n* 准备 \n* 解析三步  \n### 加载  \n1、通过类的完全限定名获取到类文件的二进制字节流，具体获取方式不做限制。   \n2、将字节流所代表的静态存储结构转换为方法区的运行时数据。 \n3、在内存中生成一个代表该类的class对象\n\t\n### 连接部分  \n* 验证  \n\t1、验证文件格式是否符合要求  \n\t2、元数据验证  \n\t3、字节码验证  \n\t4、符号引用验证  \n* 准备  \n\t该阶段为类变量分配内存并初始化零值  \n* 解析  \n\t将常量池内的符号引用替换为直接引用  \n### 初始化  \n执行类代码中的初始化逻辑\n\n","source":"_posts/java虚拟机/jvm内存区域.md","raw":"---\ntitle: JVM内存区域和GC类型\ndate: 2019-10-15 22:02:16\ncomments: true\ncategories: \n- 笔记\ntags: \n- java\n---\n\n简单记录JVM的内存划分以及几种GC收集器  \n<!-- more -->  \n## 主要区域  \n\n* 线程公有部分\n\t* 堆 heap  \n\t\t用来存放对象实例。GC的主要区域，采用分代回收的gc算法的话还可以细分成 Eden，From Survivor(S0)，To Survivor(S1)，Tentired。其中Eden，S0，S1属于新生代，Tentired属于老年代，当对象在 Eden经过一次GC后对象年龄+1并且进入S0，S1区，当他的年龄增加到一定程度会进入Tentired老年区，或者s区域相同年龄的对象所占空间大于s总空间的一半，那对象大于这个年龄的都会进入老年代。    \n\t* 方法区  \n\t\t用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。\n\n\t* 运行时常量池\n\t\t方法区的一部分，也是线程共享的。\n\n* 线程私有部分  \n\t* 虚拟机栈  \n\t\t每个方法调用都是通过栈传递的，由栈帧组成，每个栈帧都包含了：1、局部变量表 2、操作数栈 3、动态链表 4、方法出口信息等。  \n\t\t每次函数调用都会有一个栈帧入栈，调用结束后会有个栈帧出栈，抛出异常也会出栈。  \n\t* 本地方法栈  \n\t\t调用native方法也会创建栈帧入本地方法栈，HotSpot虚拟机中本地方法栈和虚拟机栈是同一个。  \n\t* 程序计数器\n\t\t当前程序执行的行号指示器，可以保证线程切换后能恢复到原来的执行位置。通过程序计数器来获取下一步要执行的字节码指令。  \n* 直接内存\n\t* 元空间\n\t在jdk1.8之后移除了方法区，原方法区的内容移动到了直接内存中的元空间内  \n\t\n\t  \n## HotSpot    \n\n### 对象的创建过程    \n \n* 类加载检查 \n* 分配内存 \n* 初始化零值 \n* 设置对象头 \n* 执行init方法   \n\n### 类加载检查  \n  当虚拟机执行到new指令时，会检查是否能在常量池中找到这个类的符号引用，并且检查该类是否被加载、解析和初始化过。若没有则进行对应的类加载操作。  \n\n### 分配内存  \n  根据内存是否规整分为：1、指针碰撞 2、空闲列表 两种方式    \n\n  * 指针碰撞  \n  \t在内存规整的情况下被使用的内存在一则，未被使用的内存在另一侧，中间存在一个指针，当需要分配时指针往未被使用的一则移动所需空间即可。  \n  * 空闲列表  \n  \t内存分配不连续，虚拟机维护一份内存使用列表，当需要分配时查找列表找到一块合适的内存进行分配后更新该列表  \n在创建对象时需要保证线程安全，虚拟机通过：1、CAS 2、TLAB 两种方式来保证线程安全\n\t* CAS  \n\tCAS是一种乐观锁的实现，每次不加锁且假设没有冲突去操作，若因为冲突而导致失败则不断重试直到成功  \n\t* TLAB  \n\t预先给线程在Eden区分配一块内存，当需要分配时在这块内存中进行分配，若该块内存空间不够则进行CAS方式分配  \n\t\n\t  \n### 初始化零值  \n   为了保证不赋初始值就能使用需要将对应的数据设置零值  \n     \n### 设置对象头  \n   虚拟机需要在零值初始化完成后把对象的一些信息存放到对象头中，包括 这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希值，GC的分年代信息等  \n     \n### 直销init方法  \n   根据代码中的意愿初始化对象  \n     \n## GC部分  \n垃圾回收算法主要有：\n* 标记-清除算法 \n* 复制算法\n* 标记-整理算法\n* 分代收集算法   \n\n### 标记-清除算法  \n垃圾收集器会标记需要清除的对象，然后清除他们。不过会导致回收后内存有大量不连续碎片。  \n### 复制算法  \n将内存分为两块，将需要保留的对象复制到一侧，回收另一侧内存。缺点是内存使用率低，会空置一半的内存。  \n### 标记-整理算法  \n将需要回收的对象进行标记，然后把不回收的对象移动到一起，回收边界以外的内存。  \n### 分代收集算法  \n根据对象的存活周期，将内存分为新生代和老年代，然后在各个年代采用前面的算法。  \n\t\n## 垃圾收集器  \n\n垃圾收集器主要有：\n* Serial收集器   \n* ParNew收集器 \n* Parallel Scavenge收集器 \n* CMS收集器 \n* G1收集器  \n### Serial收集器\n单线程收集器，执行GC时会stop the world，对新生代使用复制算法，对老年代使用标记-整理算法。  \n### ParNew收集器  \nSerial收集器的多线程版本。  \n### Parallel Scavenge收集器  \n与ParNew收集器类似，提供很多参数供用户找到最合适的停顿时间或最大吞吐量。   \n### CMS收集器  \n并发收集器，收集线程与用户线程基本上一同工作。主要步骤有：1、初始标记 2、并发标记 3、重新标记 4、并发清除  \n### G1收集器  \n使用服务器的多处理器和大内存优势的收集器，1、初始标记 2、并发标记 3、最终标记 4、筛选回收\n\n## 类加载  \n类加载过程主要分为：\n* 加载 \n* 连接 \n* 初始化  \n其中**连接**又分为：\n* 验证 \n* 准备 \n* 解析三步  \n### 加载  \n1、通过类的完全限定名获取到类文件的二进制字节流，具体获取方式不做限制。   \n2、将字节流所代表的静态存储结构转换为方法区的运行时数据。 \n3、在内存中生成一个代表该类的class对象\n\t\n### 连接部分  \n* 验证  \n\t1、验证文件格式是否符合要求  \n\t2、元数据验证  \n\t3、字节码验证  \n\t4、符号引用验证  \n* 准备  \n\t该阶段为类变量分配内存并初始化零值  \n* 解析  \n\t将常量池内的符号引用替换为直接引用  \n### 初始化  \n执行类代码中的初始化逻辑\n\n","slug":"java虚拟机/jvm内存区域","published":1,"updated":"2020-01-29T13:35:41.188Z","_id":"ck5ibb8up000dd4rmuzxhzmzz","layout":"post","photos":[],"link":"","content":"<p>简单记录JVM的内存划分以及几种GC收集器<br><a id=\"more\"></a>  </p>\n<h2 id=\"主要区域\"><a href=\"#主要区域\" class=\"headerlink\" title=\"主要区域\"></a>主要区域</h2><ul>\n<li><p>线程公有部分</p>\n<ul>\n<li>堆 heap<br>  用来存放对象实例。GC的主要区域，采用分代回收的gc算法的话还可以细分成 Eden，From Survivor(S0)，To Survivor(S1)，Tentired。其中Eden，S0，S1属于新生代，Tentired属于老年代，当对象在 Eden经过一次GC后对象年龄+1并且进入S0，S1区，当他的年龄增加到一定程度会进入Tentired老年区，或者s区域相同年龄的对象所占空间大于s总空间的一半，那对象大于这个年龄的都会进入老年代。    </li>\n<li><p>方法区<br>  用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。</p>\n</li>\n<li><p>运行时常量池<br>  方法区的一部分，也是线程共享的。</p>\n</li>\n</ul>\n</li>\n<li><p>线程私有部分  </p>\n<ul>\n<li>虚拟机栈<br>  每个方法调用都是通过栈传递的，由栈帧组成，每个栈帧都包含了：1、局部变量表 2、操作数栈 3、动态链表 4、方法出口信息等。<br>  每次函数调用都会有一个栈帧入栈，调用结束后会有个栈帧出栈，抛出异常也会出栈。  </li>\n<li>本地方法栈<br>  调用native方法也会创建栈帧入本地方法栈，HotSpot虚拟机中本地方法栈和虚拟机栈是同一个。  </li>\n<li>程序计数器<br>  当前程序执行的行号指示器，可以保证线程切换后能恢复到原来的执行位置。通过程序计数器来获取下一步要执行的字节码指令。  </li>\n</ul>\n</li>\n<li>直接内存<ul>\n<li>元空间<br>在jdk1.8之后移除了方法区，原方法区的内容移动到了直接内存中的元空间内  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HotSpot\"><a href=\"#HotSpot\" class=\"headerlink\" title=\"HotSpot\"></a>HotSpot</h2><h3 id=\"对象的创建过程\"><a href=\"#对象的创建过程\" class=\"headerlink\" title=\"对象的创建过程\"></a>对象的创建过程</h3><ul>\n<li>类加载检查 </li>\n<li>分配内存 </li>\n<li>初始化零值 </li>\n<li>设置对象头 </li>\n<li>执行init方法   </li>\n</ul>\n<h3 id=\"类加载检查\"><a href=\"#类加载检查\" class=\"headerlink\" title=\"类加载检查\"></a>类加载检查</h3><p>  当虚拟机执行到new指令时，会检查是否能在常量池中找到这个类的符号引用，并且检查该类是否被加载、解析和初始化过。若没有则进行对应的类加载操作。  </p>\n<h3 id=\"分配内存\"><a href=\"#分配内存\" class=\"headerlink\" title=\"分配内存\"></a>分配内存</h3><p>  根据内存是否规整分为：1、指针碰撞 2、空闲列表 两种方式    </p>\n<ul>\n<li>指针碰撞<br>  在内存规整的情况下被使用的内存在一则，未被使用的内存在另一侧，中间存在一个指针，当需要分配时指针往未被使用的一则移动所需空间即可。  </li>\n<li>空闲列表<br>  内存分配不连续，虚拟机维护一份内存使用列表，当需要分配时查找列表找到一块合适的内存进行分配后更新该列表<br>在创建对象时需要保证线程安全，虚拟机通过：1、CAS 2、TLAB 两种方式来保证线程安全<ul>\n<li>CAS<br>CAS是一种乐观锁的实现，每次不加锁且假设没有冲突去操作，若因为冲突而导致失败则不断重试直到成功  </li>\n<li>TLAB<br>预先给线程在Eden区分配一块内存，当需要分配时在这块内存中进行分配，若该块内存空间不够则进行CAS方式分配  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初始化零值\"><a href=\"#初始化零值\" class=\"headerlink\" title=\"初始化零值\"></a>初始化零值</h3><p>   为了保证不赋初始值就能使用需要将对应的数据设置零值  </p>\n<h3 id=\"设置对象头\"><a href=\"#设置对象头\" class=\"headerlink\" title=\"设置对象头\"></a>设置对象头</h3><p>   虚拟机需要在零值初始化完成后把对象的一些信息存放到对象头中，包括 这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希值，GC的分年代信息等  </p>\n<h3 id=\"直销init方法\"><a href=\"#直销init方法\" class=\"headerlink\" title=\"直销init方法\"></a>直销init方法</h3><p>   根据代码中的意愿初始化对象  </p>\n<h2 id=\"GC部分\"><a href=\"#GC部分\" class=\"headerlink\" title=\"GC部分\"></a>GC部分</h2><p>垃圾回收算法主要有：</p>\n<ul>\n<li>标记-清除算法 </li>\n<li>复制算法</li>\n<li>标记-整理算法</li>\n<li>分代收集算法   </li>\n</ul>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>垃圾收集器会标记需要清除的对象，然后清除他们。不过会导致回收后内存有大量不连续碎片。  </p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>将内存分为两块，将需要保留的对象复制到一侧，回收另一侧内存。缺点是内存使用率低，会空置一半的内存。  </p>\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>将需要回收的对象进行标记，然后把不回收的对象移动到一起，回收边界以外的内存。  </p>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><p>根据对象的存活周期，将内存分为新生代和老年代，然后在各个年代采用前面的算法。  </p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>垃圾收集器主要有：</p>\n<ul>\n<li>Serial收集器   </li>\n<li>ParNew收集器 </li>\n<li>Parallel Scavenge收集器 </li>\n<li>CMS收集器 </li>\n<li>G1收集器  <h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3>单线程收集器，执行GC时会stop the world，对新生代使用复制算法，对老年代使用标记-整理算法。  <h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3>Serial收集器的多线程版本。  <h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3>与ParNew收集器类似，提供很多参数供用户找到最合适的停顿时间或最大吞吐量。   <h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3>并发收集器，收集线程与用户线程基本上一同工作。主要步骤有：1、初始标记 2、并发标记 3、重新标记 4、并发清除  <h3 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h3>使用服务器的多处理器和大内存优势的收集器，1、初始标记 2、并发标记 3、最终标记 4、筛选回收</li>\n</ul>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><p>类加载过程主要分为：</p>\n<ul>\n<li>加载 </li>\n<li>连接 </li>\n<li>初始化<br>其中<strong>连接</strong>又分为：</li>\n<li>验证 </li>\n<li>准备 </li>\n<li>解析三步  <h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3>1、通过类的完全限定名获取到类文件的二进制字节流，具体获取方式不做限制。<br>2、将字节流所代表的静态存储结构转换为方法区的运行时数据。<br>3、在内存中生成一个代表该类的class对象</li>\n</ul>\n<h3 id=\"连接部分\"><a href=\"#连接部分\" class=\"headerlink\" title=\"连接部分\"></a>连接部分</h3><ul>\n<li>验证<br>  1、验证文件格式是否符合要求<br>  2、元数据验证<br>  3、字节码验证<br>  4、符号引用验证  </li>\n<li>准备<br>  该阶段为类变量分配内存并初始化零值  </li>\n<li>解析<br>  将常量池内的符号引用替换为直接引用  <h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3>执行类代码中的初始化逻辑</li>\n</ul>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>简单记录JVM的内存划分以及几种GC收集器<br>","more":"</p>\n<h2 id=\"主要区域\"><a href=\"#主要区域\" class=\"headerlink\" title=\"主要区域\"></a>主要区域</h2><ul>\n<li><p>线程公有部分</p>\n<ul>\n<li>堆 heap<br>  用来存放对象实例。GC的主要区域，采用分代回收的gc算法的话还可以细分成 Eden，From Survivor(S0)，To Survivor(S1)，Tentired。其中Eden，S0，S1属于新生代，Tentired属于老年代，当对象在 Eden经过一次GC后对象年龄+1并且进入S0，S1区，当他的年龄增加到一定程度会进入Tentired老年区，或者s区域相同年龄的对象所占空间大于s总空间的一半，那对象大于这个年龄的都会进入老年代。    </li>\n<li><p>方法区<br>  用于存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码数据等。</p>\n</li>\n<li><p>运行时常量池<br>  方法区的一部分，也是线程共享的。</p>\n</li>\n</ul>\n</li>\n<li><p>线程私有部分  </p>\n<ul>\n<li>虚拟机栈<br>  每个方法调用都是通过栈传递的，由栈帧组成，每个栈帧都包含了：1、局部变量表 2、操作数栈 3、动态链表 4、方法出口信息等。<br>  每次函数调用都会有一个栈帧入栈，调用结束后会有个栈帧出栈，抛出异常也会出栈。  </li>\n<li>本地方法栈<br>  调用native方法也会创建栈帧入本地方法栈，HotSpot虚拟机中本地方法栈和虚拟机栈是同一个。  </li>\n<li>程序计数器<br>  当前程序执行的行号指示器，可以保证线程切换后能恢复到原来的执行位置。通过程序计数器来获取下一步要执行的字节码指令。  </li>\n</ul>\n</li>\n<li>直接内存<ul>\n<li>元空间<br>在jdk1.8之后移除了方法区，原方法区的内容移动到了直接内存中的元空间内  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HotSpot\"><a href=\"#HotSpot\" class=\"headerlink\" title=\"HotSpot\"></a>HotSpot</h2><h3 id=\"对象的创建过程\"><a href=\"#对象的创建过程\" class=\"headerlink\" title=\"对象的创建过程\"></a>对象的创建过程</h3><ul>\n<li>类加载检查 </li>\n<li>分配内存 </li>\n<li>初始化零值 </li>\n<li>设置对象头 </li>\n<li>执行init方法   </li>\n</ul>\n<h3 id=\"类加载检查\"><a href=\"#类加载检查\" class=\"headerlink\" title=\"类加载检查\"></a>类加载检查</h3><p>  当虚拟机执行到new指令时，会检查是否能在常量池中找到这个类的符号引用，并且检查该类是否被加载、解析和初始化过。若没有则进行对应的类加载操作。  </p>\n<h3 id=\"分配内存\"><a href=\"#分配内存\" class=\"headerlink\" title=\"分配内存\"></a>分配内存</h3><p>  根据内存是否规整分为：1、指针碰撞 2、空闲列表 两种方式    </p>\n<ul>\n<li>指针碰撞<br>  在内存规整的情况下被使用的内存在一则，未被使用的内存在另一侧，中间存在一个指针，当需要分配时指针往未被使用的一则移动所需空间即可。  </li>\n<li>空闲列表<br>  内存分配不连续，虚拟机维护一份内存使用列表，当需要分配时查找列表找到一块合适的内存进行分配后更新该列表<br>在创建对象时需要保证线程安全，虚拟机通过：1、CAS 2、TLAB 两种方式来保证线程安全<ul>\n<li>CAS<br>CAS是一种乐观锁的实现，每次不加锁且假设没有冲突去操作，若因为冲突而导致失败则不断重试直到成功  </li>\n<li>TLAB<br>预先给线程在Eden区分配一块内存，当需要分配时在这块内存中进行分配，若该块内存空间不够则进行CAS方式分配  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"初始化零值\"><a href=\"#初始化零值\" class=\"headerlink\" title=\"初始化零值\"></a>初始化零值</h3><p>   为了保证不赋初始值就能使用需要将对应的数据设置零值  </p>\n<h3 id=\"设置对象头\"><a href=\"#设置对象头\" class=\"headerlink\" title=\"设置对象头\"></a>设置对象头</h3><p>   虚拟机需要在零值初始化完成后把对象的一些信息存放到对象头中，包括 这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希值，GC的分年代信息等  </p>\n<h3 id=\"直销init方法\"><a href=\"#直销init方法\" class=\"headerlink\" title=\"直销init方法\"></a>直销init方法</h3><p>   根据代码中的意愿初始化对象  </p>\n<h2 id=\"GC部分\"><a href=\"#GC部分\" class=\"headerlink\" title=\"GC部分\"></a>GC部分</h2><p>垃圾回收算法主要有：</p>\n<ul>\n<li>标记-清除算法 </li>\n<li>复制算法</li>\n<li>标记-整理算法</li>\n<li>分代收集算法   </li>\n</ul>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>垃圾收集器会标记需要清除的对象，然后清除他们。不过会导致回收后内存有大量不连续碎片。  </p>\n<h3 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h3><p>将内存分为两块，将需要保留的对象复制到一侧，回收另一侧内存。缺点是内存使用率低，会空置一半的内存。  </p>\n<h3 id=\"标记-整理算法\"><a href=\"#标记-整理算法\" class=\"headerlink\" title=\"标记-整理算法\"></a>标记-整理算法</h3><p>将需要回收的对象进行标记，然后把不回收的对象移动到一起，回收边界以外的内存。  </p>\n<h3 id=\"分代收集算法\"><a href=\"#分代收集算法\" class=\"headerlink\" title=\"分代收集算法\"></a>分代收集算法</h3><p>根据对象的存活周期，将内存分为新生代和老年代，然后在各个年代采用前面的算法。  </p>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>垃圾收集器主要有：</p>\n<ul>\n<li>Serial收集器   </li>\n<li>ParNew收集器 </li>\n<li>Parallel Scavenge收集器 </li>\n<li>CMS收集器 </li>\n<li>G1收集器  <h3 id=\"Serial收集器\"><a href=\"#Serial收集器\" class=\"headerlink\" title=\"Serial收集器\"></a>Serial收集器</h3>单线程收集器，执行GC时会stop the world，对新生代使用复制算法，对老年代使用标记-整理算法。  <h3 id=\"ParNew收集器\"><a href=\"#ParNew收集器\" class=\"headerlink\" title=\"ParNew收集器\"></a>ParNew收集器</h3>Serial收集器的多线程版本。  <h3 id=\"Parallel-Scavenge收集器\"><a href=\"#Parallel-Scavenge收集器\" class=\"headerlink\" title=\"Parallel Scavenge收集器\"></a>Parallel Scavenge收集器</h3>与ParNew收集器类似，提供很多参数供用户找到最合适的停顿时间或最大吞吐量。   <h3 id=\"CMS收集器\"><a href=\"#CMS收集器\" class=\"headerlink\" title=\"CMS收集器\"></a>CMS收集器</h3>并发收集器，收集线程与用户线程基本上一同工作。主要步骤有：1、初始标记 2、并发标记 3、重新标记 4、并发清除  <h3 id=\"G1收集器\"><a href=\"#G1收集器\" class=\"headerlink\" title=\"G1收集器\"></a>G1收集器</h3>使用服务器的多处理器和大内存优势的收集器，1、初始标记 2、并发标记 3、最终标记 4、筛选回收</li>\n</ul>\n<h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><p>类加载过程主要分为：</p>\n<ul>\n<li>加载 </li>\n<li>连接 </li>\n<li>初始化<br>其中<strong>连接</strong>又分为：</li>\n<li>验证 </li>\n<li>准备 </li>\n<li>解析三步  <h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3>1、通过类的完全限定名获取到类文件的二进制字节流，具体获取方式不做限制。<br>2、将字节流所代表的静态存储结构转换为方法区的运行时数据。<br>3、在内存中生成一个代表该类的class对象</li>\n</ul>\n<h3 id=\"连接部分\"><a href=\"#连接部分\" class=\"headerlink\" title=\"连接部分\"></a>连接部分</h3><ul>\n<li>验证<br>  1、验证文件格式是否符合要求<br>  2、元数据验证<br>  3、字节码验证<br>  4、符号引用验证  </li>\n<li>准备<br>  该阶段为类变量分配内存并初始化零值  </li>\n<li>解析<br>  将常量池内的符号引用替换为直接引用  <h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3>执行类代码中的初始化逻辑</li>\n</ul>"},{"title":"类加载器","date":"2019-02-24T04:39:04.000Z","comments":1,"_content":"\n类加载器，是java虚拟机中用来加载各种乱七八糟的类的代码模块.  \n平常开发过程中使用某个自定义或者别人的类的时候，全靠编辑器比如idea自动引入，或者自己写个import（很少有人这么干），那么开发时只要import就好了.  \n程序执行时对虚拟机来说它是怎么找到你要使用的类并且引入的呢？  \n靠的当然是类加载器  \n<!-- more -->\n## 类加载器的种类  \n\n常见的类加载器主要有四种  \n\n* 启动类类加载器 BootstrapClassLoader   \n启动java应用时的加载器，由C++实现，所以在找到它的时候会是个null\n* 拓展类（平台类）加载器 ExtClassLoader  \n继承自至BootstrapClassLoader，在java9之后被改为平台类加载器，讲道理他们还是一样的，改了个名字？  \n* 应用加载器 AppClassLoader  \n继承自ExtClassLoader，应用程序加载器，平时引用的jar包的类都是它进行加载的   \n* 自定义的加载器  \n只要继承自ClassLoader，上面提到的类加载器不能用来被继承，因为有访问权限，自定义的话无法取得。自定义的加载器，java有个双亲委派模型需要准守，是个默认规范，不遵守..也没事(建议遵守)    \n  \n  \n##  双亲委派模型   \n在自定义加载器那里提到了双亲委派模型，那什么是双亲委派模型呢？     \n\n----  \n   \n类加载器存在继承结构，最顶层父类是BootstrapClassLoader，如果一个自定义的类加载器想要加载一个类，比如想加载一个String类，那么自定义的类加载器不应该自己去查找这个class对象，而是应该委托它的父类去查找、加载，它的父类又会委托自己的父类去查找、加载，一层层往上，父类加载器表示说我找不到这个类，子加载器才会自行去查找。这样就可以保证类只被加载一次。  \n在虚拟机中，一个类的唯一性并不仅仅是靠它的完全限定名来确定的，一个类的完全限定名+对应的类加载器才能唯一确定在虚拟机中的一个类。  \n在自定义类加载器的时候是需要遵循这个规范的，然鹅其实并没有强制措施，实现自定义的类加载器主要是重写findClass方法。  \n来看loadClass方法  \n```  \n  protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n```\n它主要的操作就是先检查要找的类是否被加载了，没有的话parent为null的时候即是BootstrapClassLoader的时候就调findBootstrapClassOrNull方法查找，不然就是调用父类的loadClass方法查找，如果都没有就调用自己的findClass方法。     \n那这个findClass方法就是自定义classLoader的时候要重写的方法了。     \n### 链接\n并不是类加载完了就直接使用的，还需要链接，链接分为验证、准备、解析三个阶段\n验证主要是用来校验类文件符合虚拟机的约束条件，然后进行准备阶段  \n准备阶段主要是为该类的静态字段分配内存，初始化静态字段是会在初始化阶段进行的。\n解析阶段主要是生成对类方法和字段的引用的地址  \n在其他类引用某个类的时候，比如类A的a方法，写成  \n```\nA aObject = new A();\naObject.a();\n```\n进行编译后，会生成类，方法以及参数等的符号引用，用来指代这些方法。  \n所以解析的时候是将这些符号引用变成实际引用。  \n### 初始化  \n类中的静态字段和静态代码块都会被放入clinit方法中，在类加载的初始化过程中为这些赋值，以及执行静态代码块的内容，执行完初始化后类才可被用。  \n想起来以前不知道在哪看到的一个说法，static静态代码块的代码是在new对象时才会执行的说法是错误的。  \n比如下面这个类  \n```  \npublic class test {\n    public static int a = 1;\n    static{\n        System.out.println(\"hhhhh\");\n    }\n}\n```\n进行这样调用时  \n```  \npublic class main {\n    public static void main(String[] args) {\n        System.out.println(\"要打印了\");\n\n        System.out.println(test.a);\n        new test();\n    }\n}\n```\n结果是    \n\n![](/images/imageForPost/类加载器-pic-1.png)\n\n\n\n\n\n","source":"_posts/java虚拟机/类加载器.md","raw":"---\ntitle: 类加载器\ndate: 2019-02-24 12:39:04\ncomments: true\ncategories: \n- 笔记\ntags: \n- java\n---\n\n类加载器，是java虚拟机中用来加载各种乱七八糟的类的代码模块.  \n平常开发过程中使用某个自定义或者别人的类的时候，全靠编辑器比如idea自动引入，或者自己写个import（很少有人这么干），那么开发时只要import就好了.  \n程序执行时对虚拟机来说它是怎么找到你要使用的类并且引入的呢？  \n靠的当然是类加载器  \n<!-- more -->\n## 类加载器的种类  \n\n常见的类加载器主要有四种  \n\n* 启动类类加载器 BootstrapClassLoader   \n启动java应用时的加载器，由C++实现，所以在找到它的时候会是个null\n* 拓展类（平台类）加载器 ExtClassLoader  \n继承自至BootstrapClassLoader，在java9之后被改为平台类加载器，讲道理他们还是一样的，改了个名字？  \n* 应用加载器 AppClassLoader  \n继承自ExtClassLoader，应用程序加载器，平时引用的jar包的类都是它进行加载的   \n* 自定义的加载器  \n只要继承自ClassLoader，上面提到的类加载器不能用来被继承，因为有访问权限，自定义的话无法取得。自定义的加载器，java有个双亲委派模型需要准守，是个默认规范，不遵守..也没事(建议遵守)    \n  \n  \n##  双亲委派模型   \n在自定义加载器那里提到了双亲委派模型，那什么是双亲委派模型呢？     \n\n----  \n   \n类加载器存在继承结构，最顶层父类是BootstrapClassLoader，如果一个自定义的类加载器想要加载一个类，比如想加载一个String类，那么自定义的类加载器不应该自己去查找这个class对象，而是应该委托它的父类去查找、加载，它的父类又会委托自己的父类去查找、加载，一层层往上，父类加载器表示说我找不到这个类，子加载器才会自行去查找。这样就可以保证类只被加载一次。  \n在虚拟机中，一个类的唯一性并不仅仅是靠它的完全限定名来确定的，一个类的完全限定名+对应的类加载器才能唯一确定在虚拟机中的一个类。  \n在自定义类加载器的时候是需要遵循这个规范的，然鹅其实并没有强制措施，实现自定义的类加载器主要是重写findClass方法。  \n来看loadClass方法  \n```  \n  protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n\n```\n它主要的操作就是先检查要找的类是否被加载了，没有的话parent为null的时候即是BootstrapClassLoader的时候就调findBootstrapClassOrNull方法查找，不然就是调用父类的loadClass方法查找，如果都没有就调用自己的findClass方法。     \n那这个findClass方法就是自定义classLoader的时候要重写的方法了。     \n### 链接\n并不是类加载完了就直接使用的，还需要链接，链接分为验证、准备、解析三个阶段\n验证主要是用来校验类文件符合虚拟机的约束条件，然后进行准备阶段  \n准备阶段主要是为该类的静态字段分配内存，初始化静态字段是会在初始化阶段进行的。\n解析阶段主要是生成对类方法和字段的引用的地址  \n在其他类引用某个类的时候，比如类A的a方法，写成  \n```\nA aObject = new A();\naObject.a();\n```\n进行编译后，会生成类，方法以及参数等的符号引用，用来指代这些方法。  \n所以解析的时候是将这些符号引用变成实际引用。  \n### 初始化  \n类中的静态字段和静态代码块都会被放入clinit方法中，在类加载的初始化过程中为这些赋值，以及执行静态代码块的内容，执行完初始化后类才可被用。  \n想起来以前不知道在哪看到的一个说法，static静态代码块的代码是在new对象时才会执行的说法是错误的。  \n比如下面这个类  \n```  \npublic class test {\n    public static int a = 1;\n    static{\n        System.out.println(\"hhhhh\");\n    }\n}\n```\n进行这样调用时  \n```  \npublic class main {\n    public static void main(String[] args) {\n        System.out.println(\"要打印了\");\n\n        System.out.println(test.a);\n        new test();\n    }\n}\n```\n结果是    \n\n![](/images/imageForPost/类加载器-pic-1.png)\n\n\n\n\n\n","slug":"java虚拟机/类加载器","published":1,"updated":"2020-01-29T14:01:17.112Z","_id":"ck5ibb8us000fd4rm3gwims6z","layout":"post","photos":[],"link":"","content":"<p>类加载器，是java虚拟机中用来加载各种乱七八糟的类的代码模块.<br>平常开发过程中使用某个自定义或者别人的类的时候，全靠编辑器比如idea自动引入，或者自己写个import（很少有人这么干），那么开发时只要import就好了.<br>程序执行时对虚拟机来说它是怎么找到你要使用的类并且引入的呢？<br>靠的当然是类加载器<br><a id=\"more\"></a></p>\n<h2 id=\"类加载器的种类\"><a href=\"#类加载器的种类\" class=\"headerlink\" title=\"类加载器的种类\"></a>类加载器的种类</h2><p>常见的类加载器主要有四种  </p>\n<ul>\n<li>启动类类加载器 BootstrapClassLoader<br>启动java应用时的加载器，由C++实现，所以在找到它的时候会是个null</li>\n<li>拓展类（平台类）加载器 ExtClassLoader<br>继承自至BootstrapClassLoader，在java9之后被改为平台类加载器，讲道理他们还是一样的，改了个名字？  </li>\n<li>应用加载器 AppClassLoader<br>继承自ExtClassLoader，应用程序加载器，平时引用的jar包的类都是它进行加载的   </li>\n<li>自定义的加载器<br>只要继承自ClassLoader，上面提到的类加载器不能用来被继承，因为有访问权限，自定义的话无法取得。自定义的加载器，java有个双亲委派模型需要准守，是个默认规范，不遵守..也没事(建议遵守)    </li>\n</ul>\n<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><p>在自定义加载器那里提到了双亲委派模型，那什么是双亲委派模型呢？     </p>\n<hr>\n<p>类加载器存在继承结构，最顶层父类是BootstrapClassLoader，如果一个自定义的类加载器想要加载一个类，比如想加载一个String类，那么自定义的类加载器不应该自己去查找这个class对象，而是应该委托它的父类去查找、加载，它的父类又会委托自己的父类去查找、加载，一层层往上，父类加载器表示说我找不到这个类，子加载器才会自行去查找。这样就可以保证类只被加载一次。<br>在虚拟机中，一个类的唯一性并不仅仅是靠它的完全限定名来确定的，一个类的完全限定名+对应的类加载器才能唯一确定在虚拟机中的一个类。<br>在自定义类加载器的时候是需要遵循这个规范的，然鹅其实并没有强制措施，实现自定义的类加载器主要是重写findClass方法。<br>来看loadClass方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class=\"line\">      throws ClassNotFoundException</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      synchronized (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">          // First, check if the class has already been loaded</span><br><span class=\"line\">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          if (c == null) &#123;</span><br><span class=\"line\">              long t0 = System.nanoTime();</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                  if (parent != null) &#123;</span><br><span class=\"line\">                      c = parent.loadClass(name, false);</span><br><span class=\"line\">                  &#125; else &#123;</span><br><span class=\"line\">                      c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                  // ClassNotFoundException thrown if class not found</span><br><span class=\"line\">                  // from the non-null parent class loader</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              if (c == null) &#123;</span><br><span class=\"line\">                  // If still not found, then invoke findClass in order</span><br><span class=\"line\">                  // to find the class.</span><br><span class=\"line\">                  long t1 = System.nanoTime();</span><br><span class=\"line\">                  c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                  // this is the defining class loader; record the stats</span><br><span class=\"line\">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                  sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (resolve) &#123;</span><br><span class=\"line\">              resolveClass(c);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它主要的操作就是先检查要找的类是否被加载了，没有的话parent为null的时候即是BootstrapClassLoader的时候就调findBootstrapClassOrNull方法查找，不然就是调用父类的loadClass方法查找，如果都没有就调用自己的findClass方法。<br>那这个findClass方法就是自定义classLoader的时候要重写的方法了。     </p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>并不是类加载完了就直接使用的，还需要链接，链接分为验证、准备、解析三个阶段<br>验证主要是用来校验类文件符合虚拟机的约束条件，然后进行准备阶段<br>准备阶段主要是为该类的静态字段分配内存，初始化静态字段是会在初始化阶段进行的。<br>解析阶段主要是生成对类方法和字段的引用的地址<br>在其他类引用某个类的时候，比如类A的a方法，写成<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A aObject = new A();</span><br><span class=\"line\">aObject.a();</span><br></pre></td></tr></table></figure></p>\n<p>进行编译后，会生成类，方法以及参数等的符号引用，用来指代这些方法。<br>所以解析的时候是将这些符号引用变成实际引用。  </p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类中的静态字段和静态代码块都会被放入clinit方法中，在类加载的初始化过程中为这些赋值，以及执行静态代码块的内容，执行完初始化后类才可被用。<br>想起来以前不知道在哪看到的一个说法，static静态代码块的代码是在new对象时才会执行的说法是错误的。<br>比如下面这个类<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class test &#123;</span><br><span class=\"line\">    public static int a = 1;</span><br><span class=\"line\">    static&#123;</span><br><span class=\"line\">        System.out.println(&quot;hhhhh&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>进行这样调用时<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;要打印了&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(test.a);</span><br><span class=\"line\">        new test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果是    </p>\n<p><img src=\"/images/imageForPost/类加载器-pic-1.png\" alt></p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>类加载器，是java虚拟机中用来加载各种乱七八糟的类的代码模块.<br>平常开发过程中使用某个自定义或者别人的类的时候，全靠编辑器比如idea自动引入，或者自己写个import（很少有人这么干），那么开发时只要import就好了.<br>程序执行时对虚拟机来说它是怎么找到你要使用的类并且引入的呢？<br>靠的当然是类加载器<br>","more":"</p>\n<h2 id=\"类加载器的种类\"><a href=\"#类加载器的种类\" class=\"headerlink\" title=\"类加载器的种类\"></a>类加载器的种类</h2><p>常见的类加载器主要有四种  </p>\n<ul>\n<li>启动类类加载器 BootstrapClassLoader<br>启动java应用时的加载器，由C++实现，所以在找到它的时候会是个null</li>\n<li>拓展类（平台类）加载器 ExtClassLoader<br>继承自至BootstrapClassLoader，在java9之后被改为平台类加载器，讲道理他们还是一样的，改了个名字？  </li>\n<li>应用加载器 AppClassLoader<br>继承自ExtClassLoader，应用程序加载器，平时引用的jar包的类都是它进行加载的   </li>\n<li>自定义的加载器<br>只要继承自ClassLoader，上面提到的类加载器不能用来被继承，因为有访问权限，自定义的话无法取得。自定义的加载器，java有个双亲委派模型需要准守，是个默认规范，不遵守..也没事(建议遵守)    </li>\n</ul>\n<h2 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h2><p>在自定义加载器那里提到了双亲委派模型，那什么是双亲委派模型呢？     </p>\n<hr>\n<p>类加载器存在继承结构，最顶层父类是BootstrapClassLoader，如果一个自定义的类加载器想要加载一个类，比如想加载一个String类，那么自定义的类加载器不应该自己去查找这个class对象，而是应该委托它的父类去查找、加载，它的父类又会委托自己的父类去查找、加载，一层层往上，父类加载器表示说我找不到这个类，子加载器才会自行去查找。这样就可以保证类只被加载一次。<br>在虚拟机中，一个类的唯一性并不仅仅是靠它的完全限定名来确定的，一个类的完全限定名+对应的类加载器才能唯一确定在虚拟机中的一个类。<br>在自定义类加载器的时候是需要遵循这个规范的，然鹅其实并没有强制措施，实现自定义的类加载器主要是重写findClass方法。<br>来看loadClass方法<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class=\"line\">      throws ClassNotFoundException</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      synchronized (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">          // First, check if the class has already been loaded</span><br><span class=\"line\">          Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">          if (c == null) &#123;</span><br><span class=\"line\">              long t0 = System.nanoTime();</span><br><span class=\"line\">              try &#123;</span><br><span class=\"line\">                  if (parent != null) &#123;</span><br><span class=\"line\">                      c = parent.loadClass(name, false);</span><br><span class=\"line\">                  &#125; else &#123;</span><br><span class=\"line\">                      c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                  // ClassNotFoundException thrown if class not found</span><br><span class=\"line\">                  // from the non-null parent class loader</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              if (c == null) &#123;</span><br><span class=\"line\">                  // If still not found, then invoke findClass in order</span><br><span class=\"line\">                  // to find the class.</span><br><span class=\"line\">                  long t1 = System.nanoTime();</span><br><span class=\"line\">                  c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                  // this is the defining class loader; record the stats</span><br><span class=\"line\">                  sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                  sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                  sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          if (resolve) &#123;</span><br><span class=\"line\">              resolveClass(c);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          return c;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>它主要的操作就是先检查要找的类是否被加载了，没有的话parent为null的时候即是BootstrapClassLoader的时候就调findBootstrapClassOrNull方法查找，不然就是调用父类的loadClass方法查找，如果都没有就调用自己的findClass方法。<br>那这个findClass方法就是自定义classLoader的时候要重写的方法了。     </p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>并不是类加载完了就直接使用的，还需要链接，链接分为验证、准备、解析三个阶段<br>验证主要是用来校验类文件符合虚拟机的约束条件，然后进行准备阶段<br>准备阶段主要是为该类的静态字段分配内存，初始化静态字段是会在初始化阶段进行的。<br>解析阶段主要是生成对类方法和字段的引用的地址<br>在其他类引用某个类的时候，比如类A的a方法，写成<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">A aObject = new A();</span><br><span class=\"line\">aObject.a();</span><br></pre></td></tr></table></figure></p>\n<p>进行编译后，会生成类，方法以及参数等的符号引用，用来指代这些方法。<br>所以解析的时候是将这些符号引用变成实际引用。  </p>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>类中的静态字段和静态代码块都会被放入clinit方法中，在类加载的初始化过程中为这些赋值，以及执行静态代码块的内容，执行完初始化后类才可被用。<br>想起来以前不知道在哪看到的一个说法，static静态代码块的代码是在new对象时才会执行的说法是错误的。<br>比如下面这个类<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class test &#123;</span><br><span class=\"line\">    public static int a = 1;</span><br><span class=\"line\">    static&#123;</span><br><span class=\"line\">        System.out.println(&quot;hhhhh&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>进行这样调用时<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class main &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        System.out.println(&quot;要打印了&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(test.a);</span><br><span class=\"line\">        new test();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果是    </p>\n<p><img src=\"/images/imageForPost/类加载器-pic-1.png\" alt></p>"},{"title":"JAVA CAS FFA","date":"2019-09-26T13:02:16.000Z","comments":1,"toc":true,"_content":"\nCAS和FFA都是硬件同步原语，通过计算机硬件实现的原子操作  \nCAS 全称叫 Compare And Set    \nFFA 全称叫 Fetch And Add  \n\n<!-- more -->    \n\n-----  \n## 概述  \n\nCAS，参数有个旧值和新值，当通过CAS更改值时会比对原值是否相同，若相同则执行更新操作，不同则放弃该操作，是一个无锁的更新。  \nFFA，参数有增加的值 inc，即获取当前操作时的原值，并增加inc后返回原值，java中的FFA跟CAS实现相同。  \nCAS和FFA操作存在多步，通过编程语言是无法直接实现原子操作的，而原语是由计算机硬件实现的，所以能够有效的实现无锁的并发操作。  \n在JAVA中 CAS和FFA都是通过JNI来实现方法。  \n\n# 使用场景  \nCAS和FFA都是无锁的并发操作，那么接下来通过一个账户服务的场景来实现。  \n## 实现内容  \n存在一个账户余额balance为0，通过多个线程对账户余额进行增加，每次增加1，直到账户余额为10000。  \n通过CAS、FFA和锁三种方式实现  \n## CAS实现 \n  \n\n```java\npublic class CASTest {\n\n    private static AtomicInteger balance = new AtomicInteger(0);\n\n    @Test\n    public void cas(){\n        long startTime = System.currentTimeMillis();\n\n        Lock lock = new ReentrantLock();\n\n        for(int i = 0;i < 10000; i ++ ){\n            CompletableFuture.runAsync(()->transferByCAS(1));\n        }\n\n        while(balance.get() < 10000){\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n        System.out.println(balance);\n\n    }\n\n    public static void transferByCAS(int amount){\n        while(true){\n            int oldValue = balance.get();\n            int newValue = oldValue + amount;\n            if (balance.compareAndSet(oldValue, newValue)){\n                break;\n            }\n\n        }\n    }\n\n}\n\n```\n\n\n\n\n\n\n执行结果如下。  \n![](/images/imageForPost/笔记/CAS/CASResult.png)\n多执行几遍，除了运行时间不一样之外，账户余额仍然是被增加到了10000。通过transferByCAS可以看到当准备执行compareAndSet方法时若旧值被其他线程修改后，会放弃本次操作并不断重试，\n\n### FFA实现。\n把原代码中的transferByCAS修改为transferByFFA，代码如下  \n  \n\n```java\n    public static void transferByFFA(int amount){  \n        balance.addAndGet(amount);  \n    }\n\n```\n\n\n\n\n\n\n\n执行结果\n![](/images/imageForPost/笔记/CAS/FFAResult.png)  \n可见FFA和CAS一样都是原子操作，不会受多线程并发的影响。  \n### 锁实现  \n修改原代码为如下    \n\n```java\npublic class CASTest {\n\n    private static int balance = 0;\n\n    @Test\n    public void cas(){\n        long startTime = System.currentTimeMillis();\n\n        Lock lock = new ReentrantLock();\n\n        for(int i = 0;i < 10000; i ++ ){\n            CompletableFuture.runAsync(()->transferByLock(1, lock));\n        }\n\n        while(balance < 10000){\n        //while(balance.get() < 10000){\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n        System.out.println(balance);\n\n    }\n\n\n\n\n    public static void transferByLock(int amount, Lock lock){\n        lock.lock();\n        System.out.println(\"thread \" + Thread.currentThread().getId() + \" get lock\");\n        try {\n            balance += amount;\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n\n\n\n执行结果如下  \n在线程获取到锁的时候顺便打印了线程信息，可见CompletableFuture.runAsync()是启动了一个线程池来执行异步任务的。\n![](/images/imageForPost/笔记/CAS/LockResult.png)   \n\n\n## CAS、FFA具体实现  \n代码中的CAS和FFA都是通过AtomicInteger类来操作的，查看AtomicInteger的组成可见  \n  \n\n```java\n       private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n```\n\n\n\n\n\n\n对AtomicInteger类对象的操作都是对value进行操作，value是被volatile修饰的，对该值的操作对所有线程可见，所以不会存在脏读的情况。  \n### AtomicInteger的compareAndSet(int expect, int update)方法  \n跟进该方法可以看到他的实现为    \n\n```java\n    public final boolean compareAndSet(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n    }\n\n```\n\n\n\n\n\n\n\nunsafe.compareAndSwapInt通过JNI实现的调用。\n### AtomicInteger的addAndGet(int delta)  \n\n```java\n    public final int addAndGet(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n    }\n\n\n```\n\n\n\n\n\n\n\n继续跟进 **getAndAddInt(Object var1, long var2, int var4)方法可以看到**  \n  \n\n```java\n    public final int getAndAddInt(Object var1, long var2, int var4) {\n        int var5;\n        do {\n            var5 = this.getIntVolatile(var1, var2);\n        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n        return var5;\n    }\n\n```\n\n\n\n\n\n\n\n最终还是调用到了this.compareAndSwapInt方法，所以在JAVA中CAS和FFA实现都是相同的，FFA相比较于CAS，使用范围更小一点，只能进行增加，而CAS则可以进行其他的逻辑操作。  \n虽然CAS和FFA是一种无锁的并发操作，相比较于锁实现可以减少获取锁的开销，但是通过不间断的循环实现操作，在业务并发量大的时候也是有不小的循环开销的。而且CAS和FFA只能保证对一个共享变量的原子操作，如果业务逻辑中需要对多个共享变量进行原子操作则需要使用锁来实现。  \n## ABA问题  \n如果存在线程1和线程2，共享变量value，值为A。  \n当线程1要将value由A变成B时，获取到旧值A，线程2在线程1获取完value旧值后通过CAS操作将value从A变成B，并再次通过CAS操作将value从B变成A，此时线程1开始了它的CAS操作，并且发现value值为A，与旧值相同则可以进行操作。虽然线程1进行CAS比较的时候value值是A，但是不是最开始线程1获取到的值，而是线程2变更之后的值。  \n#### 解决方法  \n可以通过对变量value增加一个版本号，CAS操作时比较版本号，若版本号相同则进行操作，操作完成后版本号+1，版本号不同则放弃此次操作。JAVA中可以通过AtomicStampedReference来实现版本号的控制。该类的构造函数如下    \n\n```java\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n\n```\n\n\n\n\n\n\n可见比AtomicInteger的value属性多了个int stamp，即对应的版本号，通过比对这个版本号来进行CAS和FFA操作，版本号一致则修改，不一致则放弃操作并循环重试。\n\n\n","source":"_posts/笔记/JAVA CAS.md","raw":"---\ntitle: JAVA CAS FFA\ndate: 2019-09-26 21:02:16\ncomments: true\ncategories: \n  - 笔记\ntags: \n  - java\ntoc: true\n---\n\nCAS和FFA都是硬件同步原语，通过计算机硬件实现的原子操作  \nCAS 全称叫 Compare And Set    \nFFA 全称叫 Fetch And Add  \n\n<!-- more -->    \n\n-----  \n## 概述  \n\nCAS，参数有个旧值和新值，当通过CAS更改值时会比对原值是否相同，若相同则执行更新操作，不同则放弃该操作，是一个无锁的更新。  \nFFA，参数有增加的值 inc，即获取当前操作时的原值，并增加inc后返回原值，java中的FFA跟CAS实现相同。  \nCAS和FFA操作存在多步，通过编程语言是无法直接实现原子操作的，而原语是由计算机硬件实现的，所以能够有效的实现无锁的并发操作。  \n在JAVA中 CAS和FFA都是通过JNI来实现方法。  \n\n# 使用场景  \nCAS和FFA都是无锁的并发操作，那么接下来通过一个账户服务的场景来实现。  \n## 实现内容  \n存在一个账户余额balance为0，通过多个线程对账户余额进行增加，每次增加1，直到账户余额为10000。  \n通过CAS、FFA和锁三种方式实现  \n## CAS实现 \n  \n\n```java\npublic class CASTest {\n\n    private static AtomicInteger balance = new AtomicInteger(0);\n\n    @Test\n    public void cas(){\n        long startTime = System.currentTimeMillis();\n\n        Lock lock = new ReentrantLock();\n\n        for(int i = 0;i < 10000; i ++ ){\n            CompletableFuture.runAsync(()->transferByCAS(1));\n        }\n\n        while(balance.get() < 10000){\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n        System.out.println(balance);\n\n    }\n\n    public static void transferByCAS(int amount){\n        while(true){\n            int oldValue = balance.get();\n            int newValue = oldValue + amount;\n            if (balance.compareAndSet(oldValue, newValue)){\n                break;\n            }\n\n        }\n    }\n\n}\n\n```\n\n\n\n\n\n\n执行结果如下。  \n![](/images/imageForPost/笔记/CAS/CASResult.png)\n多执行几遍，除了运行时间不一样之外，账户余额仍然是被增加到了10000。通过transferByCAS可以看到当准备执行compareAndSet方法时若旧值被其他线程修改后，会放弃本次操作并不断重试，\n\n### FFA实现。\n把原代码中的transferByCAS修改为transferByFFA，代码如下  \n  \n\n```java\n    public static void transferByFFA(int amount){  \n        balance.addAndGet(amount);  \n    }\n\n```\n\n\n\n\n\n\n\n执行结果\n![](/images/imageForPost/笔记/CAS/FFAResult.png)  \n可见FFA和CAS一样都是原子操作，不会受多线程并发的影响。  \n### 锁实现  \n修改原代码为如下    \n\n```java\npublic class CASTest {\n\n    private static int balance = 0;\n\n    @Test\n    public void cas(){\n        long startTime = System.currentTimeMillis();\n\n        Lock lock = new ReentrantLock();\n\n        for(int i = 0;i < 10000; i ++ ){\n            CompletableFuture.runAsync(()->transferByLock(1, lock));\n        }\n\n        while(balance < 10000){\n        //while(balance.get() < 10000){\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        long endTime = System.currentTimeMillis();\n        System.out.println(endTime - startTime);\n        System.out.println(balance);\n\n    }\n\n\n\n\n    public static void transferByLock(int amount, Lock lock){\n        lock.lock();\n        System.out.println(\"thread \" + Thread.currentThread().getId() + \" get lock\");\n        try {\n            balance += amount;\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\n```\n\n\n\n\n执行结果如下  \n在线程获取到锁的时候顺便打印了线程信息，可见CompletableFuture.runAsync()是启动了一个线程池来执行异步任务的。\n![](/images/imageForPost/笔记/CAS/LockResult.png)   \n\n\n## CAS、FFA具体实现  \n代码中的CAS和FFA都是通过AtomicInteger类来操作的，查看AtomicInteger的组成可见  \n  \n\n```java\n       private static final long serialVersionUID = 6214790243416807050L;\n\n    // setup to use Unsafe.compareAndSwapInt for updates\n    private static final Unsafe unsafe = Unsafe.getUnsafe();\n    private static final long valueOffset;\n\n    static {\n        try {\n            valueOffset = unsafe.objectFieldOffset\n                (AtomicInteger.class.getDeclaredField(\"value\"));\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n\n    private volatile int value;\n\n```\n\n\n\n\n\n\n对AtomicInteger类对象的操作都是对value进行操作，value是被volatile修饰的，对该值的操作对所有线程可见，所以不会存在脏读的情况。  \n### AtomicInteger的compareAndSet(int expect, int update)方法  \n跟进该方法可以看到他的实现为    \n\n```java\n    public final boolean compareAndSet(int expect, int update) {\n        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n    }\n\n```\n\n\n\n\n\n\n\nunsafe.compareAndSwapInt通过JNI实现的调用。\n### AtomicInteger的addAndGet(int delta)  \n\n```java\n    public final int addAndGet(int delta) {\n        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n    }\n\n\n```\n\n\n\n\n\n\n\n继续跟进 **getAndAddInt(Object var1, long var2, int var4)方法可以看到**  \n  \n\n```java\n    public final int getAndAddInt(Object var1, long var2, int var4) {\n        int var5;\n        do {\n            var5 = this.getIntVolatile(var1, var2);\n        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n        return var5;\n    }\n\n```\n\n\n\n\n\n\n\n最终还是调用到了this.compareAndSwapInt方法，所以在JAVA中CAS和FFA实现都是相同的，FFA相比较于CAS，使用范围更小一点，只能进行增加，而CAS则可以进行其他的逻辑操作。  \n虽然CAS和FFA是一种无锁的并发操作，相比较于锁实现可以减少获取锁的开销，但是通过不间断的循环实现操作，在业务并发量大的时候也是有不小的循环开销的。而且CAS和FFA只能保证对一个共享变量的原子操作，如果业务逻辑中需要对多个共享变量进行原子操作则需要使用锁来实现。  \n## ABA问题  \n如果存在线程1和线程2，共享变量value，值为A。  \n当线程1要将value由A变成B时，获取到旧值A，线程2在线程1获取完value旧值后通过CAS操作将value从A变成B，并再次通过CAS操作将value从B变成A，此时线程1开始了它的CAS操作，并且发现value值为A，与旧值相同则可以进行操作。虽然线程1进行CAS比较的时候value值是A，但是不是最开始线程1获取到的值，而是线程2变更之后的值。  \n#### 解决方法  \n可以通过对变量value增加一个版本号，CAS操作时比较版本号，若版本号相同则进行操作，操作完成后版本号+1，版本号不同则放弃此次操作。JAVA中可以通过AtomicStampedReference来实现版本号的控制。该类的构造函数如下    \n\n```java\n    private static class Pair<T> {\n        final T reference;\n        final int stamp;\n        private Pair(T reference, int stamp) {\n            this.reference = reference;\n            this.stamp = stamp;\n        }\n        static <T> Pair<T> of(T reference, int stamp) {\n            return new Pair<T>(reference, stamp);\n        }\n    }\n\n```\n\n\n\n\n\n\n可见比AtomicInteger的value属性多了个int stamp，即对应的版本号，通过比对这个版本号来进行CAS和FFA操作，版本号一致则修改，不一致则放弃操作并循环重试。\n\n\n","slug":"笔记/JAVA CAS","published":1,"updated":"2020-01-29T13:49:50.476Z","_id":"ck5ibb8uw000kd4rmtbfbwv4y","layout":"post","photos":[],"link":"","content":"<p>CAS和FFA都是硬件同步原语，通过计算机硬件实现的原子操作<br>CAS 全称叫 Compare And Set<br>FFA 全称叫 Fetch And Add  </p>\n<a id=\"more\"></a>    \n<hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>CAS，参数有个旧值和新值，当通过CAS更改值时会比对原值是否相同，若相同则执行更新操作，不同则放弃该操作，是一个无锁的更新。<br>FFA，参数有增加的值 inc，即获取当前操作时的原值，并增加inc后返回原值，java中的FFA跟CAS实现相同。<br>CAS和FFA操作存在多步，通过编程语言是无法直接实现原子操作的，而原语是由计算机硬件实现的，所以能够有效的实现无锁的并发操作。<br>在JAVA中 CAS和FFA都是通过JNI来实现方法。  </p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><p>CAS和FFA都是无锁的并发操作，那么接下来通过一个账户服务的场景来实现。  </p>\n<h2 id=\"实现内容\"><a href=\"#实现内容\" class=\"headerlink\" title=\"实现内容\"></a>实现内容</h2><p>存在一个账户余额balance为0，通过多个线程对账户余额进行增加，每次增加1，直到账户余额为10000。<br>通过CAS、FFA和锁三种方式实现  </p>\n<h2 id=\"CAS实现\"><a href=\"#CAS实现\" class=\"headerlink\" title=\"CAS实现\"></a>CAS实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger balance = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cas</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>; i ++ )&#123;</span><br><span class=\"line\">            CompletableFuture.runAsync(()-&gt;transferByCAS(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(balance.get() &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">        System.out.println(balance);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByCAS</span><span class=\"params\">(<span class=\"keyword\">int</span> amount)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> oldValue = balance.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> newValue = oldValue + amount;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (balance.compareAndSet(oldValue, newValue))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果如下。<br><img src=\"/images/imageForPost/笔记/CAS/CASResult.png\" alt><br>多执行几遍，除了运行时间不一样之外，账户余额仍然是被增加到了10000。通过transferByCAS可以看到当准备执行compareAndSet方法时若旧值被其他线程修改后，会放弃本次操作并不断重试，</p>\n<h3 id=\"FFA实现。\"><a href=\"#FFA实现。\" class=\"headerlink\" title=\"FFA实现。\"></a>FFA实现。</h3><p>把原代码中的transferByCAS修改为transferByFFA，代码如下  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByFFA</span><span class=\"params\">(<span class=\"keyword\">int</span> amount)</span></span>&#123;  </span><br><span class=\"line\">    balance.addAndGet(amount);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果<br><img src=\"/images/imageForPost/笔记/CAS/FFAResult.png\" alt><br>可见FFA和CAS一样都是原子操作，不会受多线程并发的影响。  </p>\n<h3 id=\"锁实现\"><a href=\"#锁实现\" class=\"headerlink\" title=\"锁实现\"></a>锁实现</h3><p>修改原代码为如下    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> balance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cas</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>; i ++ )&#123;</span><br><span class=\"line\">            CompletableFuture.runAsync(()-&gt;transferByLock(<span class=\"number\">1</span>, lock));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(balance &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//while(balance.get() &lt; 10000)&#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">        System.out.println(balance);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByLock</span><span class=\"params\">(<span class=\"keyword\">int</span> amount, Lock lock)</span></span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"thread \"</span> + Thread.currentThread().getId() + <span class=\"string\">\" get lock\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            balance += amount;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果如下<br>在线程获取到锁的时候顺便打印了线程信息，可见CompletableFuture.runAsync()是启动了一个线程池来执行异步任务的。<br><img src=\"/images/imageForPost/笔记/CAS/LockResult.png\" alt>   </p>\n<h2 id=\"CAS、FFA具体实现\"><a href=\"#CAS、FFA具体实现\" class=\"headerlink\" title=\"CAS、FFA具体实现\"></a>CAS、FFA具体实现</h2><p>代码中的CAS和FFA都是通过AtomicInteger类来操作的，查看AtomicInteger的组成可见  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n<p>对AtomicInteger类对象的操作都是对value进行操作，value是被volatile修饰的，对该值的操作对所有线程可见，所以不会存在脏读的情况。  </p>\n<h3 id=\"AtomicInteger的compareAndSet-int-expect-int-update-方法\"><a href=\"#AtomicInteger的compareAndSet-int-expect-int-update-方法\" class=\"headerlink\" title=\"AtomicInteger的compareAndSet(int expect, int update)方法\"></a>AtomicInteger的compareAndSet(int expect, int update)方法</h3><p>跟进该方法可以看到他的实现为    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>unsafe.compareAndSwapInt通过JNI实现的调用。</p>\n<h3 id=\"AtomicInteger的addAndGet-int-delta\"><a href=\"#AtomicInteger的addAndGet-int-delta\" class=\"headerlink\" title=\"AtomicInteger的addAndGet(int delta)\"></a>AtomicInteger的addAndGet(int delta)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续跟进 <strong>getAndAddInt(Object var1, long var2, int var4)方法可以看到</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终还是调用到了this.compareAndSwapInt方法，所以在JAVA中CAS和FFA实现都是相同的，FFA相比较于CAS，使用范围更小一点，只能进行增加，而CAS则可以进行其他的逻辑操作。<br>虽然CAS和FFA是一种无锁的并发操作，相比较于锁实现可以减少获取锁的开销，但是通过不间断的循环实现操作，在业务并发量大的时候也是有不小的循环开销的。而且CAS和FFA只能保证对一个共享变量的原子操作，如果业务逻辑中需要对多个共享变量进行原子操作则需要使用锁来实现。  </p>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>如果存在线程1和线程2，共享变量value，值为A。<br>当线程1要将value由A变成B时，获取到旧值A，线程2在线程1获取完value旧值后通过CAS操作将value从A变成B，并再次通过CAS操作将value从B变成A，此时线程1开始了它的CAS操作，并且发现value值为A，与旧值相同则可以进行操作。虽然线程1进行CAS比较的时候value值是A，但是不是最开始线程1获取到的值，而是线程2变更之后的值。  </p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>可以通过对变量value增加一个版本号，CAS操作时比较版本号，若版本号相同则进行操作，操作完成后版本号+1，版本号不同则放弃此次操作。JAVA中可以通过AtomicStampedReference来实现版本号的控制。该类的构造函数如下    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T reference;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> stamp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Pair</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.reference = reference;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stamp = stamp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Pair&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见比AtomicInteger的value属性多了个int stamp，即对应的版本号，通过比对这个版本号来进行CAS和FFA操作，版本号一致则修改，不一致则放弃操作并循环重试。</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>CAS和FFA都是硬件同步原语，通过计算机硬件实现的原子操作<br>CAS 全称叫 Compare And Set<br>FFA 全称叫 Fetch And Add  </p>","more":"<hr>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>CAS，参数有个旧值和新值，当通过CAS更改值时会比对原值是否相同，若相同则执行更新操作，不同则放弃该操作，是一个无锁的更新。<br>FFA，参数有增加的值 inc，即获取当前操作时的原值，并增加inc后返回原值，java中的FFA跟CAS实现相同。<br>CAS和FFA操作存在多步，通过编程语言是无法直接实现原子操作的，而原语是由计算机硬件实现的，所以能够有效的实现无锁的并发操作。<br>在JAVA中 CAS和FFA都是通过JNI来实现方法。  </p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><p>CAS和FFA都是无锁的并发操作，那么接下来通过一个账户服务的场景来实现。  </p>\n<h2 id=\"实现内容\"><a href=\"#实现内容\" class=\"headerlink\" title=\"实现内容\"></a>实现内容</h2><p>存在一个账户余额balance为0，通过多个线程对账户余额进行增加，每次增加1，直到账户余额为10000。<br>通过CAS、FFA和锁三种方式实现  </p>\n<h2 id=\"CAS实现\"><a href=\"#CAS实现\" class=\"headerlink\" title=\"CAS实现\"></a>CAS实现</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger balance = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cas</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>; i ++ )&#123;</span><br><span class=\"line\">            CompletableFuture.runAsync(()-&gt;transferByCAS(<span class=\"number\">1</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(balance.get() &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">        System.out.println(balance);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByCAS</span><span class=\"params\">(<span class=\"keyword\">int</span> amount)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> oldValue = balance.get();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> newValue = oldValue + amount;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (balance.compareAndSet(oldValue, newValue))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果如下。<br><img src=\"/images/imageForPost/笔记/CAS/CASResult.png\" alt><br>多执行几遍，除了运行时间不一样之外，账户余额仍然是被增加到了10000。通过transferByCAS可以看到当准备执行compareAndSet方法时若旧值被其他线程修改后，会放弃本次操作并不断重试，</p>\n<h3 id=\"FFA实现。\"><a href=\"#FFA实现。\" class=\"headerlink\" title=\"FFA实现。\"></a>FFA实现。</h3><p>把原代码中的transferByCAS修改为transferByFFA，代码如下  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByFFA</span><span class=\"params\">(<span class=\"keyword\">int</span> amount)</span></span>&#123;  </span><br><span class=\"line\">    balance.addAndGet(amount);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果<br><img src=\"/images/imageForPost/笔记/CAS/FFAResult.png\" alt><br>可见FFA和CAS一样都是原子操作，不会受多线程并发的影响。  </p>\n<h3 id=\"锁实现\"><a href=\"#锁实现\" class=\"headerlink\" title=\"锁实现\"></a>锁实现</h3><p>修改原代码为如下    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CASTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> balance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cas</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">10000</span>; i ++ )&#123;</span><br><span class=\"line\">            CompletableFuture.runAsync(()-&gt;transferByLock(<span class=\"number\">1</span>, lock));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(balance &lt; <span class=\"number\">10000</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//while(balance.get() &lt; 10000)&#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(endTime - startTime);</span><br><span class=\"line\">        System.out.println(balance);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">transferByLock</span><span class=\"params\">(<span class=\"keyword\">int</span> amount, Lock lock)</span></span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"thread \"</span> + Thread.currentThread().getId() + <span class=\"string\">\" get lock\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            balance += amount;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行结果如下<br>在线程获取到锁的时候顺便打印了线程信息，可见CompletableFuture.runAsync()是启动了一个线程池来执行异步任务的。<br><img src=\"/images/imageForPost/笔记/CAS/LockResult.png\" alt>   </p>\n<h2 id=\"CAS、FFA具体实现\"><a href=\"#CAS、FFA具体实现\" class=\"headerlink\" title=\"CAS、FFA具体实现\"></a>CAS、FFA具体实现</h2><p>代码中的CAS和FFA都是通过AtomicInteger类来操作的，查看AtomicInteger的组成可见  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">6214790243416807050L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> valueOffset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        valueOffset = unsafe.objectFieldOffset</span><br><span class=\"line\">            (AtomicInteger.class.getDeclaredField(<span class=\"string\">\"value\"</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception ex) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(ex); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> value;</span><br></pre></td></tr></table></figure>\n<p>对AtomicInteger类对象的操作都是对value进行操作，value是被volatile修饰的，对该值的操作对所有线程可见，所以不会存在脏读的情况。  </p>\n<h3 id=\"AtomicInteger的compareAndSet-int-expect-int-update-方法\"><a href=\"#AtomicInteger的compareAndSet-int-expect-int-update-方法\" class=\"headerlink\" title=\"AtomicInteger的compareAndSet(int expect, int update)方法\"></a>AtomicInteger的compareAndSet(int expect, int update)方法</h3><p>跟进该方法可以看到他的实现为    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSet</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, valueOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>unsafe.compareAndSwapInt通过JNI实现的调用。</p>\n<h3 id=\"AtomicInteger的addAndGet-int-delta\"><a href=\"#AtomicInteger的addAndGet-int-delta\" class=\"headerlink\" title=\"AtomicInteger的addAndGet(int delta)\"></a>AtomicInteger的addAndGet(int delta)</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">addAndGet</span><span class=\"params\">(<span class=\"keyword\">int</span> delta)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.getAndAddInt(<span class=\"keyword\">this</span>, valueOffset, delta) + delta;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续跟进 <strong>getAndAddInt(Object var1, long var2, int var4)方法可以看到</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getAndAddInt</span><span class=\"params\">(Object var1, <span class=\"keyword\">long</span> var2, <span class=\"keyword\">int</span> var4)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> var5;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        var5 = <span class=\"keyword\">this</span>.getIntVolatile(var1, var2);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(!<span class=\"keyword\">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> var5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终还是调用到了this.compareAndSwapInt方法，所以在JAVA中CAS和FFA实现都是相同的，FFA相比较于CAS，使用范围更小一点，只能进行增加，而CAS则可以进行其他的逻辑操作。<br>虽然CAS和FFA是一种无锁的并发操作，相比较于锁实现可以减少获取锁的开销，但是通过不间断的循环实现操作，在业务并发量大的时候也是有不小的循环开销的。而且CAS和FFA只能保证对一个共享变量的原子操作，如果业务逻辑中需要对多个共享变量进行原子操作则需要使用锁来实现。  </p>\n<h2 id=\"ABA问题\"><a href=\"#ABA问题\" class=\"headerlink\" title=\"ABA问题\"></a>ABA问题</h2><p>如果存在线程1和线程2，共享变量value，值为A。<br>当线程1要将value由A变成B时，获取到旧值A，线程2在线程1获取完value旧值后通过CAS操作将value从A变成B，并再次通过CAS操作将value从B变成A，此时线程1开始了它的CAS操作，并且发现value值为A，与旧值相同则可以进行操作。虽然线程1进行CAS比较的时候value值是A，但是不是最开始线程1获取到的值，而是线程2变更之后的值。  </p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>可以通过对变量value增加一个版本号，CAS操作时比较版本号，若版本号相同则进行操作，操作完成后版本号+1，版本号不同则放弃此次操作。JAVA中可以通过AtomicStampedReference来实现版本号的控制。该类的构造函数如下    </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T reference;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> stamp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Pair</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.reference = reference;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.stamp = stamp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Pair&lt;T&gt; <span class=\"title\">of</span><span class=\"params\">(T reference, <span class=\"keyword\">int</span> stamp)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见比AtomicInteger的value属性多了个int stamp，即对应的版本号，通过比对这个版本号来进行CAS和FFA操作，版本号一致则修改，不一致则放弃操作并循环重试。</p>"},{"title":"HashMap","date":"2019-10-28T13:02:16.000Z","comments":1,"_content":"\nHashMap主要用来存放键值对，在JDK1.8之前，HashMap的结构有数组+链表组成，数组是HashMap的主体，链表则是用来处理哈希冲突时存放数据用的，在JDK1.8后，当出现哈希冲突的时候，即当链表长度大于阈值（一般是8），会把链表转换成红黑树来存储，以减少节点的搜索时间。\n\n<!-- more -->\n\n## HashMap的结构  \n\n### JDK1.8之前    \n\nJDK1.8之前的HashMap的存储结构由数组和链表组成。  \n\n通过key的hash值经过扰动函数处理后得到该key对应的数据在链表中的存储位置，即（n-1）&hash，n为数组长度，如果得到的位置已经存在数据，则比较hash值和key值，如果相同则覆盖不相同则挂在链表上。 \n### JDK1.8之后    \n\n基础结构跟JDK1.8之前一样，都是有数组+链表组成，当链表下挂的节点多于阈值（一般为8）后，会把链表转换成红黑树来存储，便于加快查找速度。  \n如果没有转换成红黑树的花，假设有一组数据hash值一样，那么便会不断的下挂在同一个数组节点的链表上，此时HashMap变成了线性的，查找效率会变得很慢。    \nJDK1.8之前的hash方法：  \n\n```java\n    static int hash(int var0) {\n        var0 ^= var0 >>> 20 ^ var0 >>> 12;\n        return var0 ^ var0 >>> 7 ^ var0 >>> 4;\n    }\n\n\n```\n\nJDK1.8之后的hash方法：  \n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n\n\n\n```\n可见JDK1.8之后的HashMap，若存入一个key为null值，他的hash值为0，所以HashMap只能存储一个key为null值的元素，再看JDK1.8之前若存入一个key为null的元素，  \n\n```java\n    private V putForNullKey(V var1) {\n        for(HashMap.Entry var2 = this.table[0]; var2 != null; var2 = var2.next) {\n            if (var2.key == null) {\n                Object var3 = var2.value;\n                var2.value = var1;\n                var2.recordAccess(this);\n                return var3;\n            }\n        }\n\n        ++this.modCount;\n        this.addEntry(0, (Object)null, var1, 0);\n        return null;\n    }\n\n\n```  \n### 类的属性  \n\n```java\n // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n\n\n```  \n* loadFactor  \n\t加载因子，默认值为0.75，当数组占用大于等于capacity*loadFactor时，数组需要进行扩容，默认capacity大小为16，即当数组占用大于等于12时要进行扩容，也就是resize方法。  \n\t\n### resize扩容时的rehash操作  \n当数组需要进行扩容时会重新计算hash并分配位置，该操作也就是rehash，对hash表中的所有数据进行操作，所以会比较耗时。   \n#### JDK1.8之前的resize实现   \n\n* 扩容时机    \n\n```java\n    void addEntry(int var1, K var2, V var3, int var4) {\n        HashMap.Entry var5 = this.table[var4];\n        this.table[var4] = new HashMap.Entry(var1, var2, var3, var5);\n        if (this.size++ >= this.threshold) {//当数组占用大小大于等于前面说的capacity*loadFactor时会进行扩容\n            this.resize(2 * this.table.length);\n        }\n\n    }\n\n\n```   \n\n* 扩容操作   \n \n\t\n```java\n    void resize(int var1) {\n        HashMap.Entry[] var2 = this.table;\n        int var3 = var2.length;\n        if (var3 == 1073741824) {\n            this.threshold = 2147483647; //达到最大值后就不会再扩张了\n        } else {\n            HashMap.Entry[] var4 = new HashMap.Entry[var1];//新生成一个两倍大小的数组\n            this.transfer(var4);//把原数组和对应的链表都搬移过去\n            this.table = var4;\n            this.threshold = (int)((float)var1 * this.loadFactor);\n        }\n    }\n\n\n```     \n\n* 搬移操作   \n \n\n```java\n   void transfer(HashMap.Entry[] var1) {\n        HashMap.Entry[] var2 = this.table;\n        int var3 = var1.length;\n\n        for(int var4 = 0; var4 < var2.length; ++var4) {//遍历搬运数组上的节点\n            HashMap.Entry var5 = var2[var4];\n            if (var5 != null) {\n                var2[var4] = null;\n\n                HashMap.Entry var6;//遍历搬运每个数组节点上的链表数据节点\n                do {\n                    var6 = var5.next;\n                    int var7 = indexFor(var5.hash, var3);\n                    var5.next = var1[var7];\n                    var1[var7] = var5;\n                    var5 = var6;\n                } while(var6 != null);\n            }\n        }\n\n    }\n\n\n\n```    \n\n每次resize操作时会搬运所有的Hash表数据，操作比较耗时。  \n由于操作中代码都不是同步的，所以HashMap其实不是线程安全的，如果需要保证线程安全可以使用ConcurrentHashMap，还有一个HashTable也是线程安全的。 不过HashMap的key可以为null，而这两个则不可以。   \n## HashTable  \nHashTable的get和set方法都加上了synchronized同步锁，每次调用get或者set都要加锁，会把整个表都锁住，所以性能损耗比较大。  \n## ConcurrentHashMap  \nConcurrentHashMap跟HashTable不同，不是锁住整个表，ConcurrentHashMap增加了一个Segment结构，在每个Segment结构后面才是数组，再然后下挂链表，所以并发时锁住的是Segment对象而不是整个表，锁粒度比HashTable小的多。  \n","source":"_posts/笔记/HashMap.md","raw":"---\ntitle: HashMap \ndate: 2019-10-28 21:02:16\ncomments: true\ncategories: \n- 笔记\ntags: \n- java\n---\n\nHashMap主要用来存放键值对，在JDK1.8之前，HashMap的结构有数组+链表组成，数组是HashMap的主体，链表则是用来处理哈希冲突时存放数据用的，在JDK1.8后，当出现哈希冲突的时候，即当链表长度大于阈值（一般是8），会把链表转换成红黑树来存储，以减少节点的搜索时间。\n\n<!-- more -->\n\n## HashMap的结构  \n\n### JDK1.8之前    \n\nJDK1.8之前的HashMap的存储结构由数组和链表组成。  \n\n通过key的hash值经过扰动函数处理后得到该key对应的数据在链表中的存储位置，即（n-1）&hash，n为数组长度，如果得到的位置已经存在数据，则比较hash值和key值，如果相同则覆盖不相同则挂在链表上。 \n### JDK1.8之后    \n\n基础结构跟JDK1.8之前一样，都是有数组+链表组成，当链表下挂的节点多于阈值（一般为8）后，会把链表转换成红黑树来存储，便于加快查找速度。  \n如果没有转换成红黑树的花，假设有一组数据hash值一样，那么便会不断的下挂在同一个数组节点的链表上，此时HashMap变成了线性的，查找效率会变得很慢。    \nJDK1.8之前的hash方法：  \n\n```java\n    static int hash(int var0) {\n        var0 ^= var0 >>> 20 ^ var0 >>> 12;\n        return var0 ^ var0 >>> 7 ^ var0 >>> 4;\n    }\n\n\n```\n\nJDK1.8之后的hash方法：  \n\n```java\n    static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n\n\n\n```\n可见JDK1.8之后的HashMap，若存入一个key为null值，他的hash值为0，所以HashMap只能存储一个key为null值的元素，再看JDK1.8之前若存入一个key为null的元素，  \n\n```java\n    private V putForNullKey(V var1) {\n        for(HashMap.Entry var2 = this.table[0]; var2 != null; var2 = var2.next) {\n            if (var2.key == null) {\n                Object var3 = var2.value;\n                var2.value = var1;\n                var2.recordAccess(this);\n                return var3;\n            }\n        }\n\n        ++this.modCount;\n        this.addEntry(0, (Object)null, var1, 0);\n        return null;\n    }\n\n\n```  \n### 类的属性  \n\n```java\n // 序列号\n    private static final long serialVersionUID = 362498820763181265L;    \n    // 默认的初始容量是16\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;   \n    // 最大容量\n    static final int MAXIMUM_CAPACITY = 1 << 30; \n    // 默认的填充因子\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    // 当桶(bucket)上的结点数大于这个值时会转成红黑树\n    static final int TREEIFY_THRESHOLD = 8; \n    // 当桶(bucket)上的结点数小于这个值时树转链表\n    static final int UNTREEIFY_THRESHOLD = 6;\n    // 桶中结构转化为红黑树对应的table的最小大小\n    static final int MIN_TREEIFY_CAPACITY = 64;\n    // 存储元素的数组，总是2的幂次倍\n    transient Node<k,v>[] table; \n    // 存放具体元素的集\n    transient Set<map.entry<k,v>> entrySet;\n    // 存放元素的个数，注意这个不等于数组的长度。\n    transient int size;\n    // 每次扩容和更改map结构的计数器\n    transient int modCount;   \n    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容\n    int threshold;\n    // 加载因子\n    final float loadFactor;\n\n\n```  \n* loadFactor  \n\t加载因子，默认值为0.75，当数组占用大于等于capacity*loadFactor时，数组需要进行扩容，默认capacity大小为16，即当数组占用大于等于12时要进行扩容，也就是resize方法。  \n\t\n### resize扩容时的rehash操作  \n当数组需要进行扩容时会重新计算hash并分配位置，该操作也就是rehash，对hash表中的所有数据进行操作，所以会比较耗时。   \n#### JDK1.8之前的resize实现   \n\n* 扩容时机    \n\n```java\n    void addEntry(int var1, K var2, V var3, int var4) {\n        HashMap.Entry var5 = this.table[var4];\n        this.table[var4] = new HashMap.Entry(var1, var2, var3, var5);\n        if (this.size++ >= this.threshold) {//当数组占用大小大于等于前面说的capacity*loadFactor时会进行扩容\n            this.resize(2 * this.table.length);\n        }\n\n    }\n\n\n```   \n\n* 扩容操作   \n \n\t\n```java\n    void resize(int var1) {\n        HashMap.Entry[] var2 = this.table;\n        int var3 = var2.length;\n        if (var3 == 1073741824) {\n            this.threshold = 2147483647; //达到最大值后就不会再扩张了\n        } else {\n            HashMap.Entry[] var4 = new HashMap.Entry[var1];//新生成一个两倍大小的数组\n            this.transfer(var4);//把原数组和对应的链表都搬移过去\n            this.table = var4;\n            this.threshold = (int)((float)var1 * this.loadFactor);\n        }\n    }\n\n\n```     \n\n* 搬移操作   \n \n\n```java\n   void transfer(HashMap.Entry[] var1) {\n        HashMap.Entry[] var2 = this.table;\n        int var3 = var1.length;\n\n        for(int var4 = 0; var4 < var2.length; ++var4) {//遍历搬运数组上的节点\n            HashMap.Entry var5 = var2[var4];\n            if (var5 != null) {\n                var2[var4] = null;\n\n                HashMap.Entry var6;//遍历搬运每个数组节点上的链表数据节点\n                do {\n                    var6 = var5.next;\n                    int var7 = indexFor(var5.hash, var3);\n                    var5.next = var1[var7];\n                    var1[var7] = var5;\n                    var5 = var6;\n                } while(var6 != null);\n            }\n        }\n\n    }\n\n\n\n```    \n\n每次resize操作时会搬运所有的Hash表数据，操作比较耗时。  \n由于操作中代码都不是同步的，所以HashMap其实不是线程安全的，如果需要保证线程安全可以使用ConcurrentHashMap，还有一个HashTable也是线程安全的。 不过HashMap的key可以为null，而这两个则不可以。   \n## HashTable  \nHashTable的get和set方法都加上了synchronized同步锁，每次调用get或者set都要加锁，会把整个表都锁住，所以性能损耗比较大。  \n## ConcurrentHashMap  \nConcurrentHashMap跟HashTable不同，不是锁住整个表，ConcurrentHashMap增加了一个Segment结构，在每个Segment结构后面才是数组，再然后下挂链表，所以并发时锁住的是Segment对象而不是整个表，锁粒度比HashTable小的多。  \n","slug":"笔记/HashMap","published":1,"updated":"2019-10-28T14:44:15.986Z","layout":"post","photos":[],"link":"","_id":"ck5ibb8v0000pd4rmwsv1oycs","content":"<p>HashMap主要用来存放键值对，在JDK1.8之前，HashMap的结构有数组+链表组成，数组是HashMap的主体，链表则是用来处理哈希冲突时存放数据用的，在JDK1.8后，当出现哈希冲突的时候，即当链表长度大于阈值（一般是8），会把链表转换成红黑树来存储，以减少节点的搜索时间。</p>\n<a id=\"more\"></a>\n<h2 id=\"HashMap的结构\"><a href=\"#HashMap的结构\" class=\"headerlink\" title=\"HashMap的结构\"></a>HashMap的结构</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8之前的HashMap的存储结构由数组和链表组成。  </p>\n<p>通过key的hash值经过扰动函数处理后得到该key对应的数据在链表中的存储位置，即（n-1）&amp;hash，n为数组长度，如果得到的位置已经存在数据，则比较hash值和key值，如果相同则覆盖不相同则挂在链表上。 </p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>基础结构跟JDK1.8之前一样，都是有数组+链表组成，当链表下挂的节点多于阈值（一般为8）后，会把链表转换成红黑树来存储，便于加快查找速度。<br>如果没有转换成红黑树的花，假设有一组数据hash值一样，那么便会不断的下挂在同一个数组节点的链表上，此时HashMap变成了线性的，查找效率会变得很慢。<br>JDK1.8之前的hash方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">    var0 ^= var0 &gt;&gt;&gt; <span class=\"number\">20</span> ^ var0 &gt;&gt;&gt; <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var0 ^ var0 &gt;&gt;&gt; <span class=\"number\">7</span> ^ var0 &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK1.8之后的hash方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见JDK1.8之后的HashMap，若存入一个key为null值，他的hash值为0，所以HashMap只能存储一个key为null值的元素，再看JDK1.8之前若存入一个key为null的元素，  </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">putForNullKey</span><span class=\"params\">(V var1)</span> </span>{\n    <span class=\"keyword\">for</span>(HashMap.Entry var2 = <span class=\"keyword\">this</span>.table[<span class=\"number\">0</span>]; var2 != <span class=\"keyword\">null</span>; var2 = var2.next) {\n        <span class=\"keyword\">if</span> (var2.key == <span class=\"keyword\">null</span>) {\n            Object var3 = var2.value;\n            var2.value = var1;\n            var2.recordAccess(<span class=\"keyword\">this</span>);\n            <span class=\"keyword\">return</span> var3;\n        }\n    }\n\n    ++<span class=\"keyword\">this</span>.modCount;\n    <span class=\"keyword\">this</span>.addEntry(<span class=\"number\">0</span>, (Object)<span class=\"keyword\">null</span>, var1, <span class=\"number\">0</span>);\n    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n}\n\n\n</code></pre>\n<h3 id=\"类的属性\"><a href=\"#类的属性\" class=\"headerlink\" title=\"类的属性\"></a>类的属性</h3><pre><code class=\"java\"><span class=\"comment\">// 序列号</span>\n   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    \n   <span class=\"comment\">// 默认的初始容量是16</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   \n   <span class=\"comment\">// 最大容量</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; \n   <span class=\"comment\">// 默认的填充因子</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;\n   <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; \n   <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;\n   <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;\n   <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span>\n   <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; \n   <span class=\"comment\">// 存放具体元素的集</span>\n   <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;\n   <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span>\n   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;\n   <span class=\"comment\">// 每次扩容和更改map结构的计数器</span>\n   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   \n   <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>\n   <span class=\"keyword\">int</span> threshold;\n   <span class=\"comment\">// 加载因子</span>\n   <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;\n\n\n</code></pre>\n<ul>\n<li>loadFactor<br>  加载因子，默认值为0.75，当数组占用大于等于capacity*loadFactor时，数组需要进行扩容，默认capacity大小为16，即当数组占用大于等于12时要进行扩容，也就是resize方法。  </li>\n</ul>\n<h3 id=\"resize扩容时的rehash操作\"><a href=\"#resize扩容时的rehash操作\" class=\"headerlink\" title=\"resize扩容时的rehash操作\"></a>resize扩容时的rehash操作</h3><p>当数组需要进行扩容时会重新计算hash并分配位置，该操作也就是rehash，对hash表中的所有数据进行操作，所以会比较耗时。   </p>\n<h4 id=\"JDK1-8之前的resize实现\"><a href=\"#JDK1-8之前的resize实现\" class=\"headerlink\" title=\"JDK1.8之前的resize实现\"></a>JDK1.8之前的resize实现</h4><ul>\n<li>扩容时机    </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> var1, K var2, V var3, <span class=\"keyword\">int</span> var4)</span> </span>{\n    HashMap.Entry var5 = <span class=\"keyword\">this</span>.table[var4];\n    <span class=\"keyword\">this</span>.table[var4] = <span class=\"keyword\">new</span> HashMap.Entry(var1, var2, var3, var5);\n    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size++ &gt;= <span class=\"keyword\">this</span>.threshold) {<span class=\"comment\">//当数组占用大小大于等于前面说的capacity*loadFactor时会进行扩容</span>\n        <span class=\"keyword\">this</span>.resize(<span class=\"number\">2</span> * <span class=\"keyword\">this</span>.table.length);\n    }\n\n}\n\n\n</code></pre>\n<ul>\n<li>扩容操作   </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span> </span>{\n    HashMap.Entry[] var2 = <span class=\"keyword\">this</span>.table;\n    <span class=\"keyword\">int</span> var3 = var2.length;\n    <span class=\"keyword\">if</span> (var3 == <span class=\"number\">1073741824</span>) {\n        <span class=\"keyword\">this</span>.threshold = <span class=\"number\">2147483647</span>; <span class=\"comment\">//达到最大值后就不会再扩张了</span>\n    } <span class=\"keyword\">else</span> {\n        HashMap.Entry[] var4 = <span class=\"keyword\">new</span> HashMap.Entry[var1];<span class=\"comment\">//新生成一个两倍大小的数组</span>\n        <span class=\"keyword\">this</span>.transfer(var4);<span class=\"comment\">//把原数组和对应的链表都搬移过去</span>\n        <span class=\"keyword\">this</span>.table = var4;\n        <span class=\"keyword\">this</span>.threshold = (<span class=\"keyword\">int</span>)((<span class=\"keyword\">float</span>)var1 * <span class=\"keyword\">this</span>.loadFactor);\n    }\n}\n\n\n</code></pre>\n<ul>\n<li>搬移操作   </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(HashMap.Entry[] var1)</span> </span>{\n     HashMap.Entry[] var2 = <span class=\"keyword\">this</span>.table;\n     <span class=\"keyword\">int</span> var3 = var1.length;\n\n     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var4 = <span class=\"number\">0</span>; var4 &lt; var2.length; ++var4) {<span class=\"comment\">//遍历搬运数组上的节点</span>\n         HashMap.Entry var5 = var2[var4];\n         <span class=\"keyword\">if</span> (var5 != <span class=\"keyword\">null</span>) {\n             var2[var4] = <span class=\"keyword\">null</span>;\n\n             HashMap.Entry var6;<span class=\"comment\">//遍历搬运每个数组节点上的链表数据节点</span>\n             <span class=\"keyword\">do</span> {\n                 var6 = var5.next;\n                 <span class=\"keyword\">int</span> var7 = indexFor(var5.hash, var3);\n                 var5.next = var1[var7];\n                 var1[var7] = var5;\n                 var5 = var6;\n             } <span class=\"keyword\">while</span>(var6 != <span class=\"keyword\">null</span>);\n         }\n     }\n\n }\n\n\n\n</code></pre>\n<p>每次resize操作时会搬运所有的Hash表数据，操作比较耗时。<br>由于操作中代码都不是同步的，所以HashMap其实不是线程安全的，如果需要保证线程安全可以使用ConcurrentHashMap，还有一个HashTable也是线程安全的。 不过HashMap的key可以为null，而这两个则不可以。   </p>\n<h2 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h2><p>HashTable的get和set方法都加上了synchronized同步锁，每次调用get或者set都要加锁，会把整个表都锁住，所以性能损耗比较大。  </p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap跟HashTable不同，不是锁住整个表，ConcurrentHashMap增加了一个Segment结构，在每个Segment结构后面才是数组，再然后下挂链表，所以并发时锁住的是Segment对象而不是整个表，锁粒度比HashTable小的多。  </p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>HashMap主要用来存放键值对，在JDK1.8之前，HashMap的结构有数组+链表组成，数组是HashMap的主体，链表则是用来处理哈希冲突时存放数据用的，在JDK1.8后，当出现哈希冲突的时候，即当链表长度大于阈值（一般是8），会把链表转换成红黑树来存储，以减少节点的搜索时间。</p>","more":"<h2 id=\"HashMap的结构\"><a href=\"#HashMap的结构\" class=\"headerlink\" title=\"HashMap的结构\"></a>HashMap的结构</h2><h3 id=\"JDK1-8之前\"><a href=\"#JDK1-8之前\" class=\"headerlink\" title=\"JDK1.8之前\"></a>JDK1.8之前</h3><p>JDK1.8之前的HashMap的存储结构由数组和链表组成。  </p>\n<p>通过key的hash值经过扰动函数处理后得到该key对应的数据在链表中的存储位置，即（n-1）&amp;hash，n为数组长度，如果得到的位置已经存在数据，则比较hash值和key值，如果相同则覆盖不相同则挂在链表上。 </p>\n<h3 id=\"JDK1-8之后\"><a href=\"#JDK1-8之后\" class=\"headerlink\" title=\"JDK1.8之后\"></a>JDK1.8之后</h3><p>基础结构跟JDK1.8之前一样，都是有数组+链表组成，当链表下挂的节点多于阈值（一般为8）后，会把链表转换成红黑树来存储，便于加快查找速度。<br>如果没有转换成红黑树的花，假设有一组数据hash值一样，那么便会不断的下挂在同一个数组节点的链表上，此时HashMap变成了线性的，查找效率会变得很慢。<br>JDK1.8之前的hash方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">int</span> var0)</span> </span>&#123;</span><br><span class=\"line\">    var0 ^= var0 &gt;&gt;&gt; <span class=\"number\">20</span> ^ var0 &gt;&gt;&gt; <span class=\"number\">12</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> var0 ^ var0 &gt;&gt;&gt; <span class=\"number\">7</span> ^ var0 &gt;&gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK1.8之后的hash方法：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可见JDK1.8之后的HashMap，若存入一个key为null值，他的hash值为0，所以HashMap只能存储一个key为null值的元素，再看JDK1.8之前若存入一个key为null的元素，  </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">putForNullKey</span><span class=\"params\">(V var1)</span> </span>{\n    <span class=\"keyword\">for</span>(HashMap.Entry var2 = <span class=\"keyword\">this</span>.table[<span class=\"number\">0</span>]; var2 != <span class=\"keyword\">null</span>; var2 = var2.next) {\n        <span class=\"keyword\">if</span> (var2.key == <span class=\"keyword\">null</span>) {\n            Object var3 = var2.value;\n            var2.value = var1;\n            var2.recordAccess(<span class=\"keyword\">this</span>);\n            <span class=\"keyword\">return</span> var3;\n        }\n    }\n\n    ++<span class=\"keyword\">this</span>.modCount;\n    <span class=\"keyword\">this</span>.addEntry(<span class=\"number\">0</span>, (Object)<span class=\"keyword\">null</span>, var1, <span class=\"number\">0</span>);\n    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n}\n\n\n</code></pre>\n<h3 id=\"类的属性\"><a href=\"#类的属性\" class=\"headerlink\" title=\"类的属性\"></a>类的属性</h3><pre><code class=\"java\"><span class=\"comment\">// 序列号</span>\n   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">362498820763181265L</span>;    \n   <span class=\"comment\">// 默认的初始容量是16</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;   \n   <span class=\"comment\">// 最大容量</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; \n   <span class=\"comment\">// 默认的填充因子</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;\n   <span class=\"comment\">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>; \n   <span class=\"comment\">// 当桶(bucket)上的结点数小于这个值时树转链表</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;\n   <span class=\"comment\">// 桶中结构转化为红黑树对应的table的最小大小</span>\n   <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;\n   <span class=\"comment\">// 存储元素的数组，总是2的幂次倍</span>\n   <span class=\"keyword\">transient</span> Node&lt;k,v&gt;[] table; \n   <span class=\"comment\">// 存放具体元素的集</span>\n   <span class=\"keyword\">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;\n   <span class=\"comment\">// 存放元素的个数，注意这个不等于数组的长度。</span>\n   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;\n   <span class=\"comment\">// 每次扩容和更改map结构的计数器</span>\n   <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;   \n   <span class=\"comment\">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>\n   <span class=\"keyword\">int</span> threshold;\n   <span class=\"comment\">// 加载因子</span>\n   <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;\n\n\n</code></pre>\n<ul>\n<li>loadFactor<br>  加载因子，默认值为0.75，当数组占用大于等于capacity*loadFactor时，数组需要进行扩容，默认capacity大小为16，即当数组占用大于等于12时要进行扩容，也就是resize方法。  </li>\n</ul>\n<h3 id=\"resize扩容时的rehash操作\"><a href=\"#resize扩容时的rehash操作\" class=\"headerlink\" title=\"resize扩容时的rehash操作\"></a>resize扩容时的rehash操作</h3><p>当数组需要进行扩容时会重新计算hash并分配位置，该操作也就是rehash，对hash表中的所有数据进行操作，所以会比较耗时。   </p>\n<h4 id=\"JDK1-8之前的resize实现\"><a href=\"#JDK1-8之前的resize实现\" class=\"headerlink\" title=\"JDK1.8之前的resize实现\"></a>JDK1.8之前的resize实现</h4><ul>\n<li>扩容时机    </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> var1, K var2, V var3, <span class=\"keyword\">int</span> var4)</span> </span>{\n    HashMap.Entry var5 = <span class=\"keyword\">this</span>.table[var4];\n    <span class=\"keyword\">this</span>.table[var4] = <span class=\"keyword\">new</span> HashMap.Entry(var1, var2, var3, var5);\n    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.size++ &gt;= <span class=\"keyword\">this</span>.threshold) {<span class=\"comment\">//当数组占用大小大于等于前面说的capacity*loadFactor时会进行扩容</span>\n        <span class=\"keyword\">this</span>.resize(<span class=\"number\">2</span> * <span class=\"keyword\">this</span>.table.length);\n    }\n\n}\n\n\n</code></pre>\n<ul>\n<li>扩容操作   </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> var1)</span> </span>{\n    HashMap.Entry[] var2 = <span class=\"keyword\">this</span>.table;\n    <span class=\"keyword\">int</span> var3 = var2.length;\n    <span class=\"keyword\">if</span> (var3 == <span class=\"number\">1073741824</span>) {\n        <span class=\"keyword\">this</span>.threshold = <span class=\"number\">2147483647</span>; <span class=\"comment\">//达到最大值后就不会再扩张了</span>\n    } <span class=\"keyword\">else</span> {\n        HashMap.Entry[] var4 = <span class=\"keyword\">new</span> HashMap.Entry[var1];<span class=\"comment\">//新生成一个两倍大小的数组</span>\n        <span class=\"keyword\">this</span>.transfer(var4);<span class=\"comment\">//把原数组和对应的链表都搬移过去</span>\n        <span class=\"keyword\">this</span>.table = var4;\n        <span class=\"keyword\">this</span>.threshold = (<span class=\"keyword\">int</span>)((<span class=\"keyword\">float</span>)var1 * <span class=\"keyword\">this</span>.loadFactor);\n    }\n}\n\n\n</code></pre>\n<ul>\n<li>搬移操作   </li>\n</ul>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(HashMap.Entry[] var1)</span> </span>{\n     HashMap.Entry[] var2 = <span class=\"keyword\">this</span>.table;\n     <span class=\"keyword\">int</span> var3 = var1.length;\n\n     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var4 = <span class=\"number\">0</span>; var4 &lt; var2.length; ++var4) {<span class=\"comment\">//遍历搬运数组上的节点</span>\n         HashMap.Entry var5 = var2[var4];\n         <span class=\"keyword\">if</span> (var5 != <span class=\"keyword\">null</span>) {\n             var2[var4] = <span class=\"keyword\">null</span>;\n\n             HashMap.Entry var6;<span class=\"comment\">//遍历搬运每个数组节点上的链表数据节点</span>\n             <span class=\"keyword\">do</span> {\n                 var6 = var5.next;\n                 <span class=\"keyword\">int</span> var7 = indexFor(var5.hash, var3);\n                 var5.next = var1[var7];\n                 var1[var7] = var5;\n                 var5 = var6;\n             } <span class=\"keyword\">while</span>(var6 != <span class=\"keyword\">null</span>);\n         }\n     }\n\n }\n\n\n\n</code></pre>\n<p>每次resize操作时会搬运所有的Hash表数据，操作比较耗时。<br>由于操作中代码都不是同步的，所以HashMap其实不是线程安全的，如果需要保证线程安全可以使用ConcurrentHashMap，还有一个HashTable也是线程安全的。 不过HashMap的key可以为null，而这两个则不可以。   </p>\n<h2 id=\"HashTable\"><a href=\"#HashTable\" class=\"headerlink\" title=\"HashTable\"></a>HashTable</h2><p>HashTable的get和set方法都加上了synchronized同步锁，每次调用get或者set都要加锁，会把整个表都锁住，所以性能损耗比较大。  </p>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap跟HashTable不同，不是锁住整个表，ConcurrentHashMap增加了一个Segment结构，在每个Segment结构后面才是数组，再然后下挂链表，所以并发时锁住的是Segment对象而不是整个表，锁粒度比HashTable小的多。  </p>"},{"title":"线程生命周期","date":"2019-10-17T13:02:16.000Z","comments":1,"_content":"\n线程的状态有五种状态：1、新建  2、就绪  3、运行  4、阻塞  5、等待 6、超时等待 7、死亡    \n\n<!-- more -->\n\n* 新建  \n  当程序使用new创建一个线程后，该线程就处于新建状态，jvm分配内存并且初始化成员变量的值。  \n* 就绪  \n  当线程对象调用了start()方法后，该线程处于就绪状态，Jvm会为其创建方法调用栈和程序计数器，等待系统的调度。  \n* 运行  \n  当处于就绪状态的线程获得了CPU时间，就会开始执行run()方法，此时该线程处于运行状态。  \n* 阻塞  \n  当处于运行状态的线程失去CPU资源后，进入阻塞状态。当阻塞的线程解除了阻塞状态，便会进入就绪状态，不能直接进入运行状态。  \n* 等待  \n  进入该状态的线程需要等待其他线程的一些特定动作，比如通知或者中断。 \n* 超时等待  \n  不同于等待，可以在指定时间之后结束。  \n* 死亡  \n  线程方法执行完毕或者抛出一个未被捕获的异常以及直接调用该线程的stop()方法会结束线程，结束后线程就处于死亡状态。  ","source":"_posts/笔记/线程生命周期.md","raw":"---\ntitle: 线程生命周期 \ndate: 2019-10-17 21:02:16\ncomments: true\ncategories: \n- 笔记\ntags: \n- java\n---\n\n线程的状态有五种状态：1、新建  2、就绪  3、运行  4、阻塞  5、等待 6、超时等待 7、死亡    \n\n<!-- more -->\n\n* 新建  \n  当程序使用new创建一个线程后，该线程就处于新建状态，jvm分配内存并且初始化成员变量的值。  \n* 就绪  \n  当线程对象调用了start()方法后，该线程处于就绪状态，Jvm会为其创建方法调用栈和程序计数器，等待系统的调度。  \n* 运行  \n  当处于就绪状态的线程获得了CPU时间，就会开始执行run()方法，此时该线程处于运行状态。  \n* 阻塞  \n  当处于运行状态的线程失去CPU资源后，进入阻塞状态。当阻塞的线程解除了阻塞状态，便会进入就绪状态，不能直接进入运行状态。  \n* 等待  \n  进入该状态的线程需要等待其他线程的一些特定动作，比如通知或者中断。 \n* 超时等待  \n  不同于等待，可以在指定时间之后结束。  \n* 死亡  \n  线程方法执行完毕或者抛出一个未被捕获的异常以及直接调用该线程的stop()方法会结束线程，结束后线程就处于死亡状态。  ","slug":"笔记/线程生命周期","published":1,"updated":"2019-10-28T13:31:02.719Z","layout":"post","photos":[],"link":"","_id":"ck5ibb8vn0018d4rmhpk4awjp","content":"<p>线程的状态有五种状态：1、新建  2、就绪  3、运行  4、阻塞  5、等待 6、超时等待 7、死亡    </p>\n<a id=\"more\"></a>\n<ul>\n<li>新建<br>当程序使用new创建一个线程后，该线程就处于新建状态，jvm分配内存并且初始化成员变量的值。  </li>\n<li>就绪<br>当线程对象调用了start()方法后，该线程处于就绪状态，Jvm会为其创建方法调用栈和程序计数器，等待系统的调度。  </li>\n<li>运行<br>当处于就绪状态的线程获得了CPU时间，就会开始执行run()方法，此时该线程处于运行状态。  </li>\n<li>阻塞<br>当处于运行状态的线程失去CPU资源后，进入阻塞状态。当阻塞的线程解除了阻塞状态，便会进入就绪状态，不能直接进入运行状态。  </li>\n<li>等待<br>进入该状态的线程需要等待其他线程的一些特定动作，比如通知或者中断。 </li>\n<li>超时等待<br>不同于等待，可以在指定时间之后结束。  </li>\n<li>死亡<br>线程方法执行完毕或者抛出一个未被捕获的异常以及直接调用该线程的stop()方法会结束线程，结束后线程就处于死亡状态。  </li>\n</ul>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>线程的状态有五种状态：1、新建  2、就绪  3、运行  4、阻塞  5、等待 6、超时等待 7、死亡    </p>","more":"<ul>\n<li>新建<br>当程序使用new创建一个线程后，该线程就处于新建状态，jvm分配内存并且初始化成员变量的值。  </li>\n<li>就绪<br>当线程对象调用了start()方法后，该线程处于就绪状态，Jvm会为其创建方法调用栈和程序计数器，等待系统的调度。  </li>\n<li>运行<br>当处于就绪状态的线程获得了CPU时间，就会开始执行run()方法，此时该线程处于运行状态。  </li>\n<li>阻塞<br>当处于运行状态的线程失去CPU资源后，进入阻塞状态。当阻塞的线程解除了阻塞状态，便会进入就绪状态，不能直接进入运行状态。  </li>\n<li>等待<br>进入该状态的线程需要等待其他线程的一些特定动作，比如通知或者中断。 </li>\n<li>超时等待<br>不同于等待，可以在指定时间之后结束。  </li>\n<li>死亡<br>线程方法执行完毕或者抛出一个未被捕获的异常以及直接调用该线程的stop()方法会结束线程，结束后线程就处于死亡状态。  </li>\n</ul>"},{"title":"单例模式","date":"2019-10-20T13:02:16.000Z","comments":1,"toc":true,"_content":"\n对于某些类，可能在整个应用的生命周期中只应该存在一个实例，当这个唯一实例创建成功后，后续获取到的都应该是这个实例而不是重新创建。  \n    \n    Spring的bean默认就是单例模式  \n一般讲的单例是对Jvm来说的，而Spring的单例则是对bean容器来说，一个bean容器会存在一个唯一实例。  \n如果有多个bean容器则单例类也是可以存在多个实例的，Spring的单例模式使用的是单例注册表模式。    \n  \n  \n<!-- more -->  \n\n## 常见的单例模式   \n* 普通单例   \n* 懒汉（饱汉）单例    \n* 饿汉单例   \n* 懒汉双重检查锁定模式 \n* IoDH模式  \n* 单例注册表    \n----\n一般单例模式都会将构造函数设置为私有，然后提供一个供外界获取实例的方法，由此来避免产生多个实例。  \n\n### 普通单例    \n\n将构造函数属性设置为私有，暴露getInstance()方法供外界获取实例，当唯一实例为空时则调用构造函数初始化它。再次获取时则取得前一次生成的实例，  \n\n```java\npackage com.neoy.singleton;\n\npublic class SimpleSingleton {\n\n    private static SimpleSingleton ss = null;\n\n    private SimpleSingleton() {\n    }\n\n    public static SimpleSingleton getInstance(){\n        if (null == ss){\n            ss = new SimpleSingleton();\n        }\n        return ss;\n    }\n}\n\n```\n这种模式在多线程情况下会有问题，当线程A判断唯一实例为空去初始化时线程B来获取，此时初始化还没完成，线程B认为唯一实例为空也去初始化，最终又会创建一个实例。  \n为了解决这种情况，可以使用饿汉模式和懒汉（饱汉）模式来解决  \n### 饿汉模式    \n\n在定义静态变量的时候初始化该唯一实例，在类加载完成后就已经创建了该对象。  \n```java\npackage com.neoy.singleton;\n\npublic class HungrySingleton {\n    private static final HungrySingleton instance = new HungrySingleton();\n\n    public HungrySingleton() {\n    }\n\n    public static HungrySingleton getInstance(){\n        return instance;\n    }\n}\n\n```\n饿汉模式不能满足需要时创建这一需求，而懒汉模式则可以满足。  \n### 懒汉模式  \n  \n为了避免多线程获取唯一实例导致产生多个实例的情况，对前面普通单例的getInstance()加锁来避免多个线程同时调用。  \n```java\npublic class LazySingleton {\n    private static LazySingleton instance = null;\n\n    public LazySingleton() {\n\n    }\n\n    synchronized public static LazySingleton getInstance(){\n        if (null == instance){\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n\n```\n虽然解决了多线程访问创建多个对象的问题，但是每次获取实例都要进行线程锁判定，有可能会导致系统性能大大降低，可以考虑只对生成实例的那一句代码进行枷锁。 \n```java\npublic class LazySingleton {\n    private static LazySingleton instance = null;\n\n    public LazySingleton() {\n\n    }\n\n   public static LazySingleton getInstance(){\n        if (null == instance){\n        \tsynchronized(LazySingleton.class){\n        \t  instance = new LazySingleton();\n        \t}\n        }\n        return instance;\n    }\n}\n\n```\n#### 然鹅这种模式还会有问题  \n  \n当线程A和B都判断唯一实例为null时会争夺锁资源，假设线程A获取到了资源进行创建唯一实例，线程B进入等待。  \n当线程A创建完毕释放了锁资源后线程B得到了锁资源，然而线程B并不知道线程A已经创建了实例，此时线程B再进行创建实例则还是会出现多个实例的情况。    \n针对这种情况可以使用懒汉双重检查锁定模式，即在调用单例类的构造函数时再进行一次null判断  \n```java\npublic class DoubleCheckLazySingleton {\n    private volatile static DoubleCheckLazySingleton instance = null;\n\n    public DoubleCheckLazySingleton() {\n\n    }\n\n    synchronized public static DoubleCheckLazySingleton getInstance(){\n        if (null == instance){\n            synchronized(DoubleCheckLazySingleton.class){\n                if (null == instance){\n                    instance = new DoubleCheckLazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n双重检查锁定模式要对静态变量instance做修改，要添加volatile关键字来保证线程对该变量的修改对其他线程可见。  \n### IoDH模式    \n\n\t全称是Initialization Demand Holder  \n\t在单例类中增加一个静态内部类，由该类的静态变量持有单例类的唯一实例，单例类提供获取方法供外界使用。  \n```java\nclass Singleton {  \n    private Singleton() {  \n    }  \n\n    private static class HolderClass {  \n            private final static Singleton instance = new Singleton();  \n    }  \n\n    public static Singleton getInstance() {  \n        return HolderClass.instance;  \n    }  \n \n}\n\n```\n当Singleton类加载时不会实例化instance变量，当调用getInstance() 方法时，会加载内部类HolderClass并初始化instance变量，由虚拟机保证instance的初始化有且只有一次，而且getInstance() 方法没有任何锁定，不会对性能产生影响。  \n\n### 单例注册表模式  \n\n  维护一个Map用来保存单例对象，每次调用getInstance()方法的时候判断Map中是否存在，存在则返回该对象不存在则进行创建。Map使用ConcurrentHashMap则是为了线程安全考虑。  \n\n```java\npublic class SingletonReg {\n    private final static Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);\n\n    static {\n        SingletonReg singletonReg = new SingletonReg();\n        singletonObjects.put(singletonReg.getClass().getName(), singletonReg);\n    }\n\n    private SingletonReg() {}\n\n    public static SingletonReg getInstance(String name) {\n        if (name == null) {\n            name = \"com.neoy.singleton.SingletonReg\";\n        }\n        if (singletonObjects.get(name) == null) {\n            try {\n                singletonObjects.put(name, Class.forName(name).newInstance());\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n        return (SingletonReg) singletonObjects.get(name);\n    }\n}\n\n```  \nSpring中的AbstractBeanFactory类的doGetBean()方法中使用到的getSingleton()就是该种模式的实现。  \n```java\n    public Object getSingleton(String beanName, ObjectFactory singletonFactory) {\n        Assert.notNull(beanName, \"'beanName' must not be null\");\n        synchronized(this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                if (this.singletonsCurrentlyInDestruction) {\n                    throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)\");\n                }\n\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\");\n                }\n\n                this.beforeSingletonCreation(beanName);\n                boolean recordSuppressedExceptions = this.suppressedExceptions == null;\n                if (recordSuppressedExceptions) {\n                    this.suppressedExceptions = new LinkedHashSet();\n                }\n\n                try {\n                    singletonObject = singletonFactory.getObject();\n                } catch (BeanCreationException var14) {\n                    BeanCreationException ex = var14;\n                    if (recordSuppressedExceptions) {\n                        Iterator i$ = this.suppressedExceptions.iterator();\n\n                        while(i$.hasNext()) {\n                            Exception suppressedException = (Exception)i$.next();\n                            ex.addRelatedCause(suppressedException);\n                        }\n                    }\n\n                    throw ex;\n                } finally {\n                    if (recordSuppressedExceptions) {\n                        this.suppressedExceptions = null;\n                    }\n\n                    this.afterSingletonCreation(beanName);\n                }\n\n                this.addSingleton(beanName, singletonObject);\n            }\n\n            return singletonObject != NULL_OBJECT ? singletonObject : null;\n        }\n    }\n\n```  ","source":"_posts/设计模式/单例模式.md","raw":"---\ntitle: 单例模式\ndate: 2019-10-20 21:02:16\ncomments: true\ncategories: \n  - 笔记\ntags: \n  - java\ntoc: true\n---\n\n对于某些类，可能在整个应用的生命周期中只应该存在一个实例，当这个唯一实例创建成功后，后续获取到的都应该是这个实例而不是重新创建。  \n    \n    Spring的bean默认就是单例模式  \n一般讲的单例是对Jvm来说的，而Spring的单例则是对bean容器来说，一个bean容器会存在一个唯一实例。  \n如果有多个bean容器则单例类也是可以存在多个实例的，Spring的单例模式使用的是单例注册表模式。    \n  \n  \n<!-- more -->  \n\n## 常见的单例模式   \n* 普通单例   \n* 懒汉（饱汉）单例    \n* 饿汉单例   \n* 懒汉双重检查锁定模式 \n* IoDH模式  \n* 单例注册表    \n----\n一般单例模式都会将构造函数设置为私有，然后提供一个供外界获取实例的方法，由此来避免产生多个实例。  \n\n### 普通单例    \n\n将构造函数属性设置为私有，暴露getInstance()方法供外界获取实例，当唯一实例为空时则调用构造函数初始化它。再次获取时则取得前一次生成的实例，  \n\n```java\npackage com.neoy.singleton;\n\npublic class SimpleSingleton {\n\n    private static SimpleSingleton ss = null;\n\n    private SimpleSingleton() {\n    }\n\n    public static SimpleSingleton getInstance(){\n        if (null == ss){\n            ss = new SimpleSingleton();\n        }\n        return ss;\n    }\n}\n\n```\n这种模式在多线程情况下会有问题，当线程A判断唯一实例为空去初始化时线程B来获取，此时初始化还没完成，线程B认为唯一实例为空也去初始化，最终又会创建一个实例。  \n为了解决这种情况，可以使用饿汉模式和懒汉（饱汉）模式来解决  \n### 饿汉模式    \n\n在定义静态变量的时候初始化该唯一实例，在类加载完成后就已经创建了该对象。  \n```java\npackage com.neoy.singleton;\n\npublic class HungrySingleton {\n    private static final HungrySingleton instance = new HungrySingleton();\n\n    public HungrySingleton() {\n    }\n\n    public static HungrySingleton getInstance(){\n        return instance;\n    }\n}\n\n```\n饿汉模式不能满足需要时创建这一需求，而懒汉模式则可以满足。  \n### 懒汉模式  \n  \n为了避免多线程获取唯一实例导致产生多个实例的情况，对前面普通单例的getInstance()加锁来避免多个线程同时调用。  \n```java\npublic class LazySingleton {\n    private static LazySingleton instance = null;\n\n    public LazySingleton() {\n\n    }\n\n    synchronized public static LazySingleton getInstance(){\n        if (null == instance){\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n\n```\n虽然解决了多线程访问创建多个对象的问题，但是每次获取实例都要进行线程锁判定，有可能会导致系统性能大大降低，可以考虑只对生成实例的那一句代码进行枷锁。 \n```java\npublic class LazySingleton {\n    private static LazySingleton instance = null;\n\n    public LazySingleton() {\n\n    }\n\n   public static LazySingleton getInstance(){\n        if (null == instance){\n        \tsynchronized(LazySingleton.class){\n        \t  instance = new LazySingleton();\n        \t}\n        }\n        return instance;\n    }\n}\n\n```\n#### 然鹅这种模式还会有问题  \n  \n当线程A和B都判断唯一实例为null时会争夺锁资源，假设线程A获取到了资源进行创建唯一实例，线程B进入等待。  \n当线程A创建完毕释放了锁资源后线程B得到了锁资源，然而线程B并不知道线程A已经创建了实例，此时线程B再进行创建实例则还是会出现多个实例的情况。    \n针对这种情况可以使用懒汉双重检查锁定模式，即在调用单例类的构造函数时再进行一次null判断  \n```java\npublic class DoubleCheckLazySingleton {\n    private volatile static DoubleCheckLazySingleton instance = null;\n\n    public DoubleCheckLazySingleton() {\n\n    }\n\n    synchronized public static DoubleCheckLazySingleton getInstance(){\n        if (null == instance){\n            synchronized(DoubleCheckLazySingleton.class){\n                if (null == instance){\n                    instance = new DoubleCheckLazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n双重检查锁定模式要对静态变量instance做修改，要添加volatile关键字来保证线程对该变量的修改对其他线程可见。  \n### IoDH模式    \n\n\t全称是Initialization Demand Holder  \n\t在单例类中增加一个静态内部类，由该类的静态变量持有单例类的唯一实例，单例类提供获取方法供外界使用。  \n```java\nclass Singleton {  \n    private Singleton() {  \n    }  \n\n    private static class HolderClass {  \n            private final static Singleton instance = new Singleton();  \n    }  \n\n    public static Singleton getInstance() {  \n        return HolderClass.instance;  \n    }  \n \n}\n\n```\n当Singleton类加载时不会实例化instance变量，当调用getInstance() 方法时，会加载内部类HolderClass并初始化instance变量，由虚拟机保证instance的初始化有且只有一次，而且getInstance() 方法没有任何锁定，不会对性能产生影响。  \n\n### 单例注册表模式  \n\n  维护一个Map用来保存单例对象，每次调用getInstance()方法的时候判断Map中是否存在，存在则返回该对象不存在则进行创建。Map使用ConcurrentHashMap则是为了线程安全考虑。  \n\n```java\npublic class SingletonReg {\n    private final static Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);\n\n    static {\n        SingletonReg singletonReg = new SingletonReg();\n        singletonObjects.put(singletonReg.getClass().getName(), singletonReg);\n    }\n\n    private SingletonReg() {}\n\n    public static SingletonReg getInstance(String name) {\n        if (name == null) {\n            name = \"com.neoy.singleton.SingletonReg\";\n        }\n        if (singletonObjects.get(name) == null) {\n            try {\n                singletonObjects.put(name, Class.forName(name).newInstance());\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n        return (SingletonReg) singletonObjects.get(name);\n    }\n}\n\n```  \nSpring中的AbstractBeanFactory类的doGetBean()方法中使用到的getSingleton()就是该种模式的实现。  \n```java\n    public Object getSingleton(String beanName, ObjectFactory singletonFactory) {\n        Assert.notNull(beanName, \"'beanName' must not be null\");\n        synchronized(this.singletonObjects) {\n            Object singletonObject = this.singletonObjects.get(beanName);\n            if (singletonObject == null) {\n                if (this.singletonsCurrentlyInDestruction) {\n                    throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)\");\n                }\n\n                if (this.logger.isDebugEnabled()) {\n                    this.logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\");\n                }\n\n                this.beforeSingletonCreation(beanName);\n                boolean recordSuppressedExceptions = this.suppressedExceptions == null;\n                if (recordSuppressedExceptions) {\n                    this.suppressedExceptions = new LinkedHashSet();\n                }\n\n                try {\n                    singletonObject = singletonFactory.getObject();\n                } catch (BeanCreationException var14) {\n                    BeanCreationException ex = var14;\n                    if (recordSuppressedExceptions) {\n                        Iterator i$ = this.suppressedExceptions.iterator();\n\n                        while(i$.hasNext()) {\n                            Exception suppressedException = (Exception)i$.next();\n                            ex.addRelatedCause(suppressedException);\n                        }\n                    }\n\n                    throw ex;\n                } finally {\n                    if (recordSuppressedExceptions) {\n                        this.suppressedExceptions = null;\n                    }\n\n                    this.afterSingletonCreation(beanName);\n                }\n\n                this.addSingleton(beanName, singletonObject);\n            }\n\n            return singletonObject != NULL_OBJECT ? singletonObject : null;\n        }\n    }\n\n```  ","slug":"设计模式/单例模式","published":1,"updated":"2020-01-29T13:26:27.536Z","_id":"ck5ibb8vo0019d4rmd2upyad6","layout":"post","photos":[],"link":"","content":"<p>对于某些类，可能在整个应用的生命周期中只应该存在一个实例，当这个唯一实例创建成功后，后续获取到的都应该是这个实例而不是重新创建。  </p>\n<pre><code>Spring的bean默认就是单例模式  \n</code></pre><p>一般讲的单例是对Jvm来说的，而Spring的单例则是对bean容器来说，一个bean容器会存在一个唯一实例。<br>如果有多个bean容器则单例类也是可以存在多个实例的，Spring的单例模式使用的是单例注册表模式。    </p>\n<a id=\"more\"></a>  \n<h2 id=\"常见的单例模式\"><a href=\"#常见的单例模式\" class=\"headerlink\" title=\"常见的单例模式\"></a>常见的单例模式</h2><ul>\n<li>普通单例   </li>\n<li>懒汉（饱汉）单例    </li>\n<li>饿汉单例   </li>\n<li>懒汉双重检查锁定模式 </li>\n<li>IoDH模式  </li>\n<li>单例注册表    </li>\n</ul>\n<hr>\n<p>一般单例模式都会将构造函数设置为私有，然后提供一个供外界获取实例的方法，由此来避免产生多个实例。  </p>\n<h3 id=\"普通单例\"><a href=\"#普通单例\" class=\"headerlink\" title=\"普通单例\"></a>普通单例</h3><p>将构造函数属性设置为私有，暴露getInstance()方法供外界获取实例，当唯一实例为空时则调用构造函数初始化它。再次获取时则取得前一次生成的实例，  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.neoy.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleSingleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SimpleSingleton ss = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SimpleSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SimpleSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == ss)&#123;</span><br><span class=\"line\">            ss = <span class=\"keyword\">new</span> SimpleSingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ss;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种模式在多线程情况下会有问题，当线程A判断唯一实例为空去初始化时线程B来获取，此时初始化还没完成，线程B认为唯一实例为空也去初始化，最终又会创建一个实例。<br>为了解决这种情况，可以使用饿汉模式和懒汉（饱汉）模式来解决  </p>\n<h3 id=\"饿汉模式\"><a href=\"#饿汉模式\" class=\"headerlink\" title=\"饿汉模式\"></a>饿汉模式</h3><p>在定义静态变量的时候初始化该唯一实例，在类加载完成后就已经创建了该对象。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.neoy.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>饿汉模式不能满足需要时创建这一需求，而懒汉模式则可以满足。  </p>\n<h3 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h3><p>为了避免多线程获取唯一实例导致产生多个实例的情况，对前面普通单例的getInstance()加锁来避免多个线程同时调用。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然解决了多线程访问创建多个对象的问题，但是每次获取实例都要进行线程锁判定，有可能会导致系统性能大大降低，可以考虑只对生成实例的那一句代码进行枷锁。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">synchronized</span>(LazySingleton.class)&#123;</span><br><span class=\"line\">        \t  instance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"然鹅这种模式还会有问题\"><a href=\"#然鹅这种模式还会有问题\" class=\"headerlink\" title=\"然鹅这种模式还会有问题\"></a>然鹅这种模式还会有问题</h4><p>当线程A和B都判断唯一实例为null时会争夺锁资源，假设线程A获取到了资源进行创建唯一实例，线程B进入等待。<br>当线程A创建完毕释放了锁资源后线程B得到了锁资源，然而线程B并不知道线程A已经创建了实例，此时线程B再进行创建实例则还是会出现多个实例的情况。<br>针对这种情况可以使用懒汉双重检查锁定模式，即在调用单例类的构造函数时再进行一次null判断<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleCheckLazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DoubleCheckLazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DoubleCheckLazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DoubleCheckLazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(DoubleCheckLazySingleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> DoubleCheckLazySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>双重检查锁定模式要对静态变量instance做修改，要添加volatile关键字来保证线程对该变量的修改对其他线程可见。  </p>\n<h3 id=\"IoDH模式\"><a href=\"#IoDH模式\" class=\"headerlink\" title=\"IoDH模式\"></a>IoDH模式</h3><pre><code>全称是Initialization Demand Holder  \n在单例类中增加一个静态内部类，由该类的静态变量持有单例类的唯一实例，单例类提供获取方法供外界使用。  \n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HolderClass.instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当Singleton类加载时不会实例化instance变量，当调用getInstance() 方法时，会加载内部类HolderClass并初始化instance变量，由虚拟机保证instance的初始化有且只有一次，而且getInstance() 方法没有任何锁定，不会对性能产生影响。  </p>\n<h3 id=\"单例注册表模式\"><a href=\"#单例注册表模式\" class=\"headerlink\" title=\"单例注册表模式\"></a>单例注册表模式</h3><p>  维护一个Map用来保存单例对象，每次调用getInstance()方法的时候判断Map中是否存在，存在则返回该对象不存在则进行创建。Map使用ConcurrentHashMap则是为了线程安全考虑。  </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonReg</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">64</span>);\n\n    <span class=\"keyword\">static</span> {\n        SingletonReg singletonReg = <span class=\"keyword\">new</span> SingletonReg();\n        singletonObjects.put(singletonReg.getClass().getName(), singletonReg);\n    }\n\n    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonReg</span><span class=\"params\">()</span> </span>{}\n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonReg <span class=\"title\">getInstance</span><span class=\"params\">(String name)</span> </span>{\n        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) {\n            name = <span class=\"string\">\"com.neoy.singleton.SingletonReg\"</span>;\n        }\n        <span class=\"keyword\">if</span> (singletonObjects.get(name) == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">try</span> {\n                singletonObjects.put(name, Class.forName(name).newInstance());\n            } <span class=\"keyword\">catch</span> (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n        <span class=\"keyword\">return</span> (SingletonReg) singletonObjects.get(name);\n    }\n}\n\n</code></pre>\n<p>Spring中的AbstractBeanFactory类的doGetBean()方法中使用到的getSingleton()就是该种模式的实现。  </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, ObjectFactory singletonFactory)</span> </span>{\n    Assert.notNull(beanName, <span class=\"string\">\"'beanName' must not be null\"</span>);\n    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.singletonObjects) {\n        Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);\n        <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.singletonsCurrentlyInDestruction) {\n                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanCreationNotAllowedException(beanName, <span class=\"string\">\"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)\"</span>);\n            }\n\n            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isDebugEnabled()) {\n                <span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Creating shared instance of singleton bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);\n            }\n\n            <span class=\"keyword\">this</span>.beforeSingletonCreation(beanName);\n            <span class=\"keyword\">boolean</span> recordSuppressedExceptions = <span class=\"keyword\">this</span>.suppressedExceptions == <span class=\"keyword\">null</span>;\n            <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                <span class=\"keyword\">this</span>.suppressedExceptions = <span class=\"keyword\">new</span> LinkedHashSet();\n            }\n\n            <span class=\"keyword\">try</span> {\n                singletonObject = singletonFactory.getObject();\n            } <span class=\"keyword\">catch</span> (BeanCreationException var14) {\n                BeanCreationException ex = var14;\n                <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                    Iterator i$ = <span class=\"keyword\">this</span>.suppressedExceptions.iterator();\n\n                    <span class=\"keyword\">while</span>(i$.hasNext()) {\n                        Exception suppressedException = (Exception)i$.next();\n                        ex.addRelatedCause(suppressedException);\n                    }\n                }\n\n                <span class=\"keyword\">throw</span> ex;\n            } <span class=\"keyword\">finally</span> {\n                <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                    <span class=\"keyword\">this</span>.suppressedExceptions = <span class=\"keyword\">null</span>;\n                }\n\n                <span class=\"keyword\">this</span>.afterSingletonCreation(beanName);\n            }\n\n            <span class=\"keyword\">this</span>.addSingleton(beanName, singletonObject);\n        }\n\n        <span class=\"keyword\">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>;\n    }\n}\n\n</code></pre>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>对于某些类，可能在整个应用的生命周期中只应该存在一个实例，当这个唯一实例创建成功后，后续获取到的都应该是这个实例而不是重新创建。  </p>\n<pre><code>Spring的bean默认就是单例模式  \n</code></pre><p>一般讲的单例是对Jvm来说的，而Spring的单例则是对bean容器来说，一个bean容器会存在一个唯一实例。<br>如果有多个bean容器则单例类也是可以存在多个实例的，Spring的单例模式使用的是单例注册表模式。    </p>","more":"<h2 id=\"常见的单例模式\"><a href=\"#常见的单例模式\" class=\"headerlink\" title=\"常见的单例模式\"></a>常见的单例模式</h2><ul>\n<li>普通单例   </li>\n<li>懒汉（饱汉）单例    </li>\n<li>饿汉单例   </li>\n<li>懒汉双重检查锁定模式 </li>\n<li>IoDH模式  </li>\n<li>单例注册表    </li>\n</ul>\n<hr>\n<p>一般单例模式都会将构造函数设置为私有，然后提供一个供外界获取实例的方法，由此来避免产生多个实例。  </p>\n<h3 id=\"普通单例\"><a href=\"#普通单例\" class=\"headerlink\" title=\"普通单例\"></a>普通单例</h3><p>将构造函数属性设置为私有，暴露getInstance()方法供外界获取实例，当唯一实例为空时则调用构造函数初始化它。再次获取时则取得前一次生成的实例，  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.neoy.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleSingleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SimpleSingleton ss = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SimpleSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SimpleSingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == ss)&#123;</span><br><span class=\"line\">            ss = <span class=\"keyword\">new</span> SimpleSingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ss;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种模式在多线程情况下会有问题，当线程A判断唯一实例为空去初始化时线程B来获取，此时初始化还没完成，线程B认为唯一实例为空也去初始化，最终又会创建一个实例。<br>为了解决这种情况，可以使用饿汉模式和懒汉（饱汉）模式来解决  </p>\n<h3 id=\"饿汉模式\"><a href=\"#饿汉模式\" class=\"headerlink\" title=\"饿汉模式\"></a>饿汉模式</h3><p>在定义静态变量的时候初始化该唯一实例，在类加载完成后就已经创建了该对象。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.neoy.singleton;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HungrySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HungrySingleton instance = <span class=\"keyword\">new</span> HungrySingleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HungrySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HungrySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>饿汉模式不能满足需要时创建这一需求，而懒汉模式则可以满足。  </p>\n<h3 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h3><p>为了避免多线程获取唯一实例导致产生多个实例的情况，对前面普通单例的getInstance()加锁来避免多个线程同时调用。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然解决了多线程访问创建多个对象的问题，但是每次获取实例都要进行线程锁判定，有可能会导致系统性能大大降低，可以考虑只对生成实例的那一句代码进行枷锁。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">synchronized</span>(LazySingleton.class)&#123;</span><br><span class=\"line\">        \t  instance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">        \t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"然鹅这种模式还会有问题\"><a href=\"#然鹅这种模式还会有问题\" class=\"headerlink\" title=\"然鹅这种模式还会有问题\"></a>然鹅这种模式还会有问题</h4><p>当线程A和B都判断唯一实例为null时会争夺锁资源，假设线程A获取到了资源进行创建唯一实例，线程B进入等待。<br>当线程A创建完毕释放了锁资源后线程B得到了锁资源，然而线程B并不知道线程A已经创建了实例，此时线程B再进行创建实例则还是会出现多个实例的情况。<br>针对这种情况可以使用懒汉双重检查锁定模式，即在调用单例类的构造函数时再进行一次null判断<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DoubleCheckLazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> DoubleCheckLazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DoubleCheckLazySingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> DoubleCheckLazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(DoubleCheckLazySingleton.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance)&#123;</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> DoubleCheckLazySingleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>双重检查锁定模式要对静态变量instance做修改，要添加volatile关键字来保证线程对该变量的修改对其他线程可见。  </p>\n<h3 id=\"IoDH模式\"><a href=\"#IoDH模式\" class=\"headerlink\" title=\"IoDH模式\"></a>IoDH模式</h3><pre><code>全称是Initialization Demand Holder  \n在单例类中增加一个静态内部类，由该类的静态变量持有单例类的唯一实例，单例类提供获取方法供外界使用。  \n</code></pre><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> HolderClass.instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当Singleton类加载时不会实例化instance变量，当调用getInstance() 方法时，会加载内部类HolderClass并初始化instance变量，由虚拟机保证instance的初始化有且只有一次，而且getInstance() 方法没有任何锁定，不会对性能产生影响。  </p>\n<h3 id=\"单例注册表模式\"><a href=\"#单例注册表模式\" class=\"headerlink\" title=\"单例注册表模式\"></a>单例注册表模式</h3><p>  维护一个Map用来保存单例对象，每次调用getInstance()方法的时候判断Map中是否存在，存在则返回该对象不存在则进行创建。Map使用ConcurrentHashMap则是为了线程安全考虑。  </p>\n<pre><code class=\"java\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonReg</span> </span>{\n    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Map&lt;String, Object&gt; singletonObjects = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class=\"number\">64</span>);\n\n    <span class=\"keyword\">static</span> {\n        SingletonReg singletonReg = <span class=\"keyword\">new</span> SingletonReg();\n        singletonObjects.put(singletonReg.getClass().getName(), singletonReg);\n    }\n\n    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SingletonReg</span><span class=\"params\">()</span> </span>{}\n\n    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonReg <span class=\"title\">getInstance</span><span class=\"params\">(String name)</span> </span>{\n        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) {\n            name = <span class=\"string\">\"com.neoy.singleton.SingletonReg\"</span>;\n        }\n        <span class=\"keyword\">if</span> (singletonObjects.get(name) == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">try</span> {\n                singletonObjects.put(name, Class.forName(name).newInstance());\n            } <span class=\"keyword\">catch</span> (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n        <span class=\"keyword\">return</span> (SingletonReg) singletonObjects.get(name);\n    }\n}\n\n</code></pre>\n<p>Spring中的AbstractBeanFactory类的doGetBean()方法中使用到的getSingleton()就是该种模式的实现。  </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getSingleton</span><span class=\"params\">(String beanName, ObjectFactory singletonFactory)</span> </span>{\n    Assert.notNull(beanName, <span class=\"string\">\"'beanName' must not be null\"</span>);\n    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>.singletonObjects) {\n        Object singletonObject = <span class=\"keyword\">this</span>.singletonObjects.get(beanName);\n        <span class=\"keyword\">if</span> (singletonObject == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.singletonsCurrentlyInDestruction) {\n                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BeanCreationNotAllowedException(beanName, <span class=\"string\">\"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)\"</span>);\n            }\n\n            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isDebugEnabled()) {\n                <span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Creating shared instance of singleton bean '\"</span> + beanName + <span class=\"string\">\"'\"</span>);\n            }\n\n            <span class=\"keyword\">this</span>.beforeSingletonCreation(beanName);\n            <span class=\"keyword\">boolean</span> recordSuppressedExceptions = <span class=\"keyword\">this</span>.suppressedExceptions == <span class=\"keyword\">null</span>;\n            <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                <span class=\"keyword\">this</span>.suppressedExceptions = <span class=\"keyword\">new</span> LinkedHashSet();\n            }\n\n            <span class=\"keyword\">try</span> {\n                singletonObject = singletonFactory.getObject();\n            } <span class=\"keyword\">catch</span> (BeanCreationException var14) {\n                BeanCreationException ex = var14;\n                <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                    Iterator i$ = <span class=\"keyword\">this</span>.suppressedExceptions.iterator();\n\n                    <span class=\"keyword\">while</span>(i$.hasNext()) {\n                        Exception suppressedException = (Exception)i$.next();\n                        ex.addRelatedCause(suppressedException);\n                    }\n                }\n\n                <span class=\"keyword\">throw</span> ex;\n            } <span class=\"keyword\">finally</span> {\n                <span class=\"keyword\">if</span> (recordSuppressedExceptions) {\n                    <span class=\"keyword\">this</span>.suppressedExceptions = <span class=\"keyword\">null</span>;\n                }\n\n                <span class=\"keyword\">this</span>.afterSingletonCreation(beanName);\n            }\n\n            <span class=\"keyword\">this</span>.addSingleton(beanName, singletonObject);\n        }\n\n        <span class=\"keyword\">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class=\"keyword\">null</span>;\n    }\n}\n\n</code></pre>"},{"title":"记一次排查生产Mina框架BufferUnderflowException异常","date":"2019-10-11T07:10:16.000Z","comments":1,"toc":true,"_content":"生产环境上有个项目，跟上游系统交互通过Socket使用XML报文，代码中使用Mina作为客户端进行连接。  \n在传输编码成字符串的Photo节点时，特定的用户数据接收时出现BufferUnderflowException异常导致交易无法继续。  \n而在测试环境使用图片更大的数据却没有复现该异常，记录排查过程和错误猜测思路。  \n<!-- more -->    \n\n## 报错场景和异常内容  \n使用Mina作为客户端与上游系统交互，返回报文格式如下图  \n![](/images/imageForPost/socket/Mina/报文格式.png)  \n特定两位用户的数据返回时出现如下异常    \n![](/images/imageForPost/socket/Mina/MinaException1.png)      \n![](/images/imageForPost/socket/Mina/MinaException2.jpg)  \n   \n## 处理方法  \n面向搜索引擎编程，第一反应自然是进行如下操作  \n![](/images/imageForPost/socket/Mina/面向谷歌编程.png)  \n大多数网友的处理方法是手动增大接收缓冲区到报文大小.  \n在报错日志中确实是有看到ioBuffer进行自动扩大，因为逻辑中没有指定大小，使用的是默认大小.  \nMina会根据当前包大小来判断调整缓冲区大小，可能扩大也可能缩小，当缩小时来了个大包就会导致异常。  \n生产日终中从2048扩大到4096然后出现了异常 \n![](/images/imageForPost/socket/Mina/iobuffer扩大.JPG)   \n于是在创建Mina Client时指定读缓冲区大小，以业务报文为基准设置个合理的值，单次交互不会存在粘包的问题于是可以设置成大与等于业务报文大小。  \n  \n\n```java\n        connector.getSessionConfig().setReceiveBufferSize(2048*50);\n        connector.getSessionConfig().setReadBufferSize(2048*50);\n\n```\nconnector为NioSocketConnector，在创建完处理链之后指定了读取缓冲区和接收缓冲区大小。  \n喜闻乐见，报文正常接收了。  \n\n## 导致生产问题的原因\n### 接收缓冲区自动缩小 \n翻到一篇场景一样的文章  \n[mina read方法出现BufferUnderflowException异常的解决办法](https://my.oschina.net/javagg/blog/2)  \nMina会根据接收到的包大小自动调整缓冲区的大小，在接收TCP包的过程中，前面都是小包，Mina会判断，如果当前包的大小的平方倍小与byteBuf的大小的话，会把缓冲区减半。  \n此时来了一个大包，超过了缓冲区大小，get获取就出错了。  \n具体可以看*AbstractPollingIoProcessor类的read(T session)*  \n\n```java\nprivate void read(T session) {\n        IoSessionConfig config = session.getConfig();\n\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();  //1、buffer减小\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize(); //2、buffer加大\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n  \n\npublic final void decreaseReadBufferSize() {\n        if (this.deferDecreaseReadBuffer) {\n            this.deferDecreaseReadBuffer = false;\n        } else {\n            if (this.getConfig().getReadBufferSize() > this.getConfig().getMinReadBufferSize()) {\n                this.getConfig().setReadBufferSize(this.getConfig().getReadBufferSize() >>> 1);\n            }\n\n            this.deferDecreaseReadBuffer = true;\n        }\n    }\n\n\n```\n\n注释1中是缓冲区减小的情况，即判断当前包的平方倍是不是比当前分配的缓冲区小，小的话调用decreaseReadBufferSize()减小缓冲区。  \n   \n\n当缓冲区减小后，发送端发来一个大于缓冲区大小的包，就会导致BufferUnderflowException异常  \n\n## 顺便发现的问题   \n### 解码器中长度判断有误    \n因为是短连接，所以不存在粘包的问题，异常抛错的栈顶方法是ioBuffer的get方法  \n\n出现java.nio.BufferUnderflowException的情况为读取长度超过缓冲区可用长度  \n  \n--------  \n\n关注下解码器中的读取逻辑，然后发现解码器中的长度判断逻辑有点小问题。  \n在非常极端的情况下会出现BufferUnderflowException异常，不过这不是导致当前生产问题的原因。  \n先来关注下这个长度判断导致的问题。   \n#### ProtocolDecoder代码 \n继承了CumulativeProtocolDecoder，CumulativeProtocolDecoder是一种积累型的解码器，只要channel中有数据进来就会读取数据积累到ioBuffer缓冲区中，子类通过实现doDecode方法进行拆包，doDecode只要有数据进来就会被调用。    \n\n**doDecode方法**   \n  \n\n```java  \n        private static final int fieldLen = 8;\n        protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {\n             if (in.remaining() > 0) { // 如果有数据，先读取Head中的8字节长度来获取总报文长度\n                 byte[] sizeBytes = new byte[fieldLen];\n                 in.mark(); //1、标记ioBuffer最开头的位置\n                 in.get(sizeBytes);\n                 String len = new String(sizeBytes, charset);\n                 int packageSize = Integer.valueOf(len);\n                 in.reset();// 2、重置到标志位置\n                 if (in.remaining() < packageSize) { //3、判断剩余数据长度是不是跟报文体一样长\n                     return false;\n                 } else {\n     \n                     byte[] content = new byte[packageSize];\n                     in.skip(fieldLen); //4、跳过表示报文头长度的数据\n                     in.get(content);  //5、读取报文体\n                     String xmlContent = new String(content, charset);\n                     EgsLog.getEgsChannelLogNoCache().debug(\"解包后的核心接口返回字符串(编码字符集\" + charset + \")：\" + xmlContent);\n                     out.write(xmlContent);\n     \n                 }\n                 if (in.remaining() > 0) { // 如果内容后面还粘了包 单次交互不管\n                     return true;\n                 }\n                 return true;\n             } else {\n                 return false; \n             }\n         }\n\n```\n### 出现由于长度判断导致问题的场景  \n在很极端的情况下，假设报文头长度8字节，报文体长度22字节。  \n最开始使用默认大小的缓冲区，\n* 假设获取了一段10字节的包   \n* 步骤1获取了前面8字节知道了报文总长度22  \n* 步骤2将标志重置到起始位置，缓冲区满了，自动扩展到25字节大小  \n* 重新执行doDecode方法  \n* 步骤2，position重置到头部，因为报文头的长度不包括自身长度，步骤3判断缓冲区有25字节大于报文体22字节，开始读取。  \n* 步骤4跳过表示报文长度8字节，此时缓冲区剩余17字节  \n* 开始读取22字节的报文，超过缓冲区可读取长度，于是抛出BufferUnderflowException异常  \n\t\n这种情况也只在后面一段包还没接收到，在传输的途中，ioBuffer扩展大小之前进行读取的极端情况下出现。但是生产只要是这两个用户数据必定复现，所以不是这种情况导致的，不过也确实发现了一个隐藏问题。  \n既然意外发现了也应该修复。  \n### 修改逻辑  \n步骤3判断条件修改  \n\n\n```java\nif (in.remaining() < packageSize + fieldLen)\n```  \nCtrl C + Ctrl V多了也是有可能出事的。 \n\n  \n## 总结  \n对于单次交互的短连接，由于不存在粘包的情况，所以可以将客户端的接收缓冲区根据实际业务报文大小适当调大，可以大于等于业务最大报文，一般缓冲区设置较小为了减少开销，而实际业务的报文大小一般最多十几到几十kb。\n","source":"_posts/socket/记一次排查生产Mina框架BufferUnderflowException异常.md","raw":"---\ntitle: 记一次排查生产Mina框架BufferUnderflowException异常\ndate: 2019-10-11 15:10:16\ncomments: true\ncategories: \n  - 记录\ntags: \n  - java\ntoc: true\n---\n生产环境上有个项目，跟上游系统交互通过Socket使用XML报文，代码中使用Mina作为客户端进行连接。  \n在传输编码成字符串的Photo节点时，特定的用户数据接收时出现BufferUnderflowException异常导致交易无法继续。  \n而在测试环境使用图片更大的数据却没有复现该异常，记录排查过程和错误猜测思路。  \n<!-- more -->    \n\n## 报错场景和异常内容  \n使用Mina作为客户端与上游系统交互，返回报文格式如下图  \n![](/images/imageForPost/socket/Mina/报文格式.png)  \n特定两位用户的数据返回时出现如下异常    \n![](/images/imageForPost/socket/Mina/MinaException1.png)      \n![](/images/imageForPost/socket/Mina/MinaException2.jpg)  \n   \n## 处理方法  \n面向搜索引擎编程，第一反应自然是进行如下操作  \n![](/images/imageForPost/socket/Mina/面向谷歌编程.png)  \n大多数网友的处理方法是手动增大接收缓冲区到报文大小.  \n在报错日志中确实是有看到ioBuffer进行自动扩大，因为逻辑中没有指定大小，使用的是默认大小.  \nMina会根据当前包大小来判断调整缓冲区大小，可能扩大也可能缩小，当缩小时来了个大包就会导致异常。  \n生产日终中从2048扩大到4096然后出现了异常 \n![](/images/imageForPost/socket/Mina/iobuffer扩大.JPG)   \n于是在创建Mina Client时指定读缓冲区大小，以业务报文为基准设置个合理的值，单次交互不会存在粘包的问题于是可以设置成大与等于业务报文大小。  \n  \n\n```java\n        connector.getSessionConfig().setReceiveBufferSize(2048*50);\n        connector.getSessionConfig().setReadBufferSize(2048*50);\n\n```\nconnector为NioSocketConnector，在创建完处理链之后指定了读取缓冲区和接收缓冲区大小。  \n喜闻乐见，报文正常接收了。  \n\n## 导致生产问题的原因\n### 接收缓冲区自动缩小 \n翻到一篇场景一样的文章  \n[mina read方法出现BufferUnderflowException异常的解决办法](https://my.oschina.net/javagg/blog/2)  \nMina会根据接收到的包大小自动调整缓冲区的大小，在接收TCP包的过程中，前面都是小包，Mina会判断，如果当前包的大小的平方倍小与byteBuf的大小的话，会把缓冲区减半。  \n此时来了一个大包，超过了缓冲区大小，get获取就出错了。  \n具体可以看*AbstractPollingIoProcessor类的read(T session)*  \n\n```java\nprivate void read(T session) {\n        IoSessionConfig config = session.getConfig();\n\n        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());\n\n        final boolean hasFragmentation =\n            session.getTransportMetadata().hasFragmentation();\n\n        try {\n            int readBytes = 0;\n            int ret;\n\n            try {\n                if (hasFragmentation) {\n                    while ((ret = read(session, buf)) > 0) {\n                        readBytes += ret;\n                        if (!buf.hasRemaining()) {\n                            break;\n                        }\n                    }\n                } else {\n                    ret = read(session, buf);\n                    if (ret > 0) {\n                        readBytes = ret;\n                    }\n                }\n            } finally {\n                buf.flip();\n            }\n\n            if (readBytes > 0) {\n                session.getFilterChain().fireMessageReceived(buf);\n                buf = null;\n\n                if (hasFragmentation) {\n                    if (readBytes << 1 < config.getReadBufferSize()) {\n                        session.decreaseReadBufferSize();  //1、buffer减小\n                    } else if (readBytes == config.getReadBufferSize()) {\n                        session.increaseReadBufferSize(); //2、buffer加大\n                    }\n                }\n            }\n            if (ret < 0) {\n                scheduleRemove(session);\n            }\n        } catch (Throwable e) {\n            if (e instanceof IOException) {\n                scheduleRemove(session);\n            }\n            session.getFilterChain().fireExceptionCaught(e);\n        }\n    }\n  \n\npublic final void decreaseReadBufferSize() {\n        if (this.deferDecreaseReadBuffer) {\n            this.deferDecreaseReadBuffer = false;\n        } else {\n            if (this.getConfig().getReadBufferSize() > this.getConfig().getMinReadBufferSize()) {\n                this.getConfig().setReadBufferSize(this.getConfig().getReadBufferSize() >>> 1);\n            }\n\n            this.deferDecreaseReadBuffer = true;\n        }\n    }\n\n\n```\n\n注释1中是缓冲区减小的情况，即判断当前包的平方倍是不是比当前分配的缓冲区小，小的话调用decreaseReadBufferSize()减小缓冲区。  \n   \n\n当缓冲区减小后，发送端发来一个大于缓冲区大小的包，就会导致BufferUnderflowException异常  \n\n## 顺便发现的问题   \n### 解码器中长度判断有误    \n因为是短连接，所以不存在粘包的问题，异常抛错的栈顶方法是ioBuffer的get方法  \n\n出现java.nio.BufferUnderflowException的情况为读取长度超过缓冲区可用长度  \n  \n--------  \n\n关注下解码器中的读取逻辑，然后发现解码器中的长度判断逻辑有点小问题。  \n在非常极端的情况下会出现BufferUnderflowException异常，不过这不是导致当前生产问题的原因。  \n先来关注下这个长度判断导致的问题。   \n#### ProtocolDecoder代码 \n继承了CumulativeProtocolDecoder，CumulativeProtocolDecoder是一种积累型的解码器，只要channel中有数据进来就会读取数据积累到ioBuffer缓冲区中，子类通过实现doDecode方法进行拆包，doDecode只要有数据进来就会被调用。    \n\n**doDecode方法**   \n  \n\n```java  \n        private static final int fieldLen = 8;\n        protected boolean doDecode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {\n             if (in.remaining() > 0) { // 如果有数据，先读取Head中的8字节长度来获取总报文长度\n                 byte[] sizeBytes = new byte[fieldLen];\n                 in.mark(); //1、标记ioBuffer最开头的位置\n                 in.get(sizeBytes);\n                 String len = new String(sizeBytes, charset);\n                 int packageSize = Integer.valueOf(len);\n                 in.reset();// 2、重置到标志位置\n                 if (in.remaining() < packageSize) { //3、判断剩余数据长度是不是跟报文体一样长\n                     return false;\n                 } else {\n     \n                     byte[] content = new byte[packageSize];\n                     in.skip(fieldLen); //4、跳过表示报文头长度的数据\n                     in.get(content);  //5、读取报文体\n                     String xmlContent = new String(content, charset);\n                     EgsLog.getEgsChannelLogNoCache().debug(\"解包后的核心接口返回字符串(编码字符集\" + charset + \")：\" + xmlContent);\n                     out.write(xmlContent);\n     \n                 }\n                 if (in.remaining() > 0) { // 如果内容后面还粘了包 单次交互不管\n                     return true;\n                 }\n                 return true;\n             } else {\n                 return false; \n             }\n         }\n\n```\n### 出现由于长度判断导致问题的场景  \n在很极端的情况下，假设报文头长度8字节，报文体长度22字节。  \n最开始使用默认大小的缓冲区，\n* 假设获取了一段10字节的包   \n* 步骤1获取了前面8字节知道了报文总长度22  \n* 步骤2将标志重置到起始位置，缓冲区满了，自动扩展到25字节大小  \n* 重新执行doDecode方法  \n* 步骤2，position重置到头部，因为报文头的长度不包括自身长度，步骤3判断缓冲区有25字节大于报文体22字节，开始读取。  \n* 步骤4跳过表示报文长度8字节，此时缓冲区剩余17字节  \n* 开始读取22字节的报文，超过缓冲区可读取长度，于是抛出BufferUnderflowException异常  \n\t\n这种情况也只在后面一段包还没接收到，在传输的途中，ioBuffer扩展大小之前进行读取的极端情况下出现。但是生产只要是这两个用户数据必定复现，所以不是这种情况导致的，不过也确实发现了一个隐藏问题。  \n既然意外发现了也应该修复。  \n### 修改逻辑  \n步骤3判断条件修改  \n\n\n```java\nif (in.remaining() < packageSize + fieldLen)\n```  \nCtrl C + Ctrl V多了也是有可能出事的。 \n\n  \n## 总结  \n对于单次交互的短连接，由于不存在粘包的情况，所以可以将客户端的接收缓冲区根据实际业务报文大小适当调大，可以大于等于业务最大报文，一般缓冲区设置较小为了减少开销，而实际业务的报文大小一般最多十几到几十kb。\n","slug":"socket/记一次排查生产Mina框架BufferUnderflowException异常","published":1,"updated":"2020-01-29T13:47:45.008Z","_id":"ck5ibb8vp001bd4rmteu47h7c","layout":"post","photos":[],"link":"","content":"<p>生产环境上有个项目，跟上游系统交互通过Socket使用XML报文，代码中使用Mina作为客户端进行连接。<br>在传输编码成字符串的Photo节点时，特定的用户数据接收时出现BufferUnderflowException异常导致交易无法继续。<br>而在测试环境使用图片更大的数据却没有复现该异常，记录排查过程和错误猜测思路。<br><a id=\"more\"></a>    </p>\n<h2 id=\"报错场景和异常内容\"><a href=\"#报错场景和异常内容\" class=\"headerlink\" title=\"报错场景和异常内容\"></a>报错场景和异常内容</h2><p>使用Mina作为客户端与上游系统交互，返回报文格式如下图<br><img src=\"/images/imageForPost/socket/Mina/报文格式.png\" alt><br>特定两位用户的数据返回时出现如下异常<br><img src=\"/images/imageForPost/socket/Mina/MinaException1.png\" alt><br><img src=\"/images/imageForPost/socket/Mina/MinaException2.jpg\" alt>  </p>\n<h2 id=\"处理方法\"><a href=\"#处理方法\" class=\"headerlink\" title=\"处理方法\"></a>处理方法</h2><p>面向搜索引擎编程，第一反应自然是进行如下操作<br><img src=\"/images/imageForPost/socket/Mina/面向谷歌编程.png\" alt><br>大多数网友的处理方法是手动增大接收缓冲区到报文大小.<br>在报错日志中确实是有看到ioBuffer进行自动扩大，因为逻辑中没有指定大小，使用的是默认大小.<br>Mina会根据当前包大小来判断调整缓冲区大小，可能扩大也可能缩小，当缩小时来了个大包就会导致异常。<br>生产日终中从2048扩大到4096然后出现了异常<br><img src=\"/images/imageForPost/socket/Mina/iobuffer扩大.JPG\" alt><br>于是在创建Mina Client时指定读缓冲区大小，以业务报文为基准设置个合理的值，单次交互不会存在粘包的问题于是可以设置成大与等于业务报文大小。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">connector.getSessionConfig().setReceiveBufferSize(<span class=\"number\">2048</span>*<span class=\"number\">50</span>);</span><br><span class=\"line\">connector.getSessionConfig().setReadBufferSize(<span class=\"number\">2048</span>*<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<p>connector为NioSocketConnector，在创建完处理链之后指定了读取缓冲区和接收缓冲区大小。<br>喜闻乐见，报文正常接收了。  </p>\n<h2 id=\"导致生产问题的原因\"><a href=\"#导致生产问题的原因\" class=\"headerlink\" title=\"导致生产问题的原因\"></a>导致生产问题的原因</h2><h3 id=\"接收缓冲区自动缩小\"><a href=\"#接收缓冲区自动缩小\" class=\"headerlink\" title=\"接收缓冲区自动缩小\"></a>接收缓冲区自动缩小</h3><p>翻到一篇场景一样的文章<br><a href=\"https://my.oschina.net/javagg/blog/2\" rel=\"noopener\" target=\"_blank\">mina read方法出现BufferUnderflowException异常的解决办法</a><br>Mina会根据接收到的包大小自动调整缓冲区的大小，在接收TCP包的过程中，前面都是小包，Mina会判断，如果当前包的大小的平方倍小与byteBuf的大小的话，会把缓冲区减半。<br>此时来了一个大包，超过了缓冲区大小，get获取就出错了。<br>具体可以看<em>AbstractPollingIoProcessor类的read(T session)</em>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(T session)</span> </span>&#123;</span><br><span class=\"line\">        IoSessionConfig config = session.getConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasFragmentation =</span><br><span class=\"line\">            session.getTransportMetadata().hasFragmentation();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> readBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasFragmentation) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((ret = read(session, buf)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        readBytes += ret;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!buf.hasRemaining()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = read(session, buf);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        readBytes = ret;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                buf.flip();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                session.getFilterChain().fireMessageReceived(buf);</span><br><span class=\"line\">                buf = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasFragmentation) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &lt;&lt; <span class=\"number\">1</span> &lt; config.getReadBufferSize()) &#123;</span><br><span class=\"line\">                        session.decreaseReadBufferSize();  <span class=\"comment\">//1、buffer减小</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes == config.getReadBufferSize()) &#123;</span><br><span class=\"line\">                        session.increaseReadBufferSize(); <span class=\"comment\">//2、buffer加大</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                scheduleRemove(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> IOException) &#123;</span><br><span class=\"line\">                scheduleRemove(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            session.getFilterChain().fireExceptionCaught(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">decreaseReadBufferSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deferDecreaseReadBuffer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deferDecreaseReadBuffer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getConfig().getReadBufferSize() &gt; <span class=\"keyword\">this</span>.getConfig().getMinReadBufferSize()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.getConfig().setReadBufferSize(<span class=\"keyword\">this</span>.getConfig().getReadBufferSize() &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deferDecreaseReadBuffer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注释1中是缓冲区减小的情况，即判断当前包的平方倍是不是比当前分配的缓冲区小，小的话调用decreaseReadBufferSize()减小缓冲区。  </p>\n<p>当缓冲区减小后，发送端发来一个大于缓冲区大小的包，就会导致BufferUnderflowException异常  </p>\n<h2 id=\"顺便发现的问题\"><a href=\"#顺便发现的问题\" class=\"headerlink\" title=\"顺便发现的问题\"></a>顺便发现的问题</h2><h3 id=\"解码器中长度判断有误\"><a href=\"#解码器中长度判断有误\" class=\"headerlink\" title=\"解码器中长度判断有误\"></a>解码器中长度判断有误</h3><p>因为是短连接，所以不存在粘包的问题，异常抛错的栈顶方法是ioBuffer的get方法  </p>\n<p>出现java.nio.BufferUnderflowException的情况为读取长度超过缓冲区可用长度  </p>\n<hr>\n<p>关注下解码器中的读取逻辑，然后发现解码器中的长度判断逻辑有点小问题。<br>在非常极端的情况下会出现BufferUnderflowException异常，不过这不是导致当前生产问题的原因。<br>先来关注下这个长度判断导致的问题。   </p>\n<h4 id=\"ProtocolDecoder代码\"><a href=\"#ProtocolDecoder代码\" class=\"headerlink\" title=\"ProtocolDecoder代码\"></a>ProtocolDecoder代码</h4><p>继承了CumulativeProtocolDecoder，CumulativeProtocolDecoder是一种积累型的解码器，只要channel中有数据进来就会读取数据积累到ioBuffer缓冲区中，子类通过实现doDecode方法进行拆包，doDecode只要有数据进来就会被调用。    </p>\n<p><strong>doDecode方法</strong>   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fieldLen = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">doDecode</span><span class=\"params\">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (in.remaining() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果有数据，先读取Head中的8字节长度来获取总报文长度</span></span><br><span class=\"line\">         <span class=\"keyword\">byte</span>[] sizeBytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[fieldLen];</span><br><span class=\"line\">         in.mark(); <span class=\"comment\">//1、标记ioBuffer最开头的位置</span></span><br><span class=\"line\">         in.get(sizeBytes);</span><br><span class=\"line\">         String len = <span class=\"keyword\">new</span> String(sizeBytes, charset);</span><br><span class=\"line\">         <span class=\"keyword\">int</span> packageSize = Integer.valueOf(len);</span><br><span class=\"line\">         in.reset();<span class=\"comment\">// 2、重置到标志位置</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (in.remaining() &lt; packageSize) &#123; <span class=\"comment\">//3、判断剩余数据长度是不是跟报文体一样长</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">             <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[packageSize];</span><br><span class=\"line\">             in.skip(fieldLen); <span class=\"comment\">//4、跳过表示报文头长度的数据</span></span><br><span class=\"line\">             in.get(content);  <span class=\"comment\">//5、读取报文体</span></span><br><span class=\"line\">             String xmlContent = <span class=\"keyword\">new</span> String(content, charset);</span><br><span class=\"line\">             EgsLog.getEgsChannelLogNoCache().debug(<span class=\"string\">\"解包后的核心接口返回字符串(编码字符集\"</span> + charset + <span class=\"string\">\")：\"</span> + xmlContent);</span><br><span class=\"line\">             out.write(xmlContent);</span><br><span class=\"line\">     </span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (in.remaining() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果内容后面还粘了包 单次交互不管</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"出现由于长度判断导致问题的场景\"><a href=\"#出现由于长度判断导致问题的场景\" class=\"headerlink\" title=\"出现由于长度判断导致问题的场景\"></a>出现由于长度判断导致问题的场景</h3><p>在很极端的情况下，假设报文头长度8字节，报文体长度22字节。<br>最开始使用默认大小的缓冲区，</p>\n<ul>\n<li>假设获取了一段10字节的包   </li>\n<li>步骤1获取了前面8字节知道了报文总长度22  </li>\n<li>步骤2将标志重置到起始位置，缓冲区满了，自动扩展到25字节大小  </li>\n<li>重新执行doDecode方法  </li>\n<li>步骤2，position重置到头部，因为报文头的长度不包括自身长度，步骤3判断缓冲区有25字节大于报文体22字节，开始读取。  </li>\n<li>步骤4跳过表示报文长度8字节，此时缓冲区剩余17字节  </li>\n<li>开始读取22字节的报文，超过缓冲区可读取长度，于是抛出BufferUnderflowException异常  </li>\n</ul>\n<p>这种情况也只在后面一段包还没接收到，在传输的途中，ioBuffer扩展大小之前进行读取的极端情况下出现。但是生产只要是这两个用户数据必定复现，所以不是这种情况导致的，不过也确实发现了一个隐藏问题。<br>既然意外发现了也应该修复。  </p>\n<h3 id=\"修改逻辑\"><a href=\"#修改逻辑\" class=\"headerlink\" title=\"修改逻辑\"></a>修改逻辑</h3><p>步骤3判断条件修改  </p>\n<pre><code class=\"java\"><span class=\"keyword\">if</span> (in.remaining() &lt; packageSize + fieldLen)\n</code></pre>\n<p>Ctrl C + Ctrl V多了也是有可能出事的。 </p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对于单次交互的短连接，由于不存在粘包的情况，所以可以将客户端的接收缓冲区根据实际业务报文大小适当调大，可以大于等于业务最大报文，一般缓冲区设置较小为了减少开销，而实际业务的报文大小一般最多十几到几十kb。</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>生产环境上有个项目，跟上游系统交互通过Socket使用XML报文，代码中使用Mina作为客户端进行连接。<br>在传输编码成字符串的Photo节点时，特定的用户数据接收时出现BufferUnderflowException异常导致交易无法继续。<br>而在测试环境使用图片更大的数据却没有复现该异常，记录排查过程和错误猜测思路。<br>","more":"</p>\n<h2 id=\"报错场景和异常内容\"><a href=\"#报错场景和异常内容\" class=\"headerlink\" title=\"报错场景和异常内容\"></a>报错场景和异常内容</h2><p>使用Mina作为客户端与上游系统交互，返回报文格式如下图<br><img src=\"/images/imageForPost/socket/Mina/报文格式.png\" alt><br>特定两位用户的数据返回时出现如下异常<br><img src=\"/images/imageForPost/socket/Mina/MinaException1.png\" alt><br><img src=\"/images/imageForPost/socket/Mina/MinaException2.jpg\" alt>  </p>\n<h2 id=\"处理方法\"><a href=\"#处理方法\" class=\"headerlink\" title=\"处理方法\"></a>处理方法</h2><p>面向搜索引擎编程，第一反应自然是进行如下操作<br><img src=\"/images/imageForPost/socket/Mina/面向谷歌编程.png\" alt><br>大多数网友的处理方法是手动增大接收缓冲区到报文大小.<br>在报错日志中确实是有看到ioBuffer进行自动扩大，因为逻辑中没有指定大小，使用的是默认大小.<br>Mina会根据当前包大小来判断调整缓冲区大小，可能扩大也可能缩小，当缩小时来了个大包就会导致异常。<br>生产日终中从2048扩大到4096然后出现了异常<br><img src=\"/images/imageForPost/socket/Mina/iobuffer扩大.JPG\" alt><br>于是在创建Mina Client时指定读缓冲区大小，以业务报文为基准设置个合理的值，单次交互不会存在粘包的问题于是可以设置成大与等于业务报文大小。  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">connector.getSessionConfig().setReceiveBufferSize(<span class=\"number\">2048</span>*<span class=\"number\">50</span>);</span><br><span class=\"line\">connector.getSessionConfig().setReadBufferSize(<span class=\"number\">2048</span>*<span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n<p>connector为NioSocketConnector，在创建完处理链之后指定了读取缓冲区和接收缓冲区大小。<br>喜闻乐见，报文正常接收了。  </p>\n<h2 id=\"导致生产问题的原因\"><a href=\"#导致生产问题的原因\" class=\"headerlink\" title=\"导致生产问题的原因\"></a>导致生产问题的原因</h2><h3 id=\"接收缓冲区自动缩小\"><a href=\"#接收缓冲区自动缩小\" class=\"headerlink\" title=\"接收缓冲区自动缩小\"></a>接收缓冲区自动缩小</h3><p>翻到一篇场景一样的文章<br><a href=\"https://my.oschina.net/javagg/blog/2\" rel=\"noopener\" target=\"_blank\">mina read方法出现BufferUnderflowException异常的解决办法</a><br>Mina会根据接收到的包大小自动调整缓冲区的大小，在接收TCP包的过程中，前面都是小包，Mina会判断，如果当前包的大小的平方倍小与byteBuf的大小的话，会把缓冲区减半。<br>此时来了一个大包，超过了缓冲区大小，get获取就出错了。<br>具体可以看<em>AbstractPollingIoProcessor类的read(T session)</em>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(T session)</span> </span>&#123;</span><br><span class=\"line\">        IoSessionConfig config = session.getConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">        IoBuffer buf = IoBuffer.allocate(config.getReadBufferSize());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> hasFragmentation =</span><br><span class=\"line\">            session.getTransportMetadata().hasFragmentation();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> readBytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasFragmentation) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> ((ret = read(session, buf)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        readBytes += ret;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!buf.hasRemaining()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    ret = read(session, buf);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        readBytes = ret;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                buf.flip();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (readBytes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                session.getFilterChain().fireMessageReceived(buf);</span><br><span class=\"line\">                buf = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hasFragmentation) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBytes &lt;&lt; <span class=\"number\">1</span> &lt; config.getReadBufferSize()) &#123;</span><br><span class=\"line\">                        session.decreaseReadBufferSize();  <span class=\"comment\">//1、buffer减小</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readBytes == config.getReadBufferSize()) &#123;</span><br><span class=\"line\">                        session.increaseReadBufferSize(); <span class=\"comment\">//2、buffer加大</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                scheduleRemove(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> IOException) &#123;</span><br><span class=\"line\">                scheduleRemove(session);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            session.getFilterChain().fireExceptionCaught(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">decreaseReadBufferSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.deferDecreaseReadBuffer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deferDecreaseReadBuffer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getConfig().getReadBufferSize() &gt; <span class=\"keyword\">this</span>.getConfig().getMinReadBufferSize()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.getConfig().setReadBufferSize(<span class=\"keyword\">this</span>.getConfig().getReadBufferSize() &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deferDecreaseReadBuffer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>注释1中是缓冲区减小的情况，即判断当前包的平方倍是不是比当前分配的缓冲区小，小的话调用decreaseReadBufferSize()减小缓冲区。  </p>\n<p>当缓冲区减小后，发送端发来一个大于缓冲区大小的包，就会导致BufferUnderflowException异常  </p>\n<h2 id=\"顺便发现的问题\"><a href=\"#顺便发现的问题\" class=\"headerlink\" title=\"顺便发现的问题\"></a>顺便发现的问题</h2><h3 id=\"解码器中长度判断有误\"><a href=\"#解码器中长度判断有误\" class=\"headerlink\" title=\"解码器中长度判断有误\"></a>解码器中长度判断有误</h3><p>因为是短连接，所以不存在粘包的问题，异常抛错的栈顶方法是ioBuffer的get方法  </p>\n<p>出现java.nio.BufferUnderflowException的情况为读取长度超过缓冲区可用长度  </p>\n<hr>\n<p>关注下解码器中的读取逻辑，然后发现解码器中的长度判断逻辑有点小问题。<br>在非常极端的情况下会出现BufferUnderflowException异常，不过这不是导致当前生产问题的原因。<br>先来关注下这个长度判断导致的问题。   </p>\n<h4 id=\"ProtocolDecoder代码\"><a href=\"#ProtocolDecoder代码\" class=\"headerlink\" title=\"ProtocolDecoder代码\"></a>ProtocolDecoder代码</h4><p>继承了CumulativeProtocolDecoder，CumulativeProtocolDecoder是一种积累型的解码器，只要channel中有数据进来就会读取数据积累到ioBuffer缓冲区中，子类通过实现doDecode方法进行拆包，doDecode只要有数据进来就会被调用。    </p>\n<p><strong>doDecode方法</strong>   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> fieldLen = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">doDecode</span><span class=\"params\">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (in.remaining() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果有数据，先读取Head中的8字节长度来获取总报文长度</span></span><br><span class=\"line\">         <span class=\"keyword\">byte</span>[] sizeBytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[fieldLen];</span><br><span class=\"line\">         in.mark(); <span class=\"comment\">//1、标记ioBuffer最开头的位置</span></span><br><span class=\"line\">         in.get(sizeBytes);</span><br><span class=\"line\">         String len = <span class=\"keyword\">new</span> String(sizeBytes, charset);</span><br><span class=\"line\">         <span class=\"keyword\">int</span> packageSize = Integer.valueOf(len);</span><br><span class=\"line\">         in.reset();<span class=\"comment\">// 2、重置到标志位置</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (in.remaining() &lt; packageSize) &#123; <span class=\"comment\">//3、判断剩余数据长度是不是跟报文体一样长</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">             <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[packageSize];</span><br><span class=\"line\">             in.skip(fieldLen); <span class=\"comment\">//4、跳过表示报文头长度的数据</span></span><br><span class=\"line\">             in.get(content);  <span class=\"comment\">//5、读取报文体</span></span><br><span class=\"line\">             String xmlContent = <span class=\"keyword\">new</span> String(content, charset);</span><br><span class=\"line\">             EgsLog.getEgsChannelLogNoCache().debug(<span class=\"string\">\"解包后的核心接口返回字符串(编码字符集\"</span> + charset + <span class=\"string\">\")：\"</span> + xmlContent);</span><br><span class=\"line\">             out.write(xmlContent);</span><br><span class=\"line\">     </span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (in.remaining() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果内容后面还粘了包 单次交互不管</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"出现由于长度判断导致问题的场景\"><a href=\"#出现由于长度判断导致问题的场景\" class=\"headerlink\" title=\"出现由于长度判断导致问题的场景\"></a>出现由于长度判断导致问题的场景</h3><p>在很极端的情况下，假设报文头长度8字节，报文体长度22字节。<br>最开始使用默认大小的缓冲区，</p>\n<ul>\n<li>假设获取了一段10字节的包   </li>\n<li>步骤1获取了前面8字节知道了报文总长度22  </li>\n<li>步骤2将标志重置到起始位置，缓冲区满了，自动扩展到25字节大小  </li>\n<li>重新执行doDecode方法  </li>\n<li>步骤2，position重置到头部，因为报文头的长度不包括自身长度，步骤3判断缓冲区有25字节大于报文体22字节，开始读取。  </li>\n<li>步骤4跳过表示报文长度8字节，此时缓冲区剩余17字节  </li>\n<li>开始读取22字节的报文，超过缓冲区可读取长度，于是抛出BufferUnderflowException异常  </li>\n</ul>\n<p>这种情况也只在后面一段包还没接收到，在传输的途中，ioBuffer扩展大小之前进行读取的极端情况下出现。但是生产只要是这两个用户数据必定复现，所以不是这种情况导致的，不过也确实发现了一个隐藏问题。<br>既然意外发现了也应该修复。  </p>\n<h3 id=\"修改逻辑\"><a href=\"#修改逻辑\" class=\"headerlink\" title=\"修改逻辑\"></a>修改逻辑</h3><p>步骤3判断条件修改  </p>\n<pre><code class=\"java\"><span class=\"keyword\">if</span> (in.remaining() &lt; packageSize + fieldLen)\n</code></pre>\n<p>Ctrl C + Ctrl V多了也是有可能出事的。 </p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>对于单次交互的短连接，由于不存在粘包的情况，所以可以将客户端的接收缓冲区根据实际业务报文大小适当调大，可以大于等于业务最大报文，一般缓冲区设置较小为了减少开销，而实际业务的报文大小一般最多十几到几十kb。</p>"},{"title":"JAVA 动态代理与Spring AOP","date":"2019-06-26T13:02:16.000Z","comments":1,"_content":"\n本篇主要讲述以下内容\n\n* 静态代理\n* 动态代理\n\t* jdk动态代理\n\t* cglib动态代理。\n* Spring AOP中是怎么使用到动态代理的\n* 在spring的Cglib2AopProxy中使用到的transient关键字是做什么的\n<!-- more -->  \n\n## 先来说说java的三种代理模式  \n\n\n代理模式proxy是一种设计模式，假设目标对象A有功能functionA()，只负责他对应的业务逻辑，而调用时想在业务逻辑之前或者之后想打印些系统日志，这时候存在一个对A的增强对象proxyA，扩展了A的功能，使得通过代理对象proxyA访问目标对象A，在目标对象A实现功能的基础上扩展了额外的系统日志打印功能，在不修改A的基础上扩展了目标A的功能并且调用目标对象。\n### 静态代理\n\n**静态代理的时候首先需要有一个接口或者父类供代理类和目标类一同实现或继承**。\n代码如下\n接口**IBussiness.java**  \n\n```java\npublic interface IBussiness {\n        void doSomething();\n}\n\n```\n\n\n\n目标类**Target.java**  \n\n```java\npublic class Target implements IBussiness{\n    @Override\n    \tpublic void doSomething() {\n        System.out.println(\"do something\");\n    \t}\n}\n```\n\n\n代理类**TargetProxy.java**  \n\n```java\npublic class TargetProxy implements IBussiness{\n\tprivate IBussiness target;\n\n\tpublic TargetProxy(IBussiness target) {\n    this.target = target;\n\t}\n\n\t@Override\n\tpublic void doSomething() {\n    System.out.println(\"before do something\");\n    target.doSomething();\n    System.out.println(\"after do something\");\n\t}\n}\n```\n\n\n测试类**AppTest.java**  \n```java\npublic class AppTest {\n    /**\n     * Rigorous Test :-)\n     */\n    @Test\n    public void shouldAnswerWithTrue()\n    {\n        assertTrue( true );\n        Target target = new Target();\n    \n        TargetProxy proxy = new TargetProxy(target);\n    \n        proxy.doSomething();\n    }\n}\n```\n\n**运行结果**\n![静态代理图1](/images/imageForPost/笔记/动态代理/静态代理图1.png)\n\n------\n\n可见代理可以在不修改目标对象的情况下扩展对应的功能，但是代理对象和目标对象要实现相同的接口，如果业务中存在大量需要被代理的类则会增加很多不必要的维护工作  \n\n​为了解决这一问题，可以看下jdk动态代理  \n\n动态代理不要求代理类与目标类实现相同的接口，但是目标类要求实现接口，通过在运行时创建实现了指定接口的对象来实现目标对象的扩展  \n  \n------  \n \n \n### JDK动态代理\n主要使用到**java.lang.reflect**的**Proxy**类的**newProxyInstance**方法 \n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)throws IllegalArgumentException\n```\n\n主要有三个参数 \n* ClassLoader loader  \n\n  ClassLoader 类加载器，用来加载生成的类，类加载器可以参考这篇\n\n  [这篇]: \n\n  \n\n* Class<?>[] interfaces\n\n\tinterfaces  代理类实现的被代理类的接口。\n\n* InvocationHandler h  \n\tInvocationHandler 代理类的扩展处理器，具体扩展逻辑在该处理器中实现。\n------\n继续使用上面用到的**IBussiness.java** 接口\n代理处理器**ProxyInvocationHandler.java**\n\n```java\npublic class ProxyInvocationHandler implements  InvocationHandler {\n        \n    \t//被代理的目标对象\n      private Object target;\n        \n      public ProxyInvocationHandler(Object target) {\n        this.target = target;\n      }\n        \n      @Override\n      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      System.out.println(\"before do something\");\n      //通过反射调用目标对象的方法，如果invoke传入代理对象则会出现递归调用代理对象的代理方法\n      Object result = method.invoke(target, args);\n      System.out.println(\"after do something\");\n      return result;\n      }\n\n\n      public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(),\ttarget.getClass().getInterfaces(), this);\n    \n      }\n}\n\n```\n\n测试类**JdkProxy.java**\n```java\npublic class JdkProxy {\n\t@Test\n\tpublic void shouldAnswerWithTrue(){\n       IBussiness target = new Target();\n    \n       IBussiness proxyObj = (IBussiness) new ProxyInvocationHandler(target).getProxy();\n    \n       proxyObj.doSomething();\n\t}\n}\n```\n**执行效果**\n\n![jdk代理图1](/images/imageForPost/笔记/动态代理/jdk代理图1.png)\n\n------\n\n\n\n### cglib的代理\n与jdk代理不同的是cglib代理是通过运行时通过字节码库生成目标对象的子类，所以不需要像jdk代理一样目标对象需要实现接口，Spring AOP中就是根据目标对象是否实现了接口来确定使用jdk代理还是cglib代理，具体的选择在后面会讲。\n\n测试工程使用的是**maven**，所以在工程**pom**中添加cglib的依赖\n```shell\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.1</version>\n    </dependency>\n```\n\n继续使用上面用到的**IBussiness.java** 接口\n代理处理器**CglibProxy.java**\n\n```java\npublic class CglibProxy implements MethodInterceptor {\n    \n    //目标对象\n    private Object target;\n    \n    public CglibProxy(Object target) {\n        this.target = target;\n    }\n    \n    public Object getProxyObj(){\n        //cglib工具类\n        Enhancer en = new Enhancer();\n        //设置被代理对象\n        en.setSuperclass(target.getClass());\n        //设置扩展处理器\n        en.setCallback(this);\n        //返回代理对象\n        return en.create();\n    }\n    \n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"before do something by cglib\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"after do something by cglib\");\n        return result;\n    }\n}\n```\n测试类**CglibProxyTest.java**\n```java\npublic class CglibProxyTest {\n    @Test\n    public void shouldAnswerWithTrue()\n    {\n        IBussiness target = new Target();\n    \n        IBussiness proxyObj = (IBussiness) new CglibProxy(target).getProxyObj();\n    \n        proxyObj.doSomething();\n\n\n    }\n}\n```\n\n**运行结果**\n\n![cglib代理图1](/images/imageForPost/笔记/动态代理/cglib代理图1.png)\n\n可见cglib和jdk代理在代码结构上非常类似，Spring AOP则是使用这两种方式创建代理，Spring AOP中代理的扩展方法即advice扩展方法是另外指定的，而前面的代理扩展则是写死的，如何使得代理类能使用我们指定的方法呢，像AOP一样可以使用前置通知、后置通知和环绕通知。最简单的方法就是给**ProxyInvocationHandler**的构造方法传入想要用来扩展的方法，然后在目标对象方法的invoke之前调用扩展方法即可。\n接下来简单的看下Spring的AOP  \n\n----  \n## Spring中的代理  \n\n手边的工程是用的Spring 3.0.5版本\n在**org.springframework.aop.framework**包下的**DefaultAopProxyFactory**类中有个**public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException** 方法\n\n```java\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        if (!config.isOptimize() && !config.isProxyTargetClass() && !this.hasNoUserSuppliedProxyInterfaces(config)) {\n            return new JdkDynamicAopProxy(config);\n        } else {\n            Class targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException(\"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.\");\n            } else if (targetClass.isInterface()) {\n                return new JdkDynamicAopProxy(config);\n            } else if (!cglibAvailable) {\n                throw new AopConfigException(\"Cannot proxy target class because CGLIB2 is not available. Add CGLIB to the class path or specify proxy interfaces.\");\n            } else {\n                return DefaultAopProxyFactory.CglibProxyFactory.createCglibProxy(config);\n            }\n        }\n}\n```\n会根据被代理对象是否有实现接口来选择使用jdk代理还是cglib代理\n跟进**JdkDynamicAopProxy**类可以看到**getProxy()**方法通过**Proxy.newProxyInstance**返回了一个代理对象\n\n```java\npublic Object getProxy(ClassLoader classLoader) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n        }\n    \n        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);\n        this.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n```\n\n\n跟进,则可以看到对应的**getProxy()**方法\n```java\npublic Object getProxy(ClassLoader classLoader) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating CGLIB2 proxy: target source is \" + this.advised.getTargetSource());\n        }\n    \n        try {\n            Class rootClass = this.advised.getTargetClass();\n            Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\");\n            Class proxySuperClass = rootClass;\n            int x;\n            if (AopUtils.isCglibProxyClass(rootClass)) {\n                proxySuperClass = rootClass.getSuperclass();\n                Class[] additionalInterfaces = rootClass.getInterfaces();\n                Class[] var8 = additionalInterfaces;\n                x = additionalInterfaces.length;\n    \n                for(int var6 = 0; var6 < x; ++var6) {\n                    Class additionalInterface = var8[var6];\n                    this.advised.addInterface(additionalInterface);\n                }\n            }\n    \n            this.validateClassIfNecessary(proxySuperClass);\n            Enhancer enhancer = this.createEnhancer();\n            if (classLoader != null) {\n                enhancer.setClassLoader(classLoader);\n                if (classLoader instanceof SmartClassLoader && ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) {\n                    enhancer.setUseCache(false);\n                }\n            }\n    \n            enhancer.setSuperclass(proxySuperClass);\n            enhancer.setStrategy(new UndeclaredThrowableStrategy(UndeclaredThrowableException.class));\n            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));\n            enhancer.setInterceptDuringConstruction(false);\n            Callback[] callbacks = this.getCallbacks(rootClass);\n            enhancer.setCallbacks(callbacks);\n            enhancer.setCallbackFilter(new Cglib2AopProxy.ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));\n            Class[] types = new Class[callbacks.length];\n    \n            for(x = 0; x < types.length; ++x) {\n                types[x] = callbacks[x].getClass();\n            }\n    \n            enhancer.setCallbackTypes(types);\n            Object proxy;\n            if (this.constructorArgs != null) {\n                proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs);\n            } else {\n                proxy = enhancer.create();\n            }\n    \n            return proxy;\n        } catch (CodeGenerationException var9) {\n            throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", var9);\n        } catch (IllegalArgumentException var10) {\n            throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", var10);\n        } catch (Exception var11) {\n            throw new AopConfigException(\"Unexpected AOP exception\", var11);\n        }\n}\n```\n  \n## transient关键字  \n\n在**Cglib2AopProxy**的属性中有一个transient关键字，之前基本没看到过（果然是我见识少啊）\n这也是java的关键字之一\n这个关键字用来标示某个属性不被序列化\n定义一个会被序列化的类**TrabsientTest.java**\n\n```java\npublic class TransientTest implements Serializable {\n    \n    private String field1;\n    \n    private transient String field2;\n\n\n    public TransientTest(String field1, String field2) {\n        this.field1 = field1;\n        this.field2 = field2;\n    }\n    public TransientTest() {\n        this.field2 = \"???\";\n    \n    }\n    @Override\n    public String toString() {\n        return \"TransientTest{\" +\n                \"field1='\" + field1 + '\\'' +\n                \", field2='\" + field2 + '\\'' +\n                '}';\n    }\n}\n```\n\n然后创建一个该类的对象并且序列化它 **TestSerial.java**\n```java\npublic class TestSerial {\n    private TransientTest obj;\n    \n    @Test\n    public void shouldAnswerWithTrue()\n    {\n\n\n        TransientTest obj = new TransientTest(\"test1\",\"test2\");\n    \n        System.out.println(obj.toString());\n    \n        try {\n            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"obj\"));\n            o.writeObject(obj);\n            o.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n        try {\n            ObjectInputStream in =new ObjectInputStream(new FileInputStream(\"obj\"));\n            TransientTest logInfoIn = (TransientTest)in.readObject();\n            System.out.println(logInfoIn.toString());\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    \n    }\n}\n```\n结果如图\n\n![transient图1](/images/imageForPost/笔记/动态代理/transient图1.png)\n\n​\t执行后可以看到field2并没有值，在序列化时略过了field2，在反序列化的时候并没有执行构造函数给field2赋值“？？？”，反序列化并不会通过构造函数进行创建对象，而是载入了该类对象的持久化状态。\n","source":"_posts/笔记/JAVA 动态代理与Spring AOP  .md","raw":"---\ntitle: JAVA 动态代理与Spring AOP \ndate: 2019-06-26 21:02:16\ncomments: true\ncategories: \n- 笔记\ntags: \n- java\n---\n\n本篇主要讲述以下内容\n\n* 静态代理\n* 动态代理\n\t* jdk动态代理\n\t* cglib动态代理。\n* Spring AOP中是怎么使用到动态代理的\n* 在spring的Cglib2AopProxy中使用到的transient关键字是做什么的\n<!-- more -->  \n\n## 先来说说java的三种代理模式  \n\n\n代理模式proxy是一种设计模式，假设目标对象A有功能functionA()，只负责他对应的业务逻辑，而调用时想在业务逻辑之前或者之后想打印些系统日志，这时候存在一个对A的增强对象proxyA，扩展了A的功能，使得通过代理对象proxyA访问目标对象A，在目标对象A实现功能的基础上扩展了额外的系统日志打印功能，在不修改A的基础上扩展了目标A的功能并且调用目标对象。\n### 静态代理\n\n**静态代理的时候首先需要有一个接口或者父类供代理类和目标类一同实现或继承**。\n代码如下\n接口**IBussiness.java**  \n\n```java\npublic interface IBussiness {\n        void doSomething();\n}\n\n```\n\n\n\n目标类**Target.java**  \n\n```java\npublic class Target implements IBussiness{\n    @Override\n    \tpublic void doSomething() {\n        System.out.println(\"do something\");\n    \t}\n}\n```\n\n\n代理类**TargetProxy.java**  \n\n```java\npublic class TargetProxy implements IBussiness{\n\tprivate IBussiness target;\n\n\tpublic TargetProxy(IBussiness target) {\n    this.target = target;\n\t}\n\n\t@Override\n\tpublic void doSomething() {\n    System.out.println(\"before do something\");\n    target.doSomething();\n    System.out.println(\"after do something\");\n\t}\n}\n```\n\n\n测试类**AppTest.java**  \n```java\npublic class AppTest {\n    /**\n     * Rigorous Test :-)\n     */\n    @Test\n    public void shouldAnswerWithTrue()\n    {\n        assertTrue( true );\n        Target target = new Target();\n    \n        TargetProxy proxy = new TargetProxy(target);\n    \n        proxy.doSomething();\n    }\n}\n```\n\n**运行结果**\n![静态代理图1](/images/imageForPost/笔记/动态代理/静态代理图1.png)\n\n------\n\n可见代理可以在不修改目标对象的情况下扩展对应的功能，但是代理对象和目标对象要实现相同的接口，如果业务中存在大量需要被代理的类则会增加很多不必要的维护工作  \n\n​为了解决这一问题，可以看下jdk动态代理  \n\n动态代理不要求代理类与目标类实现相同的接口，但是目标类要求实现接口，通过在运行时创建实现了指定接口的对象来实现目标对象的扩展  \n  \n------  \n \n \n### JDK动态代理\n主要使用到**java.lang.reflect**的**Proxy**类的**newProxyInstance**方法 \n\n```java\npublic static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)throws IllegalArgumentException\n```\n\n主要有三个参数 \n* ClassLoader loader  \n\n  ClassLoader 类加载器，用来加载生成的类，类加载器可以参考这篇\n\n  [这篇]: \n\n  \n\n* Class<?>[] interfaces\n\n\tinterfaces  代理类实现的被代理类的接口。\n\n* InvocationHandler h  \n\tInvocationHandler 代理类的扩展处理器，具体扩展逻辑在该处理器中实现。\n------\n继续使用上面用到的**IBussiness.java** 接口\n代理处理器**ProxyInvocationHandler.java**\n\n```java\npublic class ProxyInvocationHandler implements  InvocationHandler {\n        \n    \t//被代理的目标对象\n      private Object target;\n        \n      public ProxyInvocationHandler(Object target) {\n        this.target = target;\n      }\n        \n      @Override\n      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      System.out.println(\"before do something\");\n      //通过反射调用目标对象的方法，如果invoke传入代理对象则会出现递归调用代理对象的代理方法\n      Object result = method.invoke(target, args);\n      System.out.println(\"after do something\");\n      return result;\n      }\n\n\n      public Object getProxy(){\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(),\ttarget.getClass().getInterfaces(), this);\n    \n      }\n}\n\n```\n\n测试类**JdkProxy.java**\n```java\npublic class JdkProxy {\n\t@Test\n\tpublic void shouldAnswerWithTrue(){\n       IBussiness target = new Target();\n    \n       IBussiness proxyObj = (IBussiness) new ProxyInvocationHandler(target).getProxy();\n    \n       proxyObj.doSomething();\n\t}\n}\n```\n**执行效果**\n\n![jdk代理图1](/images/imageForPost/笔记/动态代理/jdk代理图1.png)\n\n------\n\n\n\n### cglib的代理\n与jdk代理不同的是cglib代理是通过运行时通过字节码库生成目标对象的子类，所以不需要像jdk代理一样目标对象需要实现接口，Spring AOP中就是根据目标对象是否实现了接口来确定使用jdk代理还是cglib代理，具体的选择在后面会讲。\n\n测试工程使用的是**maven**，所以在工程**pom**中添加cglib的依赖\n```shell\n    <dependency>\n      <groupId>cglib</groupId>\n      <artifactId>cglib</artifactId>\n      <version>3.1</version>\n    </dependency>\n```\n\n继续使用上面用到的**IBussiness.java** 接口\n代理处理器**CglibProxy.java**\n\n```java\npublic class CglibProxy implements MethodInterceptor {\n    \n    //目标对象\n    private Object target;\n    \n    public CglibProxy(Object target) {\n        this.target = target;\n    }\n    \n    public Object getProxyObj(){\n        //cglib工具类\n        Enhancer en = new Enhancer();\n        //设置被代理对象\n        en.setSuperclass(target.getClass());\n        //设置扩展处理器\n        en.setCallback(this);\n        //返回代理对象\n        return en.create();\n    }\n    \n    @Override\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"before do something by cglib\");\n        Object result = method.invoke(target, args);\n        System.out.println(\"after do something by cglib\");\n        return result;\n    }\n}\n```\n测试类**CglibProxyTest.java**\n```java\npublic class CglibProxyTest {\n    @Test\n    public void shouldAnswerWithTrue()\n    {\n        IBussiness target = new Target();\n    \n        IBussiness proxyObj = (IBussiness) new CglibProxy(target).getProxyObj();\n    \n        proxyObj.doSomething();\n\n\n    }\n}\n```\n\n**运行结果**\n\n![cglib代理图1](/images/imageForPost/笔记/动态代理/cglib代理图1.png)\n\n可见cglib和jdk代理在代码结构上非常类似，Spring AOP则是使用这两种方式创建代理，Spring AOP中代理的扩展方法即advice扩展方法是另外指定的，而前面的代理扩展则是写死的，如何使得代理类能使用我们指定的方法呢，像AOP一样可以使用前置通知、后置通知和环绕通知。最简单的方法就是给**ProxyInvocationHandler**的构造方法传入想要用来扩展的方法，然后在目标对象方法的invoke之前调用扩展方法即可。\n接下来简单的看下Spring的AOP  \n\n----  \n## Spring中的代理  \n\n手边的工程是用的Spring 3.0.5版本\n在**org.springframework.aop.framework**包下的**DefaultAopProxyFactory**类中有个**public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException** 方法\n\n```java\npublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        if (!config.isOptimize() && !config.isProxyTargetClass() && !this.hasNoUserSuppliedProxyInterfaces(config)) {\n            return new JdkDynamicAopProxy(config);\n        } else {\n            Class targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException(\"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.\");\n            } else if (targetClass.isInterface()) {\n                return new JdkDynamicAopProxy(config);\n            } else if (!cglibAvailable) {\n                throw new AopConfigException(\"Cannot proxy target class because CGLIB2 is not available. Add CGLIB to the class path or specify proxy interfaces.\");\n            } else {\n                return DefaultAopProxyFactory.CglibProxyFactory.createCglibProxy(config);\n            }\n        }\n}\n```\n会根据被代理对象是否有实现接口来选择使用jdk代理还是cglib代理\n跟进**JdkDynamicAopProxy**类可以看到**getProxy()**方法通过**Proxy.newProxyInstance**返回了一个代理对象\n\n```java\npublic Object getProxy(ClassLoader classLoader) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n        }\n    \n        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised);\n        this.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n}\n```\n\n\n跟进,则可以看到对应的**getProxy()**方法\n```java\npublic Object getProxy(ClassLoader classLoader) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Creating CGLIB2 proxy: target source is \" + this.advised.getTargetSource());\n        }\n    \n        try {\n            Class rootClass = this.advised.getTargetClass();\n            Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\");\n            Class proxySuperClass = rootClass;\n            int x;\n            if (AopUtils.isCglibProxyClass(rootClass)) {\n                proxySuperClass = rootClass.getSuperclass();\n                Class[] additionalInterfaces = rootClass.getInterfaces();\n                Class[] var8 = additionalInterfaces;\n                x = additionalInterfaces.length;\n    \n                for(int var6 = 0; var6 < x; ++var6) {\n                    Class additionalInterface = var8[var6];\n                    this.advised.addInterface(additionalInterface);\n                }\n            }\n    \n            this.validateClassIfNecessary(proxySuperClass);\n            Enhancer enhancer = this.createEnhancer();\n            if (classLoader != null) {\n                enhancer.setClassLoader(classLoader);\n                if (classLoader instanceof SmartClassLoader && ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) {\n                    enhancer.setUseCache(false);\n                }\n            }\n    \n            enhancer.setSuperclass(proxySuperClass);\n            enhancer.setStrategy(new UndeclaredThrowableStrategy(UndeclaredThrowableException.class));\n            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));\n            enhancer.setInterceptDuringConstruction(false);\n            Callback[] callbacks = this.getCallbacks(rootClass);\n            enhancer.setCallbacks(callbacks);\n            enhancer.setCallbackFilter(new Cglib2AopProxy.ProxyCallbackFilter(this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));\n            Class[] types = new Class[callbacks.length];\n    \n            for(x = 0; x < types.length; ++x) {\n                types[x] = callbacks[x].getClass();\n            }\n    \n            enhancer.setCallbackTypes(types);\n            Object proxy;\n            if (this.constructorArgs != null) {\n                proxy = enhancer.create(this.constructorArgTypes, this.constructorArgs);\n            } else {\n                proxy = enhancer.create();\n            }\n    \n            return proxy;\n        } catch (CodeGenerationException var9) {\n            throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", var9);\n        } catch (IllegalArgumentException var10) {\n            throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", var10);\n        } catch (Exception var11) {\n            throw new AopConfigException(\"Unexpected AOP exception\", var11);\n        }\n}\n```\n  \n## transient关键字  \n\n在**Cglib2AopProxy**的属性中有一个transient关键字，之前基本没看到过（果然是我见识少啊）\n这也是java的关键字之一\n这个关键字用来标示某个属性不被序列化\n定义一个会被序列化的类**TrabsientTest.java**\n\n```java\npublic class TransientTest implements Serializable {\n    \n    private String field1;\n    \n    private transient String field2;\n\n\n    public TransientTest(String field1, String field2) {\n        this.field1 = field1;\n        this.field2 = field2;\n    }\n    public TransientTest() {\n        this.field2 = \"???\";\n    \n    }\n    @Override\n    public String toString() {\n        return \"TransientTest{\" +\n                \"field1='\" + field1 + '\\'' +\n                \", field2='\" + field2 + '\\'' +\n                '}';\n    }\n}\n```\n\n然后创建一个该类的对象并且序列化它 **TestSerial.java**\n```java\npublic class TestSerial {\n    private TransientTest obj;\n    \n    @Test\n    public void shouldAnswerWithTrue()\n    {\n\n\n        TransientTest obj = new TransientTest(\"test1\",\"test2\");\n    \n        System.out.println(obj.toString());\n    \n        try {\n            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"obj\"));\n            o.writeObject(obj);\n            o.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n\n        try {\n            ObjectInputStream in =new ObjectInputStream(new FileInputStream(\"obj\"));\n            TransientTest logInfoIn = (TransientTest)in.readObject();\n            System.out.println(logInfoIn.toString());\n        } catch(Exception e) {\n            e.printStackTrace();\n        }\n    \n    }\n}\n```\n结果如图\n\n![transient图1](/images/imageForPost/笔记/动态代理/transient图1.png)\n\n​\t执行后可以看到field2并没有值，在序列化时略过了field2，在反序列化的时候并没有执行构造函数给field2赋值“？？？”，反序列化并不会通过构造函数进行创建对象，而是载入了该类对象的持久化状态。\n","slug":"笔记/JAVA 动态代理与Spring AOP  ","published":1,"updated":"2020-01-29T13:55:43.250Z","_id":"ck5ibb8vq001dd4rm6rdi7cst","layout":"post","photos":[],"link":"","content":"<p>本篇主要讲述以下内容</p>\n<ul>\n<li>静态代理</li>\n<li>动态代理<ul>\n<li>jdk动态代理</li>\n<li>cglib动态代理。</li>\n</ul>\n</li>\n<li>Spring AOP中是怎么使用到动态代理的</li>\n<li>在spring的Cglib2AopProxy中使用到的transient关键字是做什么的<a id=\"more\"></a>  \n</li>\n</ul>\n<h2 id=\"先来说说java的三种代理模式\"><a href=\"#先来说说java的三种代理模式\" class=\"headerlink\" title=\"先来说说java的三种代理模式\"></a>先来说说java的三种代理模式</h2><p>代理模式proxy是一种设计模式，假设目标对象A有功能functionA()，只负责他对应的业务逻辑，而调用时想在业务逻辑之前或者之后想打印些系统日志，这时候存在一个对A的增强对象proxyA，扩展了A的功能，使得通过代理对象proxyA访问目标对象A，在目标对象A实现功能的基础上扩展了额外的系统日志打印功能，在不修改A的基础上扩展了目标A的功能并且调用目标对象。</p>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><p><strong>静态代理的时候首先需要有一个接口或者父类供代理类和目标类一同实现或继承</strong>。<br>代码如下<br>接口<strong>IBussiness.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBussiness</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目标类<strong>Target.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Target</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBussiness</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"do something\"</span>);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代理类<strong>TargetProxy.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TargetProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBussiness</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IBussiness target;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TargetProxy</span><span class=\"params\">(IBussiness target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"before do something\"</span>);</span><br><span class=\"line\">    target.doSomething();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"after do something\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>AppTest.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Rigorous Test :-)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        assertTrue( <span class=\"keyword\">true</span> );</span><br><span class=\"line\">        Target target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">        TargetProxy proxy = <span class=\"keyword\">new</span> TargetProxy(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>运行结果</strong><br><img src=\"/images/imageForPost/笔记/动态代理/静态代理图1.png\" alt=\"静态代理图1\"></p>\n<hr>\n<p>可见代理可以在不修改目标对象的情况下扩展对应的功能，但是代理对象和目标对象要实现相同的接口，如果业务中存在大量需要被代理的类则会增加很多不必要的维护工作  </p>\n<p>​为了解决这一问题，可以看下jdk动态代理  </p>\n<p>动态代理不要求代理类与目标类实现相同的接口，但是目标类要求实现接口，通过在运行时创建实现了指定接口的对象来实现目标对象的扩展  </p>\n<hr>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>主要使用到<strong>java.lang.reflect</strong>的<strong>Proxy</strong>类的<strong>newProxyInstance</strong>方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          InvocationHandler h)</span><span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>\n<p>主要有三个参数 </p>\n<ul>\n<li><p>ClassLoader loader  </p>\n<p>ClassLoader 类加载器，用来加载生成的类，类加载器可以参考这篇</p>\n<p>[这篇]: </p>\n</li>\n</ul>\n<ul>\n<li><p>Class&lt;?&gt;[] interfaces</p>\n<p>  interfaces  代理类实现的被代理类的接口。</p>\n</li>\n<li><p>InvocationHandler h<br>  InvocationHandler 代理类的扩展处理器，具体扩展逻辑在该处理器中实现。</p>\n</li>\n</ul>\n<hr>\n<p>继续使用上面用到的<strong>IBussiness.java</strong> 接口<br>代理处理器<strong>ProxyInvocationHandler.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyInvocationHandler</span> <span class=\"keyword\">implements</span>  <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    \t<span class=\"comment\">//被代理的目标对象</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"before do something\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">//通过反射调用目标对象的方法，如果invoke传入代理对象则会出现递归调用代理对象的代理方法</span></span><br><span class=\"line\">      Object result = method.invoke(target, args);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"after do something\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(<span class=\"keyword\">this</span>.getClass().getClassLoader(),\ttarget.getClass().getInterfaces(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>JdkProxy.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       IBussiness target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">       IBussiness proxyObj = (IBussiness) <span class=\"keyword\">new</span> ProxyInvocationHandler(target).getProxy();</span><br><span class=\"line\">    </span><br><span class=\"line\">       proxyObj.doSomething();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>执行效果</strong></p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/jdk代理图1.png\" alt=\"jdk代理图1\"></p>\n<hr>\n<h3 id=\"cglib的代理\"><a href=\"#cglib的代理\" class=\"headerlink\" title=\"cglib的代理\"></a>cglib的代理</h3><p>与jdk代理不同的是cglib代理是通过运行时通过字节码库生成目标对象的子类，所以不需要像jdk代理一样目标对象需要实现接口，Spring AOP中就是根据目标对象是否实现了接口来确定使用jdk代理还是cglib代理，具体的选择在后面会讲。</p>\n<p>测试工程使用的是<strong>maven</strong>，所以在工程<strong>pom</strong>中添加cglib的依赖<br><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;3.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>继续使用上面用到的<strong>IBussiness.java</strong> 接口<br>代理处理器<strong>CglibProxy.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyObj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cglib工具类</span></span><br><span class=\"line\">        Enhancer en = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">//设置被代理对象</span></span><br><span class=\"line\">        en.setSuperclass(target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置扩展处理器</span></span><br><span class=\"line\">        en.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//返回代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> en.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before do something by cglib\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after do something by cglib\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>CglibProxyTest.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxyTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        IBussiness target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">        IBussiness proxyObj = (IBussiness) <span class=\"keyword\">new</span> CglibProxy(target).getProxyObj();</span><br><span class=\"line\">    </span><br><span class=\"line\">        proxyObj.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>运行结果</strong></p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/cglib代理图1.png\" alt=\"cglib代理图1\"></p>\n<p>可见cglib和jdk代理在代码结构上非常类似，Spring AOP则是使用这两种方式创建代理，Spring AOP中代理的扩展方法即advice扩展方法是另外指定的，而前面的代理扩展则是写死的，如何使得代理类能使用我们指定的方法呢，像AOP一样可以使用前置通知、后置通知和环绕通知。最简单的方法就是给<strong>ProxyInvocationHandler</strong>的构造方法传入想要用来扩展的方法，然后在目标对象方法的invoke之前调用扩展方法即可。<br>接下来简单的看下Spring的AOP  </p>\n<hr>\n<h2 id=\"Spring中的代理\"><a href=\"#Spring中的代理\" class=\"headerlink\" title=\"Spring中的代理\"></a>Spring中的代理</h2><p>手边的工程是用的Spring 3.0.5版本<br>在<strong>org.springframework.aop.framework</strong>包下的<strong>DefaultAopProxyFactory</strong>类中有个<strong>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException</strong> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AopProxy <span class=\"title\">createAopProxy</span><span class=\"params\">(AdvisedSupport config)</span> <span class=\"keyword\">throws</span> AopConfigException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class=\"keyword\">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdkDynamicAopProxy(config);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Class targetClass = config.getTargetClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (targetClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (targetClass.isInterface()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdkDynamicAopProxy(config);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cglibAvailable) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Cannot proxy target class because CGLIB2 is not available. Add CGLIB to the class path or specify proxy interfaces.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DefaultAopProxyFactory.CglibProxyFactory.createCglibProxy(config);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会根据被代理对象是否有实现接口来选择使用jdk代理还是cglib代理<br>跟进<strong>JdkDynamicAopProxy</strong>类可以看到<strong>getProxy()</strong>方法通过<strong>Proxy.newProxyInstance</strong>返回了一个代理对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Creating JDK dynamic proxy: target source is \"</span> + <span class=\"keyword\">this</span>.advised.getTargetSource());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class=\"keyword\">this</span>.advised);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟进,则可以看到对应的<strong>getProxy()</strong>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Creating CGLIB2 proxy: target source is \"</span> + <span class=\"keyword\">this</span>.advised.getTargetSource());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class rootClass = <span class=\"keyword\">this</span>.advised.getTargetClass();</span><br><span class=\"line\">            Assert.state(rootClass != <span class=\"keyword\">null</span>, <span class=\"string\">\"Target class must be available for creating a CGLIB proxy\"</span>);</span><br><span class=\"line\">            Class proxySuperClass = rootClass;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (AopUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class=\"line\">                proxySuperClass = rootClass.getSuperclass();</span><br><span class=\"line\">                Class[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class=\"line\">                Class[] var8 = additionalInterfaces;</span><br><span class=\"line\">                x = additionalInterfaces.length;</span><br><span class=\"line\">    </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var6 = <span class=\"number\">0</span>; var6 &lt; x; ++var6) &#123;</span><br><span class=\"line\">                    Class additionalInterface = var8[var6];</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.advised.addInterface(additionalInterface);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.validateClassIfNecessary(proxySuperClass);</span><br><span class=\"line\">            Enhancer enhancer = <span class=\"keyword\">this</span>.createEnhancer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                enhancer.setClassLoader(classLoader);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (classLoader <span class=\"keyword\">instanceof</span> SmartClassLoader &amp;&amp; ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class=\"line\">                    enhancer.setUseCache(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            enhancer.setSuperclass(proxySuperClass);</span><br><span class=\"line\">            enhancer.setStrategy(<span class=\"keyword\">new</span> UndeclaredThrowableStrategy(UndeclaredThrowableException.class));</span><br><span class=\"line\">            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class=\"keyword\">this</span>.advised));</span><br><span class=\"line\">            enhancer.setInterceptDuringConstruction(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            Callback[] callbacks = <span class=\"keyword\">this</span>.getCallbacks(rootClass);</span><br><span class=\"line\">            enhancer.setCallbacks(callbacks);</span><br><span class=\"line\">            enhancer.setCallbackFilter(<span class=\"keyword\">new</span> Cglib2AopProxy.ProxyCallbackFilter(<span class=\"keyword\">this</span>.advised.getConfigurationOnlyCopy(), <span class=\"keyword\">this</span>.fixedInterceptorMap, <span class=\"keyword\">this</span>.fixedInterceptorOffset));</span><br><span class=\"line\">            Class[] types = <span class=\"keyword\">new</span> Class[callbacks.length];</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(x = <span class=\"number\">0</span>; x &lt; types.length; ++x) &#123;</span><br><span class=\"line\">                types[x] = callbacks[x].getClass();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            enhancer.setCallbackTypes(types);</span><br><span class=\"line\">            Object proxy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructorArgs != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                proxy = enhancer.create(<span class=\"keyword\">this</span>.constructorArgTypes, <span class=\"keyword\">this</span>.constructorArgs);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                proxy = enhancer.create();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CodeGenerationException var9) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Could not generate CGLIB subclass of class [\"</span> + <span class=\"keyword\">this</span>.advised.getTargetClass() + <span class=\"string\">\"]: \"</span> + <span class=\"string\">\"Common causes of this problem include using a final class or a non-visible class\"</span>, var9);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException var10) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Could not generate CGLIB subclass of class [\"</span> + <span class=\"keyword\">this</span>.advised.getTargetClass() + <span class=\"string\">\"]: \"</span> + <span class=\"string\">\"Common causes of this problem include using a final class or a non-visible class\"</span>, var10);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception var11) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Unexpected AOP exception\"</span>, var11);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"transient关键字\"><a href=\"#transient关键字\" class=\"headerlink\" title=\"transient关键字\"></a>transient关键字</h2><p>在<strong>Cglib2AopProxy</strong>的属性中有一个transient关键字，之前基本没看到过（果然是我见识少啊）<br>这也是java的关键字之一<br>这个关键字用来标示某个属性不被序列化<br>定义一个会被序列化的类<strong>TrabsientTest.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String field1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String field2;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransientTest</span><span class=\"params\">(String field1, String field2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field1 = field1;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field2 = field2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransientTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field2 = <span class=\"string\">\"???\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"TransientTest&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"field1='\"</span> + field1 + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", field2='\"</span> + field2 + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后创建一个该类的对象并且序列化它 <strong>TestSerial.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestSerial</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransientTest obj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        TransientTest obj = <span class=\"keyword\">new</span> TransientTest(<span class=\"string\">\"test1\"</span>,<span class=\"string\">\"test2\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">        System.out.println(obj.toString());</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ObjectOutputStream o = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"obj\"</span>));</span><br><span class=\"line\">            o.writeObject(obj);</span><br><span class=\"line\">            o.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ObjectInputStream in =<span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"obj\"</span>));</span><br><span class=\"line\">            TransientTest logInfoIn = (TransientTest)in.readObject();</span><br><span class=\"line\">            System.out.println(logInfoIn.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果如图</p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/transient图1.png\" alt=\"transient图1\"></p>\n<p>​    执行后可以看到field2并没有值，在序列化时略过了field2，在反序列化的时候并没有执行构造函数给field2赋值“？？？”，反序列化并不会通过构造函数进行创建对象，而是载入了该类对象的持久化状态。</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>本篇主要讲述以下内容</p>\n<ul>\n<li>静态代理</li>\n<li>动态代理<ul>\n<li>jdk动态代理</li>\n<li>cglib动态代理。</li>\n</ul>\n</li>\n<li>Spring AOP中是怎么使用到动态代理的</li>\n<li>在spring的Cglib2AopProxy中使用到的transient关键字是做什么的","more":"</li>\n</ul>\n<h2 id=\"先来说说java的三种代理模式\"><a href=\"#先来说说java的三种代理模式\" class=\"headerlink\" title=\"先来说说java的三种代理模式\"></a>先来说说java的三种代理模式</h2><p>代理模式proxy是一种设计模式，假设目标对象A有功能functionA()，只负责他对应的业务逻辑，而调用时想在业务逻辑之前或者之后想打印些系统日志，这时候存在一个对A的增强对象proxyA，扩展了A的功能，使得通过代理对象proxyA访问目标对象A，在目标对象A实现功能的基础上扩展了额外的系统日志打印功能，在不修改A的基础上扩展了目标A的功能并且调用目标对象。</p>\n<h3 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h3><p><strong>静态代理的时候首先需要有一个接口或者父类供代理类和目标类一同实现或继承</strong>。<br>代码如下<br>接口<strong>IBussiness.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IBussiness</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目标类<strong>Target.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Target</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBussiness</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    \t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"do something\"</span>);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代理类<strong>TargetProxy.java</strong>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TargetProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">IBussiness</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> IBussiness target;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TargetProxy</span><span class=\"params\">(IBussiness target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"before do something\"</span>);</span><br><span class=\"line\">    target.doSomething();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"after do something\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>AppTest.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Rigorous Test :-)</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        assertTrue( <span class=\"keyword\">true</span> );</span><br><span class=\"line\">        Target target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">        TargetProxy proxy = <span class=\"keyword\">new</span> TargetProxy(target);</span><br><span class=\"line\">    </span><br><span class=\"line\">        proxy.doSomething();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>运行结果</strong><br><img src=\"/images/imageForPost/笔记/动态代理/静态代理图1.png\" alt=\"静态代理图1\"></p>\n<hr>\n<p>可见代理可以在不修改目标对象的情况下扩展对应的功能，但是代理对象和目标对象要实现相同的接口，如果业务中存在大量需要被代理的类则会增加很多不必要的维护工作  </p>\n<p>​为了解决这一问题，可以看下jdk动态代理  </p>\n<p>动态代理不要求代理类与目标类实现相同的接口，但是目标类要求实现接口，通过在运行时创建实现了指定接口的对象来实现目标对象的扩展  </p>\n<hr>\n<h3 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h3><p>主要使用到<strong>java.lang.reflect</strong>的<strong>Proxy</strong>类的<strong>newProxyInstance</strong>方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                          InvocationHandler h)</span><span class=\"keyword\">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>\n<p>主要有三个参数 </p>\n<ul>\n<li><p>ClassLoader loader  </p>\n<p>ClassLoader 类加载器，用来加载生成的类，类加载器可以参考这篇</p>\n<p>[这篇]: </p>\n</li>\n</ul>\n<ul>\n<li><p>Class&lt;?&gt;[] interfaces</p>\n<p>  interfaces  代理类实现的被代理类的接口。</p>\n</li>\n<li><p>InvocationHandler h<br>  InvocationHandler 代理类的扩展处理器，具体扩展逻辑在该处理器中实现。</p>\n</li>\n</ul>\n<hr>\n<p>继续使用上面用到的<strong>IBussiness.java</strong> 接口<br>代理处理器<strong>ProxyInvocationHandler.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyInvocationHandler</span> <span class=\"keyword\">implements</span>  <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    \t<span class=\"comment\">//被代理的目标对象</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProxyInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"before do something\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">//通过反射调用目标对象的方法，如果invoke传入代理对象则会出现递归调用代理对象的代理方法</span></span><br><span class=\"line\">      Object result = method.invoke(target, args);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"after do something\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(<span class=\"keyword\">this</span>.getClass().getClassLoader(),\ttarget.getClass().getInterfaces(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>JdkProxy.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Test</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">       IBussiness target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">       IBussiness proxyObj = (IBussiness) <span class=\"keyword\">new</span> ProxyInvocationHandler(target).getProxy();</span><br><span class=\"line\">    </span><br><span class=\"line\">       proxyObj.doSomething();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>执行效果</strong></p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/jdk代理图1.png\" alt=\"jdk代理图1\"></p>\n<hr>\n<h3 id=\"cglib的代理\"><a href=\"#cglib的代理\" class=\"headerlink\" title=\"cglib的代理\"></a>cglib的代理</h3><p>与jdk代理不同的是cglib代理是通过运行时通过字节码库生成目标对象的子类，所以不需要像jdk代理一样目标对象需要实现接口，Spring AOP中就是根据目标对象是否实现了接口来确定使用jdk代理还是cglib代理，具体的选择在后面会讲。</p>\n<p>测试工程使用的是<strong>maven</strong>，所以在工程<strong>pom</strong>中添加cglib的依赖<br><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;version&gt;3.1&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>继续使用上面用到的<strong>IBussiness.java</strong> 接口<br>代理处理器<strong>CglibProxy.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CglibProxy</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxyObj</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cglib工具类</span></span><br><span class=\"line\">        Enhancer en = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">//设置被代理对象</span></span><br><span class=\"line\">        en.setSuperclass(target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置扩展处理器</span></span><br><span class=\"line\">        en.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//返回代理对象</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> en.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before do something by cglib\"</span>);</span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after do something by cglib\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试类<strong>CglibProxyTest.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxyTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        IBussiness target = <span class=\"keyword\">new</span> Target();</span><br><span class=\"line\">    </span><br><span class=\"line\">        IBussiness proxyObj = (IBussiness) <span class=\"keyword\">new</span> CglibProxy(target).getProxyObj();</span><br><span class=\"line\">    </span><br><span class=\"line\">        proxyObj.doSomething();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>运行结果</strong></p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/cglib代理图1.png\" alt=\"cglib代理图1\"></p>\n<p>可见cglib和jdk代理在代码结构上非常类似，Spring AOP则是使用这两种方式创建代理，Spring AOP中代理的扩展方法即advice扩展方法是另外指定的，而前面的代理扩展则是写死的，如何使得代理类能使用我们指定的方法呢，像AOP一样可以使用前置通知、后置通知和环绕通知。最简单的方法就是给<strong>ProxyInvocationHandler</strong>的构造方法传入想要用来扩展的方法，然后在目标对象方法的invoke之前调用扩展方法即可。<br>接下来简单的看下Spring的AOP  </p>\n<hr>\n<h2 id=\"Spring中的代理\"><a href=\"#Spring中的代理\" class=\"headerlink\" title=\"Spring中的代理\"></a>Spring中的代理</h2><p>手边的工程是用的Spring 3.0.5版本<br>在<strong>org.springframework.aop.framework</strong>包下的<strong>DefaultAopProxyFactory</strong>类中有个<strong>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException</strong> 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> AopProxy <span class=\"title\">createAopProxy</span><span class=\"params\">(AdvisedSupport config)</span> <span class=\"keyword\">throws</span> AopConfigException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class=\"keyword\">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdkDynamicAopProxy(config);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Class targetClass = config.getTargetClass();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (targetClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (targetClass.isInterface()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdkDynamicAopProxy(config);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cglibAvailable) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Cannot proxy target class because CGLIB2 is not available. Add CGLIB to the class path or specify proxy interfaces.\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> DefaultAopProxyFactory.CglibProxyFactory.createCglibProxy(config);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会根据被代理对象是否有实现接口来选择使用jdk代理还是cglib代理<br>跟进<strong>JdkDynamicAopProxy</strong>类可以看到<strong>getProxy()</strong>方法通过<strong>Proxy.newProxyInstance</strong>返回了一个代理对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Creating JDK dynamic proxy: target source is \"</span> + <span class=\"keyword\">this</span>.advised.getTargetSource());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        Class[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class=\"keyword\">this</span>.advised);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟进,则可以看到对应的<strong>getProxy()</strong>方法<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">            logger.debug(<span class=\"string\">\"Creating CGLIB2 proxy: target source is \"</span> + <span class=\"keyword\">this</span>.advised.getTargetSource());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Class rootClass = <span class=\"keyword\">this</span>.advised.getTargetClass();</span><br><span class=\"line\">            Assert.state(rootClass != <span class=\"keyword\">null</span>, <span class=\"string\">\"Target class must be available for creating a CGLIB proxy\"</span>);</span><br><span class=\"line\">            Class proxySuperClass = rootClass;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (AopUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class=\"line\">                proxySuperClass = rootClass.getSuperclass();</span><br><span class=\"line\">                Class[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class=\"line\">                Class[] var8 = additionalInterfaces;</span><br><span class=\"line\">                x = additionalInterfaces.length;</span><br><span class=\"line\">    </span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> var6 = <span class=\"number\">0</span>; var6 &lt; x; ++var6) &#123;</span><br><span class=\"line\">                    Class additionalInterface = var8[var6];</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.advised.addInterface(additionalInterface);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">this</span>.validateClassIfNecessary(proxySuperClass);</span><br><span class=\"line\">            Enhancer enhancer = <span class=\"keyword\">this</span>.createEnhancer();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                enhancer.setClassLoader(classLoader);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (classLoader <span class=\"keyword\">instanceof</span> SmartClassLoader &amp;&amp; ((SmartClassLoader)classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class=\"line\">                    enhancer.setUseCache(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            enhancer.setSuperclass(proxySuperClass);</span><br><span class=\"line\">            enhancer.setStrategy(<span class=\"keyword\">new</span> UndeclaredThrowableStrategy(UndeclaredThrowableException.class));</span><br><span class=\"line\">            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class=\"keyword\">this</span>.advised));</span><br><span class=\"line\">            enhancer.setInterceptDuringConstruction(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            Callback[] callbacks = <span class=\"keyword\">this</span>.getCallbacks(rootClass);</span><br><span class=\"line\">            enhancer.setCallbacks(callbacks);</span><br><span class=\"line\">            enhancer.setCallbackFilter(<span class=\"keyword\">new</span> Cglib2AopProxy.ProxyCallbackFilter(<span class=\"keyword\">this</span>.advised.getConfigurationOnlyCopy(), <span class=\"keyword\">this</span>.fixedInterceptorMap, <span class=\"keyword\">this</span>.fixedInterceptorOffset));</span><br><span class=\"line\">            Class[] types = <span class=\"keyword\">new</span> Class[callbacks.length];</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">for</span>(x = <span class=\"number\">0</span>; x &lt; types.length; ++x) &#123;</span><br><span class=\"line\">                types[x] = callbacks[x].getClass();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            enhancer.setCallbackTypes(types);</span><br><span class=\"line\">            Object proxy;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructorArgs != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                proxy = enhancer.create(<span class=\"keyword\">this</span>.constructorArgTypes, <span class=\"keyword\">this</span>.constructorArgs);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                proxy = enhancer.create();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (CodeGenerationException var9) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Could not generate CGLIB subclass of class [\"</span> + <span class=\"keyword\">this</span>.advised.getTargetClass() + <span class=\"string\">\"]: \"</span> + <span class=\"string\">\"Common causes of this problem include using a final class or a non-visible class\"</span>, var9);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException var10) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Could not generate CGLIB subclass of class [\"</span> + <span class=\"keyword\">this</span>.advised.getTargetClass() + <span class=\"string\">\"]: \"</span> + <span class=\"string\">\"Common causes of this problem include using a final class or a non-visible class\"</span>, var10);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception var11) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AopConfigException(<span class=\"string\">\"Unexpected AOP exception\"</span>, var11);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"transient关键字\"><a href=\"#transient关键字\" class=\"headerlink\" title=\"transient关键字\"></a>transient关键字</h2><p>在<strong>Cglib2AopProxy</strong>的属性中有一个transient关键字，之前基本没看到过（果然是我见识少啊）<br>这也是java的关键字之一<br>这个关键字用来标示某个属性不被序列化<br>定义一个会被序列化的类<strong>TrabsientTest.java</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransientTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String field1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> String field2;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransientTest</span><span class=\"params\">(String field1, String field2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field1 = field1;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field2 = field2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TransientTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.field2 = <span class=\"string\">\"???\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"TransientTest&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"field1='\"</span> + field1 + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">\", field2='\"</span> + field2 + <span class=\"string\">'\\''</span> +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后创建一个该类的对象并且序列化它 <strong>TestSerial.java</strong><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestSerial</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransientTest obj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shouldAnswerWithTrue</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        TransientTest obj = <span class=\"keyword\">new</span> TransientTest(<span class=\"string\">\"test1\"</span>,<span class=\"string\">\"test2\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">        System.out.println(obj.toString());</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ObjectOutputStream o = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"obj\"</span>));</span><br><span class=\"line\">            o.writeObject(obj);</span><br><span class=\"line\">            o.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ObjectInputStream in =<span class=\"keyword\">new</span> ObjectInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"obj\"</span>));</span><br><span class=\"line\">            TransientTest logInfoIn = (TransientTest)in.readObject();</span><br><span class=\"line\">            System.out.println(logInfoIn.toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>结果如图</p>\n<p><img src=\"/images/imageForPost/笔记/动态代理/transient图1.png\" alt=\"transient图1\"></p>\n<p>​    执行后可以看到field2并没有值，在序列化时略过了field2，在反序列化的时候并没有执行构造函数给field2赋值“？？？”，反序列化并不会通过构造函数进行创建对象，而是载入了该类对象的持久化状态。</p>"},{"title":"PMP笔记","date":"2010-01-24T07:10:16.000Z","comments":1,"toc":true,"_content":"PMP笔记 building...\n<!-- more -->    \n## 项目章程  \n项目章程主要有项目发起人或者启动者发布的  \n\n\n项目的收益 = 潜在收益-投资成本-运营成本  \n石川图 鱼骨图 whywhy分析图 因果图 将问题陈述的原因分解为离散的分支  有助于识别问题的主要原因或者根本原因  \n\nX理论  性本恶     Y理论 性本善\n\n\n帕累托图 找主要原因 一种特殊的垂直条形图 用于识别造成大多数问题的少数重要原因\n\n\n散点图是一种展示两个变量之间的关系的图形，它能够展示两支轴的关系，一支轴表示过程、环境或活动的任何要素，另一支轴表示质量缺陷。\n","source":"_posts/pmp/启动过程组.md","raw":"---\ntitle: PMP笔记\ndate: 2010-01-24 15:10:16\ncomments: true\ncategories: \n  - 总结\ntags: \n  - pmp\ntoc: true\n---\nPMP笔记 building...\n<!-- more -->    \n## 项目章程  \n项目章程主要有项目发起人或者启动者发布的  \n\n\n项目的收益 = 潜在收益-投资成本-运营成本  \n石川图 鱼骨图 whywhy分析图 因果图 将问题陈述的原因分解为离散的分支  有助于识别问题的主要原因或者根本原因  \n\nX理论  性本恶     Y理论 性本善\n\n\n帕累托图 找主要原因 一种特殊的垂直条形图 用于识别造成大多数问题的少数重要原因\n\n\n散点图是一种展示两个变量之间的关系的图形，它能够展示两支轴的关系，一支轴表示过程、环境或活动的任何要素，另一支轴表示质量缺陷。\n","slug":"pmp/启动过程组","published":1,"updated":"2020-01-29T14:00:39.299Z","_id":"ck5y2x96000005xrme9pg2z0i","layout":"post","photos":[],"link":"","content":"<p>PMP笔记 building…<br><a id=\"more\"></a>    </p>\n<h2 id=\"项目章程\"><a href=\"#项目章程\" class=\"headerlink\" title=\"项目章程\"></a>项目章程</h2><p>项目章程主要有项目发起人或者启动者发布的  </p>\n<p>项目的收益 = 潜在收益-投资成本-运营成本<br>石川图 鱼骨图 whywhy分析图 因果图 将问题陈述的原因分解为离散的分支  有助于识别问题的主要原因或者根本原因  </p>\n<p>X理论  性本恶     Y理论 性本善</p>\n<p>帕累托图 找主要原因 一种特殊的垂直条形图 用于识别造成大多数问题的少数重要原因</p>\n<p>散点图是一种展示两个变量之间的关系的图形，它能够展示两支轴的关系，一支轴表示过程、环境或活动的任何要素，另一支轴表示质量缺陷。</p>\n","site":{"data":{"links":{"Sincerity":{"link":"http://chenjianhui.site","avatar":"https://chenjianhui.site/images/avatar.png","desc":"Web Developer"}}}},"excerpt":"<p>PMP笔记 building…<br>","more":"</p>\n<h2 id=\"项目章程\"><a href=\"#项目章程\" class=\"headerlink\" title=\"项目章程\"></a>项目章程</h2><p>项目章程主要有项目发起人或者启动者发布的  </p>\n<p>项目的收益 = 潜在收益-投资成本-运营成本<br>石川图 鱼骨图 whywhy分析图 因果图 将问题陈述的原因分解为离散的分支  有助于识别问题的主要原因或者根本原因  </p>\n<p>X理论  性本恶     Y理论 性本善</p>\n<p>帕累托图 找主要原因 一种特殊的垂直条形图 用于识别造成大多数问题的少数重要原因</p>\n<p>散点图是一种展示两个变量之间的关系的图形，它能够展示两支轴的关系，一支轴表示过程、环境或活动的任何要素，另一支轴表示质量缺陷。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck5ibb8sz0001d4rm1v8fe8qb","category_id":"ck5ibb8t50003d4rmqfydel1b","_id":"ck5ibb8t90006d4rm15v4k0ts"},{"post_id":"ck5ibb8v0000pd4rmwsv1oycs","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5ibb8v40012d4rmjcgslfuy"},{"post_id":"ck5ibb8up000dd4rmuzxhzmzz","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5ibb8v40014d4rm6t80t6u8"},{"post_id":"ck5ibb8vn0018d4rmhpk4awjp","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5ibb8vr001ed4rmorkps23i"},{"post_id":"ck5ibb8vo0019d4rmd2upyad6","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5ibb8vs001gd4rmkdc52c6v"},{"post_id":"ck5ibb8us000fd4rm3gwims6z","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5z0eew2000195rm9h68ktjo"},{"post_id":"ck5ibb8um0009d4rmbmwa9x1e","category_id":"ck5ibb8t50003d4rmqfydel1b","_id":"ck5z0elg9000295rmv6fnphz7"},{"post_id":"ck5ibb8uw000kd4rmtbfbwv4y","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5z0fyhu000795rmwsothapi"},{"post_id":"ck5ibb8vq001dd4rm6rdi7cst","category_id":"ck5ibb8uo000bd4rm8zwxubbd","_id":"ck5z0g0wo000895rmhmh9mgtb"},{"post_id":"ck5ibb8vp001bd4rmteu47h7c","category_id":"ck5ibb8t50003d4rmqfydel1b","_id":"ck5z0gu1y000995rmiv0c6jh7"},{"post_id":"ck5y2x96000005xrme9pg2z0i","category_id":"ck5z0hhk1000a95rmjotv52yx","_id":"ck5z0hhk1000b95rmjz5vg99m"}],"PostTag":[{"post_id":"ck5ibb8sz0001d4rm1v8fe8qb","tag_id":"ck5ibb8t70004d4rmubv6500h","_id":"ck5ibb8t80005d4rmzmgulr7g"},{"post_id":"ck5ibb8um0009d4rmbmwa9x1e","tag_id":"ck5ibb8up000cd4rm1928ns4x","_id":"ck5ibb8uu000id4rmk1k526j4"},{"post_id":"ck5ibb8uw000kd4rmtbfbwv4y","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8v2000vd4rm6n5nb375"},{"post_id":"ck5ibb8v0000pd4rmwsv1oycs","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8v3000xd4rm6l27qmor"},{"post_id":"ck5ibb8up000dd4rmuzxhzmzz","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8v40011d4rmxv6zjyod"},{"post_id":"ck5ibb8us000fd4rm3gwims6z","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8v50016d4rmnz5g64y4"},{"post_id":"ck5ibb8vn0018d4rmhpk4awjp","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8vp001ad4rmx7euquu0"},{"post_id":"ck5ibb8vo0019d4rmd2upyad6","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8vq001cd4rm8b39i1q6"},{"post_id":"ck5ibb8vp001bd4rmteu47h7c","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8vr001fd4rmf7xr0cvh"},{"post_id":"ck5ibb8vq001dd4rm6rdi7cst","tag_id":"ck5ibb8ut000hd4rmvlzzjdl9","_id":"ck5ibb8vs001hd4rm60bkbsr0"},{"post_id":"ck5y2x96000005xrme9pg2z0i","tag_id":"ck5y2x96800015xrmusodqqsd","_id":"ck5y2x96d00035xrm2e0eawje"}],"Tag":[{"name":"devops","_id":"ck5ibb8t70004d4rmubv6500h"},{"name":"Linux","_id":"ck5ibb8up000cd4rm1928ns4x"},{"name":"java","_id":"ck5ibb8ut000hd4rmvlzzjdl9"},{"name":"pmp","_id":"ck5y2x96800015xrmusodqqsd"}]}}